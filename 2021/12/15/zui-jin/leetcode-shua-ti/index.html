<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>LeetCode刷题 | pengber&#39;s site</title>
  <meta name="keywords" content=" C++ , Java , python , github ">
  <meta name="description" content="LeetCode刷题 | pengber&#39;s site">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="个人简介pengber 本科毕业于北京化工大学, 硕士就读于北京邮电大学. 联系方式邮箱: pengber@126.com">
<meta property="og:type" content="website">
<meta property="og:title" content="pengber&#39;s site">
<meta property="og:url" content="https://pengber.github.io/about/index.html">
<meta property="og:site_name" content="pengber&#39;s site">
<meta property="og:description" content="个人简介pengber 本科毕业于北京化工大学, 硕士就读于北京邮电大学. 联系方式邮箱: pengber@126.com">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-15T11:15:27.280Z">
<meta property="article:modified_time" content="2022-07-15T11:15:22.204Z">
<meta property="article:author" content="pengber">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>pengber</span>
</div>

<div class="icon">
    
        
    
        
            <a title="github"
               href="https://github.com/pengber"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:pengber@126.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(264)</small>
            
        </div>
    </li>
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="计算机">
                        <i class="fold iconfont icon-right"></i>
                        
                        计算机
                        <small>(117)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="计算机<--->编程语言">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        编程语言
                                        
                                            <small>(24
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="计算机<--->编程语言其它">
                                                        
                                                        其它
                                                        
                                                            <small>(6)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="计算机<--->编程语言C">
                                                        
                                                        C
                                                        
                                                            <small>(6)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="计算机<--->编程语言JAVA">
                                                        
                                                        JAVA
                                                        
                                                            <small>(6)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="计算机<--->编程语言PHP">
                                                        
                                                        PHP
                                                        
                                                            <small>(1)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="计算机<--->编程语言Python">
                                                        
                                                        Python
                                                        
                                                            <small>(5)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="计算机<--->集成开发环境">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        集成开发环境
                                        
                                            <small>(37
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="计算机<--->集成开发环境IDEA">
                                                        
                                                        IDEA
                                                        
                                                            <small>(1)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="计算机<--->集成开发环境linux">
                                                        
                                                        linux
                                                        
                                                            <small>(9)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="计算机<--->集成开发环境sublime">
                                                        
                                                        sublime
                                                        
                                                            <small>(1)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="计算机<--->集成开发环境Vs2019">
                                                        
                                                        Vs2019
                                                        
                                                            <small>(1)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="计算机<--->集成开发环境VsCode">
                                                        
                                                        VsCode
                                                        
                                                            <small>(9)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="计算机<--->集成开发环境WAMP">
                                                        
                                                        WAMP
                                                        
                                                            <small>(6)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="计算机<--->集成开发环境windows">
                                                        
                                                        windows
                                                        
                                                            <small>(10)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="计算机<--->计算机理论与数学">
                                        
                                        计算机理论与数学
                                        
                                            <small>(4
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="计算机<--->计算机图形学">
                                        
                                        计算机图形学
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="计算机<--->计算机网络">
                                        
                                        计算机网络
                                        
                                            <small>(9
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="计算机<--->计算机硬件">
                                        
                                        计算机硬件
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="计算机<--->计算机组成原理和系统结构">
                                        
                                        计算机组成原理和系统结构
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="计算机<--->其他计算机">
                                        
                                        其他计算机
                                        
                                            <small>(6
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="计算机<--->人工智能">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        人工智能
                                        
                                            <small>(9
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="计算机<--->人工智能机器学习">
                                                        
                                                        机器学习
                                                        
                                                            <small>(5)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="计算机<--->人工智能自然语言处理">
                                                        
                                                        自然语言处理
                                                        
                                                            <small>(2)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="计算机<--->软件开发">
                                        
                                        软件开发
                                        
                                            <small>(4
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="计算机<--->实验室">
                                        
                                        实验室
                                        
                                            <small>(9
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="计算机<--->算法与数据结构">
                                        
                                        算法与数据结构
                                        
                                            <small>(4
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="金融">
                        <i class="fold iconfont icon-right"></i>
                        
                        金融
                        <small>(27)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="金融<--->金融知识">
                                        
                                        金融知识
                                        
                                            <small>(15
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="金融<--->经济周期与宏观调控">
                                        
                                        经济周期与宏观调控
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="金融<--->投资记录">
                                        
                                        投资记录
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="金融<--->投资理念">
                                        
                                        投资理念
                                        
                                            <small>(6
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="金融<--->行业个股">
                                        
                                        行业个股
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="修身">
                        <i class="fold iconfont icon-right"></i>
                        
                        修身
                        <small>(70)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="修身<--->创业">
                                        
                                        创业
                                        
                                            <small>(17
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="修身<--->工作">
                                        
                                        工作
                                        
                                            <small>(9
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="修身<--->奇思妙想">
                                        
                                        奇思妙想
                                        
                                            <small>(10
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="修身<--->三省吾身">
                                        
                                        三省吾身
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="修身<--->生活技能">
                                        
                                        生活技能
                                        
                                            <small>(10
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="修身<--->生活知识">
                                        
                                        生活知识
                                        
                                            <small>(21
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="学科">
                        <i class="fold iconfont icon-right"></i>
                        
                        学科
                        <small>(31)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="学科<--->历史">
                                        
                                        历史
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="学科<--->其他学科">
                                        
                                        其他学科
                                        
                                            <small>(4
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="学科<--->社会科学">
                                        
                                        社会科学
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="学科<--->文学">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        文学
                                        
                                            <small>(9
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="学科<--->文学村上春树">
                                                        
                                                        村上春树
                                                        
                                                            <small>(6)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="学科<--->心理学">
                                        
                                        心理学
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="学科<--->影评">
                                        
                                        影评
                                        
                                            <small>(4
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="学科<--->政治">
                                        
                                        政治
                                        
                                            <small>(8
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="运动">
                        <i class="fold iconfont icon-right"></i>
                        
                        运动
                        <small>(6)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="运动<--->足球">
                                        
                                        足球
                                        
                                            <small>(6
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="真其它">
                        
                        真其它
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="最近">
                        
                        最近
                        <small>(12)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="264">
<input type="hidden" id="yelog_site_word_count" value="436k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C++</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>PHP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>python</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>pytorch</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>WAMP</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 最近 "
           href="/2022/09/13/zui-jin/202209-ji-hui/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="202209机会">202209机会</span>
            <span class="post-date" title="2022-09-13 09:07:15">2022/09/13</span>
        </a>
        
        
        <a  class="全部文章 学科 心理学 "
           href="/2022/09/12/xue-ke/xin-li-xue/shi-liu-ren-ge/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="十六人格">十六人格</span>
            <span class="post-date" title="2022-09-12 00:05:27">2022/09/12</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2022/09/11/xiu-shen/sheng-huo-zhi-shi/pei-yan-jing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="配眼镜">配眼镜</span>
            <span class="post-date" title="2022-09-11 22:47:23">2022/09/11</span>
        </a>
        
        
        <a  class="全部文章 学科 政治 "
           href="/2022/09/01/xue-ke/zheng-zhi/wo-guo-jue-ce-ti-xi-ji-ji-gou/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="我国决策体系及机构">我国决策体系及机构</span>
            <span class="post-date" title="2022-09-01 17:27:48">2022/09/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 人工智能 自然语言处理 "
           href="/2022/09/01/ji-suan-ji/ren-gong-zhi-neng/zi-ran-yu-yan-chu-li/speech-language-aprocess/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Speech language aprocess">Speech language aprocess</span>
            <span class="post-date" title="2022-09-01 16:12:26">2022/09/01</span>
        </a>
        
        
        <a  class="全部文章 学科 历史 "
           href="/2022/08/25/xue-ke/li-shi/ming-zhao-zhao-dai-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="明朝朝代总结">明朝朝代总结</span>
            <span class="post-date" title="2022-08-25 23:18:36">2022/08/25</span>
        </a>
        
        
        <a  class="全部文章 修身 工作 "
           href="/2022/08/17/xiu-shen/gong-zuo/bi-shi-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="笔试总结">笔试总结</span>
            <span class="post-date" title="2022-08-17 14:57:53">2022/08/17</span>
        </a>
        
        
        <a  class="全部文章 计算机 人工智能 "
           href="/2022/08/14/ji-suan-ji/ren-gong-zhi-neng/ren-gong-zhi-neng-ling-san-zhi-shi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="人工智能零散知识">人工智能零散知识</span>
            <span class="post-date" title="2022-08-14 11:43:48">2022/08/14</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2022/08/09/jin-rong/jin-rong-zhi-shi/wen-da/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="问答">问答</span>
            <span class="post-date" title="2022-08-09 09:28:56">2022/08/09</span>
        </a>
        
        
        <a  class="全部文章 计算机 "
           href="/2022/08/02/ji-suan-ji/2022-nian-6-yue/"
           data-tag="python,github,PHP"
           data-author="" >
            <span class="post-title" title="2022年6月">2022年6月</span>
            <span class="post-date" title="2022-08-02 19:50:38">2022/08/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 "
           href="/2022/08/01/ji-suan-ji/you-jian-fen-lei/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="邮件分类">邮件分类</span>
            <span class="post-date" title="2022-08-01 14:58:41">2022/08/01</span>
        </a>
        
        
        <a  class="全部文章 修身 工作 "
           href="/2022/08/01/xiu-shen/gong-zuo/gong-zuo-fang-xiang/"
           data-tag="C++,Java"
           data-author="" >
            <span class="post-title" title="工作方向">工作方向</span>
            <span class="post-date" title="2022-08-01 09:12:53">2022/08/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 "
           href="/2022/07/31/ji-suan-ji/ibizsim/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="ibizsim">ibizsim</span>
            <span class="post-date" title="2022-07-31 16:40:37">2022/07/31</span>
        </a>
        
        
        <a  class="全部文章 修身 奇思妙想 "
           href="/2022/07/30/xiu-shen/qi-si-miao-xiang/sui-bian-xiang-xiang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="随便想想">随便想想</span>
            <span class="post-date" title="2022-07-30 15:23:54">2022/07/30</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2022/07/29/xiu-shen/sheng-huo-zhi-shi/a-sheng-huo-chang-shi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="阿生活常识">阿生活常识</span>
            <span class="post-date" title="2022-07-29 22:23:48">2022/07/29</span>
        </a>
        
        
        <a  class="全部文章 计算机 人工智能 自然语言处理 "
           href="/2022/07/25/ji-suan-ji/ren-gong-zhi-neng/zi-ran-yu-yan-chu-li/text-to-table/"
           data-tag="python,pytorch"
           data-author="" >
            <span class="post-title" title="text_to_table">text_to_table</span>
            <span class="post-date" title="2022-07-25 19:49:50">2022/07/25</span>
        </a>
        
        
        <a  class="全部文章 学科 影评 "
           href="/2022/07/24/xue-ke/ying-ping/da-ming-wang-zhao-1566/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="大明王朝1566">大明王朝1566</span>
            <span class="post-date" title="2022-07-24 17:03:10">2022/07/24</span>
        </a>
        
        
        <a  class="全部文章 修身 奇思妙想 "
           href="/2022/07/24/xiu-shen/qi-si-miao-xiang/ni-ke-yi-ti-wo-qu-zuo-mou-jian-shi-ma/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="你可以替我去做某件事吗">你可以替我去做某件事吗</span>
            <span class="post-date" title="2022-07-24 15:59:13">2022/07/24</span>
        </a>
        
        
        <a  class="全部文章 计算机 实验室 "
           href="/2022/07/22/ji-suan-ji/shi-yan-shi/zhan-chang-ben-ti-gou-jian-1-9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="战场本体构建1-9">战场本体构建1-9</span>
            <span class="post-date" title="2022-07-22 09:23:24">2022/07/22</span>
        </a>
        
        
        <a  class="全部文章 计算机 实验室 "
           href="/2022/07/21/ji-suan-ji/shi-yan-shi/ooda/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="OODA">OODA</span>
            <span class="post-date" title="2022-07-21 11:32:54">2022/07/21</span>
        </a>
        
        
        <a  class="全部文章 金融 投资记录 "
           href="/2022/07/20/jin-rong/tou-zi-ji-lu/2022-nian-tou-zi-ji-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2022年投资记录">2022年投资记录</span>
            <span class="post-date" title="2022-07-20 14:48:25">2022/07/20</span>
        </a>
        
        
        <a  class="全部文章 金融 投资记录 "
           href="/2022/07/20/jin-rong/tou-zi-ji-lu/2021-nian-tou-zi-ji-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2021年投资记录">2021年投资记录</span>
            <span class="post-date" title="2022-07-20 14:47:52">2022/07/20</span>
        </a>
        
        
        <a  class="全部文章 修身 工作 "
           href="/2022/07/18/xiu-shen/gong-zuo/da-jin-rong-xing-ye/"
           data-tag="C++,Java"
           data-author="" >
            <span class="post-title" title="大金融行业">大金融行业</span>
            <span class="post-date" title="2022-07-18 23:17:05">2022/07/18</span>
        </a>
        
        
        <a  class="全部文章 计算机 软件开发 "
           href="/2022/07/17/ji-suan-ji/ruan-jian-kai-fa/da-xue-zui-hou-yi-gong-li/"
           data-tag="WAMP"
           data-author="" >
            <span class="post-title" title="大学最后一公里">大学最后一公里</span>
            <span class="post-date" title="2022-07-17 16:02:41">2022/07/17</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2022/07/15/xiu-shen/sheng-huo-zhi-shi/index/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="index">index</span>
            <span class="post-date" title="2022-07-15 19:10:05">2022/07/15</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2022/07/15/xiu-shen/sheng-huo-zhi-shi/indexs/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="indexs">indexs</span>
            <span class="post-date" title="2022-07-15 15:51:06">2022/07/15</span>
        </a>
        
        
        <a  class="全部文章 最近 "
           href="/2022/07/08/zui-jin/shen-du-xue-xi-li-hong-yi/"
           data-tag="python,github,PHP,pytorch"
           data-author="" >
            <span class="post-title" title="深度学习李宏毅">深度学习李宏毅</span>
            <span class="post-date" title="2022-07-08 19:57:13">2022/07/08</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 windows "
           href="/2022/07/06/ji-suan-ji/ji-cheng-kai-fa-huan-jing/windows/hexo-github-da-jian-jing-tai-bo-ke/"
           data-tag="C++,Java,python,github,PHP,pytorch,WAMP"
           data-author="" >
            <span class="post-title" title="hexo+github搭建静态博客">hexo+github搭建静态博客</span>
            <span class="post-date" title="2022-07-06 10:09:35">2022/07/06</span>
        </a>
        
        
        <a  class="全部文章 修身 工作 "
           href="/2022/07/01/xiu-shen/gong-zuo/mian-shi-wen-ti/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="面试问题">面试问题</span>
            <span class="post-date" title="2022-07-01 16:56:21">2022/07/01</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2022/07/01/xiu-shen/chuang-ye/mi-xue-bing-cheng-diao-yan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="蜜雪冰城调研">蜜雪冰城调研</span>
            <span class="post-date" title="2022-07-01 00:27:36">2022/07/01</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2022/06/27/xiu-shen/sheng-huo-zhi-shi/tu-shu-guan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="图书馆">图书馆</span>
            <span class="post-date" title="2022-06-27 17:19:13">2022/06/27</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2022/06/23/xiu-shen/sheng-huo-zhi-shi/bei-you-2022-zhao-sheng-xuan-chuan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="北邮2022招生宣传">北邮2022招生宣传</span>
            <span class="post-date" title="2022-06-23 17:13:50">2022/06/23</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机理论与数学 "
           href="/2022/06/22/ji-suan-ji/ji-suan-ji-li-lun-yu-shu-xue/nao-ren-zhi/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="脑认知">脑认知</span>
            <span class="post-date" title="2022-06-22 00:23:58">2022/06/22</span>
        </a>
        
        
        <a  class="全部文章 计算机 其他计算机 "
           href="/2022/06/17/ji-suan-ji/qi-ta-ji-suan-ji/eeg-shi-yan/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="EEG实验">EEG实验</span>
            <span class="post-date" title="2022-06-17 15:57:34">2022/06/17</span>
        </a>
        
        
        <a  class="全部文章 修身 三省吾身 "
           href="/2022/06/08/xiu-shen/san-sheng-wu-shen/wu-ri-san-sheng-wu-shen-shi-jian-xian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="吾日三省吾身-时间线">吾日三省吾身-时间线</span>
            <span class="post-date" title="2022-06-08 00:40:11">2022/06/08</span>
        </a>
        
        
        <a  class="全部文章 学科 心理学 "
           href="/2022/06/08/xue-ke/xin-li-xue/xin-li-xue-gai-nian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="心理学概念">心理学概念</span>
            <span class="post-date" title="2022-06-08 00:33:28">2022/06/08</span>
        </a>
        
        
        <a  class="全部文章 修身 三省吾身 "
           href="/2022/06/08/xiu-shen/san-sheng-wu-shen/wu-ri-san-sheng-wu-shen-zhuang-tai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="吾日三省吾身-状态">吾日三省吾身-状态</span>
            <span class="post-date" title="2022-06-08 00:01:16">2022/06/08</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2022/06/06/xiu-shen/sheng-huo-zhi-shi/ge-ren-du-ju-zhi-nan/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="个人独居指南">个人独居指南</span>
            <span class="post-date" title="2022-06-06 10:34:31">2022/06/06</span>
        </a>
        
        
        <a  class="全部文章 修身 三省吾身 "
           href="/2022/05/24/xiu-shen/san-sheng-wu-shen/nan-de/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="男德">男德</span>
            <span class="post-date" title="2022-05-24 22:34:49">2022/05/24</span>
        </a>
        
        
        <a  class="全部文章 运动 足球 "
           href="/2022/05/21/yun-dong/zu-qiu/cai-pan-gui-ze/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="裁判规则">裁判规则</span>
            <span class="post-date" title="2022-05-21 09:21:11">2022/05/21</span>
        </a>
        
        
        <a  class="全部文章 学科 影评 "
           href="/2022/05/10/xue-ke/ying-ping/er-shi-wu-er-shi-yi-dai-2022-05-10/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二十五二十一(待)">二十五二十一(待)</span>
            <span class="post-date" title="2022-05-10 00:00:00">2022/05/10</span>
        </a>
        
        
        <a  class="全部文章 修身 生活技能 "
           href="/2022/05/05/xiu-shen/sheng-huo-ji-neng/chang-yong-ruan-jian-lie-biao/"
           data-tag="C++,Java,python,github,PHP"
           data-author="" >
            <span class="post-title" title="常用软件列表">常用软件列表</span>
            <span class="post-date" title="2022-05-05 20:39:34">2022/05/05</span>
        </a>
        
        
        <a  class="全部文章 计算机 实验室 "
           href="/2022/04/22/ji-suan-ji/shi-yan-shi/mo-zi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="墨子">墨子</span>
            <span class="post-date" title="2022-04-22 21:37:54">2022/04/22</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2022/04/11/xiu-shen/sheng-huo-zhi-shi/liu-xue-yi-min/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="留学移民">留学移民</span>
            <span class="post-date" title="2022-04-11 12:14:10">2022/04/11</span>
        </a>
        
        
        <a  class="全部文章 修身 生活技能 "
           href="/2022/04/06/xiu-shen/sheng-huo-ji-neng/kou-qin-xue-xi-ji-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="口琴学习记录">口琴学习记录</span>
            <span class="post-date" title="2022-04-06 19:58:36">2022/04/06</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机理论与数学 "
           href="/2022/03/13/ji-suan-ji/ji-suan-ji-li-lun-yu-shu-xue/yun-ji-suan-an-quan/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="云计算安全">云计算安全</span>
            <span class="post-date" title="2022-03-13 01:31:07">2022/03/13</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2022/03/12/xiu-shen/sheng-huo-zhi-shi/bei-jing-pi-fu-yi-yuan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="北京皮肤医院">北京皮肤医院</span>
            <span class="post-date" title="2022-03-12 10:51:09">2022/03/12</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2022/03/10/xiu-shen/chuang-ye/zhu-xiao-gong-si-liu-cheng/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="注销公司流程">注销公司流程</span>
            <span class="post-date" title="2022-03-10 08:34:44">2022/03/10</span>
        </a>
        
        
        <a  class="全部文章 计算机 软件开发 "
           href="/2022/02/28/ji-suan-ji/ruan-jian-kai-fa/an-zhuo-kai-fa/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安卓开发">安卓开发</span>
            <span class="post-date" title="2022-02-28 14:31:46">2022/02/28</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2022/02/24/jin-rong/jin-rong-zhi-shi/ji-jin/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基金">基金</span>
            <span class="post-date" title="2022-02-24 11:00:05">2022/02/24</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2022/02/24/xiu-shen/sheng-huo-zhi-shi/shan-zhong-yi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="陕中医">陕中医</span>
            <span class="post-date" title="2022-02-24 00:07:37">2022/02/24</span>
        </a>
        
        
        <a  class="全部文章 计算机 "
           href="/2022/02/15/ji-suan-ji/2022-nian-zu-hui-hui-bao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2022年组会汇报">2022年组会汇报</span>
            <span class="post-date" title="2022-02-15 21:07:52">2022/02/15</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2022/02/11/jin-rong/jin-rong-zhi-shi/hong-guan-liang-hua/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="宏观量化">宏观量化</span>
            <span class="post-date" title="2022-02-11 01:11:46">2022/02/11</span>
        </a>
        
        
        <a  class="全部文章 最近 "
           href="/2022/02/08/zui-jin/ge-ci/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="歌词">歌词</span>
            <span class="post-date" title="2022-02-08 21:18:46">2022/02/08</span>
        </a>
        
        
        <a  class="全部文章 修身 生活技能 "
           href="/2022/02/06/xiu-shen/sheng-huo-ji-neng/ru-he-shi-yong-liu-lan-qi-cha-jian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何使用浏览器插件">如何使用浏览器插件</span>
            <span class="post-date" title="2022-02-06 13:03:56">2022/02/06</span>
        </a>
        
        
        <a  class="全部文章 计算机 实验室 "
           href="/2022/02/05/ji-suan-ji/shi-yan-shi/shu-zi-luan-sheng/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数字孪生">数字孪生</span>
            <span class="post-date" title="2022-02-05 10:47:14">2022/02/05</span>
        </a>
        
        
        <a  class="全部文章 金融 经济周期与宏观调控 "
           href="/2022/01/27/jin-rong/jing-ji-zhou-qi-yu-hong-guan-diao-kong/qi-ye-wei-guan-jing-ji-zhi-biao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="企业微观经济指标">企业微观经济指标</span>
            <span class="post-date" title="2022-01-27 23:11:24">2022/01/27</span>
        </a>
        
        
        <a  class="全部文章 最近 "
           href="/2022/01/22/zui-jin/finmanage/"
           data-tag="Java,github"
           data-author="" >
            <span class="post-title" title="FinManage">FinManage</span>
            <span class="post-date" title="2022-01-22 17:49:15">2022/01/22</span>
        </a>
        
        
        <a  class="全部文章 修身 生活技能 "
           href="/2022/01/21/xiu-shen/sheng-huo-ji-neng/zhuang-xiu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="装修">装修</span>
            <span class="post-date" title="2022-01-21 18:51:33">2022/01/21</span>
        </a>
        
        
        <a  class="全部文章 修身 奇思妙想 "
           href="/2022/01/13/xiu-shen/qi-si-miao-xiang/guo-ren-quan-qiu-da-jiang-tang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="国任全球大讲堂">国任全球大讲堂</span>
            <span class="post-date" title="2022-01-13 23:09:16">2022/01/13</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2022/01/13/xiu-shen/sheng-huo-zhi-shi/lu-you/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="旅游">旅游</span>
            <span class="post-date" title="2022-01-13 20:54:01">2022/01/13</span>
        </a>
        
        
        <a  class="全部文章 计算机 软件开发 "
           href="/2022/01/12/ji-suan-ji/ruan-jian-kai-fa/yu-yin-xiang-mu-ji-lu/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="语音项目记录">语音项目记录</span>
            <span class="post-date" title="2022-01-12 14:23:32">2022/01/12</span>
        </a>
        
        
        <a  class="全部文章 计算机 实验室 "
           href="/2022/01/09/ji-suan-ji/shi-yan-shi/b4talk-dong-tai-lian-jie-ku/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="b4talk动态链接库">b4talk动态链接库</span>
            <span class="post-date" title="2022-01-09 15:26:31">2022/01/09</span>
        </a>
        
        
        <a  class="全部文章 最近 "
           href="/2022/01/08/zui-jin/kai-fa-ba-gu-wen/"
           data-tag="Java,github"
           data-author="" >
            <span class="post-title" title="开发八股文">开发八股文</span>
            <span class="post-date" title="2022-01-08 20:15:56">2022/01/08</span>
        </a>
        
        
        <a  class="全部文章 学科 社会科学 "
           href="/2022/01/08/xue-ke/she-hui-ke-xue/pin-qiong-de-ben-zhi-2022-01-08/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="贫穷的本质">贫穷的本质</span>
            <span class="post-date" title="2022-01-08 00:00:00">2022/01/08</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2022/01/06/jin-rong/jin-rong-zhi-shi/zheng-fu-yu-suan-xu-yao-guan-zhu-de-shu-ju/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="政府预算需要关注的数据">政府预算需要关注的数据</span>
            <span class="post-date" title="2022-01-06 11:47:23">2022/01/06</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2022/01/05/jin-rong/jin-rong-zhi-shi/hong-guan-jing-ji-shu-ju/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="宏观经济数据">宏观经济数据</span>
            <span class="post-date" title="2022-01-05 21:22:01">2022/01/05</span>
        </a>
        
        
        <a  class="全部文章 最近 "
           href="/2022/01/05/zui-jin/a-ren-sheng-zhi-dao/"
           data-tag="Java,github"
           data-author="" >
            <span class="post-title" title="阿人生指导">阿人生指导</span>
            <span class="post-date" title="2022-01-05 00:59:40">2022/01/05</span>
        </a>
        
        
        <a  class="全部文章 修身 生活技能 "
           href="/2022/01/01/xiu-shen/sheng-huo-ji-neng/gan-xing-qu-zheng-shu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="感兴趣证书">感兴趣证书</span>
            <span class="post-date" title="2022-01-01 17:26:31">2022/01/01</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2022/01/01/jin-rong/jin-rong-zhi-shi/zhong-guo-shi-zheng-fu-yu-suan-de-bei-xi-zhi-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中国式政府预算的悲喜之路">中国式政府预算的悲喜之路</span>
            <span class="post-date" title="2022-01-01 15:28:58">2022/01/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机硬件 "
           href="/2021/12/30/ji-suan-ji/ji-suan-ji-ying-jian/shou-ji-zhi-shi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="手机知识">手机知识</span>
            <span class="post-date" title="2021-12-30 22:38:10">2021/12/30</span>
        </a>
        
        
        <a  class="全部文章 修身 工作 "
           href="/2021/12/28/xiu-shen/gong-zuo/ding-ju-sheng-huo-fen-xi/"
           data-tag="C++,Java"
           data-author="" >
            <span class="post-title" title="定居生活分析">定居生活分析</span>
            <span class="post-date" title="2021-12-28 17:15:00">2021/12/28</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2021/12/28/jin-rong/jin-rong-zhi-shi/fang-di-chan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="房地产">房地产</span>
            <span class="post-date" title="2021-12-28 15:42:43">2021/12/28</span>
        </a>
        
        
        <a  class="全部文章 计算机 人工智能 机器学习 "
           href="/2021/12/27/ji-suan-ji/ren-gong-zhi-neng/ji-qi-xue-xi/gao-ji-ji-qi-xue-xi-hw2/"
           data-tag="python,pytorch"
           data-author="" >
            <span class="post-title" title="高级机器学习hw2">高级机器学习hw2</span>
            <span class="post-date" title="2021-12-27 19:42:51">2021/12/27</span>
        </a>
        
        
        <a  class="全部文章 最近 "
           href="/2021/12/20/zui-jin/leetcode-shua-ti-zong-jie/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="leetcode刷题总结">leetcode刷题总结</span>
            <span class="post-date" title="2021-12-20 22:28:55">2021/12/20</span>
        </a>
        
        
        <a  class="全部文章 计算机 算法与数据结构 "
           href="/2021/12/15/ji-suan-ji/suan-fa-yu-shu-ju-jie-gou/xing-ye-shu-jin-bi-shi-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="兴业数金笔试总结">兴业数金笔试总结</span>
            <span class="post-date" title="2021-12-15 12:15:07">2021/12/15</span>
        </a>
        
        
        <a  class="全部文章 计算机 算法与数据结构 "
           href="/2021/12/15/ji-suan-ji/suan-fa-yu-shu-ju-jie-gou/int-p-5-yu-int-p-5-de-qu-bie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="int p[5] 与(int )p[5]的区别">int p[5] 与(int )p[5]的区别</span>
            <span class="post-date" title="2021-12-15 12:14:58">2021/12/15</span>
        </a>
        
        
        <a  class="全部文章 最近 "
           href="/2021/12/15/zui-jin/leetcode-shua-ti/"
           data-tag="C++,Java,python,github"
           data-author="" >
            <span class="post-title" title="LeetCode刷题">LeetCode刷题</span>
            <span class="post-date" title="2021-12-15 12:14:43">2021/12/15</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机组成原理和系统结构 "
           href="/2021/12/13/ji-suan-ji/ji-suan-ji-zu-cheng-yuan-li-he-xi-tong-jie-gou/cao-zuo-xi-tong-qa/"
           data-tag="C++,Java,python"
           data-author="" >
            <span class="post-title" title="操作系统QA">操作系统QA</span>
            <span class="post-date" title="2021-12-13 18:45:14">2021/12/13</span>
        </a>
        
        
        <a  class="全部文章 计算机 实验室 "
           href="/2021/12/13/ji-suan-ji/shi-yan-shi/sheng-li-yin-qing-shi-yong-wen-dang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="生理引擎使用文档">生理引擎使用文档</span>
            <span class="post-date" title="2021-12-13 17:10:29">2021/12/13</span>
        </a>
        
        
        <a  class="全部文章 计算机 实验室 "
           href="/2021/12/13/ji-suan-ji/shi-yan-shi/sheng-li-yin-qing-an-zhuang-pei-zhi-wen-dang/"
           data-tag="C++,python"
           data-author="" >
            <span class="post-title" title="生理引擎安装配置文档">生理引擎安装配置文档</span>
            <span class="post-date" title="2021-12-13 16:41:41">2021/12/13</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 windows "
           href="/2021/12/08/ji-suan-ji/ji-cheng-kai-fa-huan-jing/windows/an-zhuang-windows7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安装windows7">安装windows7</span>
            <span class="post-date" title="2021-12-08 20:52:36">2021/12/08</span>
        </a>
        
        
        <a  class="全部文章 修身 生活技能 "
           href="/2021/12/07/xiu-shen/sheng-huo-ji-neng/how-to-give-a-good-presentation/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="How to give a good presentation">How to give a good presentation</span>
            <span class="post-date" title="2021-12-07 17:46:13">2021/12/07</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2021/12/06/jin-rong/jin-rong-zhi-shi/kk-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="kk总结">kk总结</span>
            <span class="post-date" title="2021-12-06 00:11:57">2021/12/06</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 Python "
           href="/2021/12/05/ji-suan-ji/bian-cheng-yu-yan/python/pytorch/"
           data-tag="python,pytorch"
           data-author="" >
            <span class="post-title" title="Pytorch">Pytorch</span>
            <span class="post-date" title="2021-12-05 15:22:54">2021/12/05</span>
        </a>
        
        
        <a  class="全部文章 最近 "
           href="/2021/12/03/zui-jin/bao-ji-kuang-jia-jie-shao-ji-shi-yong/"
           data-tag="C++,Java,python,github,PHP"
           data-author="" >
            <span class="post-title" title="包及框架介绍及使用">包及框架介绍及使用</span>
            <span class="post-date" title="2021-12-03 11:51:33">2021/12/03</span>
        </a>
        
        
        <a  class="全部文章 计算机 人工智能 机器学习 "
           href="/2021/11/29/ji-suan-ji/ren-gong-zhi-neng/ji-qi-xue-xi/gao-ji-ji-qi-xue-xi-hw1/"
           data-tag="python,pytorch"
           data-author="" >
            <span class="post-title" title="高级机器学习hw1">高级机器学习hw1</span>
            <span class="post-date" title="2021-11-29 10:31:43">2021/11/29</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2021/11/27/xiu-shen/sheng-huo-zhi-shi/she-hui-bao-xian-yang-lao-bao-xian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="社会保险养老保险">社会保险养老保险</span>
            <span class="post-date" title="2021-11-27 20:28:50">2021/11/27</span>
        </a>
        
        
        <a  class="全部文章 修身 生活技能 "
           href="/2021/11/26/xiu-shen/sheng-huo-ji-neng/xin-xi-su-yang/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="信息素养">信息素养</span>
            <span class="post-date" title="2021-11-26 18:46:10">2021/11/26</span>
        </a>
        
        
        <a  class="全部文章 学科 政治 "
           href="/2021/11/26/xue-ke/zheng-zhi/si-xiang-hui-bao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="思想汇报">思想汇报</span>
            <span class="post-date" title="2021-11-26 17:04:35">2021/11/26</span>
        </a>
        
        
        <a  class="全部文章 学科 政治 "
           href="/2021/11/26/xue-ke/zheng-zhi/shi-jiu-da-dang-zhang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="十九大党章">十九大党章</span>
            <span class="post-date" title="2021-11-26 16:43:08">2021/11/26</span>
        </a>
        
        
        <a  class="全部文章 学科 政治 "
           href="/2021/11/26/xue-ke/zheng-zhi/ji-ji-fen-zi-dang-ke-xue-xi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="积极分子党课学习">积极分子党课学习</span>
            <span class="post-date" title="2021-11-26 14:46:07">2021/11/26</span>
        </a>
        
        
        <a  class="全部文章 修身 工作 "
           href="/2021/11/26/xiu-shen/gong-zuo/bi-lei-gong-si/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="避雷公司">避雷公司</span>
            <span class="post-date" title="2021-11-26 14:15:16">2021/11/26</span>
        </a>
        
        
        <a  class="全部文章 金融 投资理念 "
           href="/2021/11/26/jin-rong/tou-zi-li-nian/bu-yao-ba-tou-zi-jiao-liu-dang-zuo-tou-zi-xue-xi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="不要把投资交流当作投资学习">不要把投资交流当作投资学习</span>
            <span class="post-date" title="2021-11-26 11:41:11">2021/11/26</span>
        </a>
        
        
        <a  class="全部文章 修身 奇思妙想 "
           href="/2021/11/25/xiu-shen/qi-si-miao-xiang/guan-yu-yi-shi-xing-tai-he-wen-hua-guan-xi-de-si-kao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="关于意识形态和文化关系的思考">关于意识形态和文化关系的思考</span>
            <span class="post-date" title="2021-11-25 23:32:18">2021/11/25</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 VsCode "
           href="/2021/11/22/ji-suan-ji/ji-cheng-kai-fa-huan-jing/vscode/python-an-zhuang-bao-mu-lu/"
           data-tag="python,pytorch"
           data-author="" >
            <span class="post-title" title="python安装包目录">python安装包目录</span>
            <span class="post-date" title="2021-11-22 11:12:33">2021/11/22</span>
        </a>
        
        
        <a  class="全部文章 学科 政治 "
           href="/2021/11/20/xue-ke/zheng-zhi/gong-chan-dang-xuan-yan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="共产党宣言">共产党宣言</span>
            <span class="post-date" title="2021-11-20 23:32:32">2021/11/20</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2021/11/18/xiu-shen/sheng-huo-zhi-shi/zhi-shi-guan-li/"
           data-tag="C++,Java,python,github,PHP"
           data-author="" >
            <span class="post-title" title="知识管理">知识管理</span>
            <span class="post-date" title="2021-11-18 18:44:23">2021/11/18</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 C "
           href="/2021/11/12/ji-suan-ji/bian-cheng-yu-yan/c/cmake/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="Cmake">Cmake</span>
            <span class="post-date" title="2021-11-12 21:01:28">2021/11/12</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/11/03/xiu-shen/chuang-ye/qi-ye-jue-ce-mo-ni-bi-sai-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="企业决策模拟比赛总结">企业决策模拟比赛总结</span>
            <span class="post-date" title="2021-11-03 23:50:04">2021/11/03</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/25/xiu-shen/chuang-ye/jue-ce-mo-ni/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="决策模拟">决策模拟</span>
            <span class="post-date" title="2021-10-25 23:01:41">2021/10/25</span>
        </a>
        
        
        <a  class="全部文章 金融 行业个股 "
           href="/2021/10/25/jin-rong/xing-ye-ge-gu/zhong-gong-jiao-yu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中公教育">中公教育</span>
            <span class="post-date" title="2021-10-25 20:12:32">2021/10/25</span>
        </a>
        
        
        <a  class="全部文章 运动 足球 "
           href="/2021/10/24/yun-dong/zu-qiu/ti-qiu-jing-yan-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="踢球经验总结">踢球经验总结</span>
            <span class="post-date" title="2021-10-24 23:41:05">2021/10/24</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/22/xiu-shen/chuang-ye/qi-ye-jue-ce-mo-ni-bi-sai-gui-ze/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="企业决策模拟比赛规则">企业决策模拟比赛规则</span>
            <span class="post-date" title="2021-10-22 23:07:51">2021/10/22</span>
        </a>
        
        
        <a  class="全部文章 计算机 人工智能 机器学习 "
           href="/2021/10/22/ji-suan-ji/ren-gong-zhi-neng/ji-qi-xue-xi/pytorch-kuang-jia/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="pytorch框架">pytorch框架</span>
            <span class="post-date" title="2021-10-22 20:54:44">2021/10/22</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2021/10/22/jin-rong/jin-rong-zhi-shi/gu-xi-gu-li-yu-chu-xi-chu-quan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="股息股利与除息除权">股息股利与除息除权</span>
            <span class="post-date" title="2021-10-22 15:13:04">2021/10/22</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2021/10/22/jin-rong/jin-rong-zhi-shi/ya-zhou-98-nian-jin-rong-wei-ji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="亚洲98年金融危机">亚洲98年金融危机</span>
            <span class="post-date" title="2021-10-22 01:15:26">2021/10/22</span>
        </a>
        
        
        <a  class="全部文章 运动 足球 "
           href="/2021/10/18/yun-dong/zu-qiu/yue-wei-pan-fa/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="越位判罚">越位判罚</span>
            <span class="post-date" title="2021-10-18 00:01:37">2021/10/18</span>
        </a>
        
        
        <a  class="全部文章 运动 足球 "
           href="/2021/10/17/yun-dong/zu-qiu/zu-qiu-cai-pan-ji-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="足球裁判记录">足球裁判记录</span>
            <span class="post-date" title="2021-10-17 20:50:04">2021/10/17</span>
        </a>
        
        
        <a  class="全部文章 学科 政治 "
           href="/2021/10/16/xue-ke/zheng-zhi/dang-ke-dang-de-guang-hui-li-shi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="党课党的光辉历史">党课党的光辉历史</span>
            <span class="post-date" title="2021-10-16 20:25:18">2021/10/16</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/16/xiu-shen/chuang-ye/qi-ye-jue-ce-mo-ni-bi-sai/"
           data-tag="python,PHP"
           data-author="" >
            <span class="post-title" title="企业决策模拟比赛">企业决策模拟比赛</span>
            <span class="post-date" title="2021-10-16 14:50:58">2021/10/16</span>
        </a>
        
        
        <a  class="全部文章 最近 "
           href="/2021/10/15/zui-jin/mu-lu/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="目录">目录</span>
            <span class="post-date" title="2021-10-15 15:57:23">2021/10/15</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 windows "
           href="/2021/10/15/ji-suan-ji/ji-cheng-kai-fa-huan-jing/windows/xue-xi-githubaction/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="学习githubAction">学习githubAction</span>
            <span class="post-date" title="2021-10-15 13:34:15">2021/10/15</span>
        </a>
        
        
        <a  class="全部文章 金融 投资理念 "
           href="/2021/10/13/jin-rong/tou-zi-li-nian/tou-zi-sui-bi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="投资随笔">投资随笔</span>
            <span class="post-date" title="2021-10-13 16:58:49">2021/10/13</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 JAVA "
           href="/2021/10/13/ji-suan-ji/bian-cheng-yu-yan/java/java-yu-c-de-qu-bie/"
           data-tag="C++,Java"
           data-author="" >
            <span class="post-title" title="Java与C++的区别">Java与C++的区别</span>
            <span class="post-date" title="2021-10-13 15:58:11">2021/10/13</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 JAVA "
           href="/2021/10/13/ji-suan-ji/bian-cheng-yu-yan/java/java-he-xin-ji-zhu-juan-1/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="《Java核心技术卷1》">《Java核心技术卷1》</span>
            <span class="post-date" title="2021-10-13 15:51:02">2021/10/13</span>
        </a>
        
        
        <a  class="全部文章 金融 投资理念 "
           href="/2021/10/13/jin-rong/tou-zi-li-nian/jie-zhi-tou-zi-vs-ji-zhu-tou-ji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="价值投资vs技术投机">价值投资vs技术投机</span>
            <span class="post-date" title="2021-10-13 15:02:32">2021/10/13</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机理论与数学 "
           href="/2021/10/12/ji-suan-ji/ji-suan-ji-li-lun-yu-shu-xue/ling-san-shu-xue-zhi-shi/"
           data-tag="pytorch"
           data-author="" >
            <span class="post-title" title="零散数学知识">零散数学知识</span>
            <span class="post-date" title="2021-10-12 11:11:27">2021/10/12</span>
        </a>
        
        
        <a  class="全部文章 计算机 人工智能 "
           href="/2021/10/10/ji-suan-ji/ren-gong-zhi-neng/xue-xi-ji-lu/"
           data-tag="pytorch"
           data-author="" >
            <span class="post-title" title="学习记录">学习记录</span>
            <span class="post-date" title="2021-10-10 21:26:30">2021/10/10</span>
        </a>
        
        
        <a  class="全部文章 金融 行业个股 "
           href="/2021/10/09/jin-rong/xing-ye-ge-gu/zhong-guo-ping-an/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中国平安">中国平安</span>
            <span class="post-date" title="2021-10-09 15:46:55">2021/10/09</span>
        </a>
        
        
        <a  class="全部文章 金融 投资理念 "
           href="/2021/10/09/jin-rong/tou-zi-li-nian/ding-tou-ce-lue-si-kao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="定投策略思考">定投策略思考</span>
            <span class="post-date" title="2021-10-09 15:32:41">2021/10/09</span>
        </a>
        
        
        <a  class="全部文章 金融 投资理念 "
           href="/2021/10/09/jin-rong/tou-zi-li-nian/tou-zi-li-nian-shi-tiao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="投资理念十条">投资理念十条</span>
            <span class="post-date" title="2021-10-09 14:47:12">2021/10/09</span>
        </a>
        
        
        <a  class="全部文章 最近 "
           href="/2021/10/07/zui-jin/typora-shi-shi-me/"
           data-tag="Java,github"
           data-author="" >
            <span class="post-title" title="Typora 是什么？">Typora 是什么？</span>
            <span class="post-date" title="2021-10-07 23:15:08">2021/10/07</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 JAVA "
           href="/2021/10/04/ji-suan-ji/bian-cheng-yu-yan/java/java-ling-san-zhi-shi-dian/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="Java零散知识点">Java零散知识点</span>
            <span class="post-date" title="2021-10-04 19:44:31">2021/10/04</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 JAVA "
           href="/2021/10/04/ji-suan-ji/bian-cheng-yu-yan/java/java-can-kao-zi-liao/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="Java参考资料">Java参考资料</span>
            <span class="post-date" title="2021-10-04 19:44:22">2021/10/04</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 JAVA "
           href="/2021/10/04/ji-suan-ji/bian-cheng-yu-yan/java/java-xue-xi-guo-cheng/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="Java学习过程">Java学习过程</span>
            <span class="post-date" title="2021-10-04 19:44:08">2021/10/04</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 JAVA "
           href="/2021/10/04/ji-suan-ji/bian-cheng-yu-yan/java/java-xue-xi-lu-xian/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="Java学习路线">Java学习路线</span>
            <span class="post-date" title="2021-10-04 19:43:51">2021/10/04</span>
        </a>
        
        
        <a  class="全部文章 修身 生活技能 "
           href="/2021/10/03/xiu-shen/sheng-huo-ji-neng/shou-ji-xuan-gou/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="手机选购">手机选购</span>
            <span class="post-date" title="2021-10-03 14:34:46">2021/10/03</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机理论与数学 "
           href="/2021/10/03/ji-suan-ji/ji-suan-ji-li-lun-yu-shu-xue/ji-qi-xue-xi-zhong-de-shu-xue-ming-ci/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机器学习中的数学名词">机器学习中的数学名词</span>
            <span class="post-date" title="2021-10-03 09:34:06">2021/10/03</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2021/10/03/xiu-shen/sheng-huo-zhi-shi/shou-ji-zhu-ce-zhang-hao-guan-li/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="手机注册账号管理">手机注册账号管理</span>
            <span class="post-date" title="2021-10-03 00:15:58">2021/10/03</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2021/10/03/xiu-shen/sheng-huo-zhi-shi/tuo-hang-ji-hua-mian-shi-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="拓航计划面试总结">拓航计划面试总结</span>
            <span class="post-date" title="2021-10-03 00:14:25">2021/10/03</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2021/10/02/xiu-shen/sheng-huo-zhi-shi/ben-ke-bi-ye-lun-wen-jin-zhan/"
           data-tag="Java,python,github,pytorch"
           data-author="" >
            <span class="post-title" title="本科毕业论文进展">本科毕业论文进展</span>
            <span class="post-date" title="2021-10-02 19:06:41">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2021/10/02/xiu-shen/sheng-huo-zhi-shi/bi-ye-lun-wen-si-lu-he-can-kao-zi-liao/"
           data-tag="github,PHP"
           data-author="" >
            <span class="post-title" title="毕业论文思路和参考资料">毕业论文思路和参考资料</span>
            <span class="post-date" title="2021-10-02 19:04:15">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 修身 工作 "
           href="/2021/10/02/xiu-shen/gong-zuo/ding-xiang-xuan-diao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="定向选调">定向选调</span>
            <span class="post-date" title="2021-10-02 19:01:45">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 修身 工作 "
           href="/2021/10/02/xiu-shen/gong-zuo/she-bao-he-wu-xian-yi-jin/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="社保和五险一金">社保和五险一金</span>
            <span class="post-date" title="2021-10-02 18:59:33">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 修身 工作 "
           href="/2021/10/02/xiu-shen/gong-zuo/ji-ti-hu-kou-xiang-guan-shi-xiang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="集体户口相关事项">集体户口相关事项</span>
            <span class="post-date" title="2021-10-02 18:58:45">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 其它 "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/qi-ta/neo4j-tu-cha-xun-yu-ju/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="neo4j图查询语句">neo4j图查询语句</span>
            <span class="post-date" title="2021-10-02 18:52:19">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2021/10/02/xiu-shen/sheng-huo-zhi-shi/yan-jiu-sheng-jie-duan-zhun-bei/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="研究生阶段准备">研究生阶段准备</span>
            <span class="post-date" title="2021-10-02 18:51:31">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 C "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/c/cprimeplus-xue-xi-bi-ji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="《CPrimePlus》学习笔记">《CPrimePlus》学习笔记</span>
            <span class="post-date" title="2021-10-02 18:39:39">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 C "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/c/c-ling-san-zhi-shi-dian/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C零散知识点">C零散知识点</span>
            <span class="post-date" title="2021-10-02 18:35:53">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 其它 "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/qi-ta/linux-ling-san-zhi-shi-dian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="linux零散知识点">linux零散知识点</span>
            <span class="post-date" title="2021-10-02 18:32:34">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 Python "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/python/python-ling-san-zhi-shi-dian/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="python零散知识点">python零散知识点</span>
            <span class="post-date" title="2021-10-02 18:24:43">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 Python "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/python/liao-xue-feng-de-python-bi-ji/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="《廖雪峰的python》笔记">《廖雪峰的python》笔记</span>
            <span class="post-date" title="2021-10-02 18:23:27">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 Python "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/python/python-xue-xi-shou-ce-bi-ji/"
           data-tag="C++,python"
           data-author="" >
            <span class="post-title" title="《Python学习手册》笔记">《Python学习手册》笔记</span>
            <span class="post-date" title="2021-10-02 18:03:10">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 windows "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/windows/an-zhuang-reactnative/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="安装ReactNative">安装ReactNative</span>
            <span class="post-date" title="2021-10-02 18:01:21">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 其它 "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/qi-ta/bian-yi-yuan-li-ci-fa-fen-xi-cheng-xu-wen-dang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="编译原理词法分析程序文档">编译原理词法分析程序文档</span>
            <span class="post-date" title="2021-10-02 18:00:49">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 其它 "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/qi-ta/bian-yi-yuan-li-ebnf-to-bnf/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="编译原理EBNF To BNF">编译原理EBNF To BNF</span>
            <span class="post-date" title="2021-10-02 17:59:24">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 其它 "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/qi-ta/bian-yi-yuan-li-yu-fa-fen-xi-cheng-xu-wen-dang/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="编译原理语法分析程序文档">编译原理语法分析程序文档</span>
            <span class="post-date" title="2021-10-02 17:58:49">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 WAMP "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/wamp/wamp-she-zhi-xu-ni-zhu-ji-hou-bu-neng-fang-wen-wen-ti/"
           data-tag="WAMP"
           data-author="" >
            <span class="post-title" title="WAMP设置虚拟主机后不能访问问题">WAMP设置虚拟主机后不能访问问题</span>
            <span class="post-date" title="2021-10-02 17:53:26">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 WAMP "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/wamp/wamp-yuan-cheng-zhu-ji-she-zhi-xu-ni-zhu-ji/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="WAMP远程主机设置虚拟主机">WAMP远程主机设置虚拟主机</span>
            <span class="post-date" title="2021-10-02 17:45:44">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机图形学 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-tu-xing-xue/shu-zi-tu-xiang-chu-li-ke-cheng-bi-ji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数字图像处理课程笔记">数字图像处理课程笔记</span>
            <span class="post-date" title="2021-10-02 17:02:04">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机图形学 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-tu-xing-xue/ping-mu-huan-chong-qu-li-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="屏幕缓冲区理解">屏幕缓冲区理解</span>
            <span class="post-date" title="2021-10-02 17:00:19">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机网络 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-wang-luo/hu-nan-ke-ji-da-xue-ji-suan-ji-wang-luo-di-7-zhang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="湖南科技大学计算机网络第7章">湖南科技大学计算机网络第7章</span>
            <span class="post-date" title="2021-10-02 16:55:05">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机网络 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-wang-luo/hu-nan-ke-ji-da-xue-ji-suan-ji-wang-luo-di-6-zhang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="湖南科技大学计算机网络第6章">湖南科技大学计算机网络第6章</span>
            <span class="post-date" title="2021-10-02 16:53:02">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机网络 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-wang-luo/hu-nan-ke-ji-da-xue-ji-suan-ji-wang-luo-di-5-zhang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="湖南科技大学计算机网络第5章">湖南科技大学计算机网络第5章</span>
            <span class="post-date" title="2021-10-02 16:50:27">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机网络 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-wang-luo/hu-nan-ke-ji-da-xue-ji-suan-ji-wang-luo-di-4-zhang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="湖南科技大学计算机网络第4章">湖南科技大学计算机网络第4章</span>
            <span class="post-date" title="2021-10-02 16:28:40">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机网络 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-wang-luo/hu-nan-ke-ji-da-xue-ji-suan-ji-wang-luo-di-3-zhang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="湖南科技大学计算机网络第3章">湖南科技大学计算机网络第3章</span>
            <span class="post-date" title="2021-10-02 16:23:11">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机网络 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-wang-luo/hu-nan-ke-ji-da-xue-ji-suan-ji-wang-luo-di-2-zhang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="湖南科技大学计算机网络第2章">湖南科技大学计算机网络第2章</span>
            <span class="post-date" title="2021-10-02 16:22:28">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机网络 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-wang-luo/hu-nan-ke-ji-da-xue-ji-suan-ji-wang-luo-di-1-zhang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="湖南科技大学计算机网络第1章">湖南科技大学计算机网络第1章</span>
            <span class="post-date" title="2021-10-02 16:21:43">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机网络 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-wang-luo/jian-yi-liao-tian-ruan-jian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="简易聊天软件">简易聊天软件</span>
            <span class="post-date" title="2021-10-02 16:19:29">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机网络 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-wang-luo/ji-suan-ji-wang-luo-ke-cheng-zhi-shi-tu-pu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络课程知识图谱">计算机网络课程知识图谱</span>
            <span class="post-date" title="2021-10-02 16:18:05">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 WAMP "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/wamp/wamp-tong-yi-ge-fu-wu-qi-pei-zhi-duo-ge-wang-zhan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="WAMP同一个服务器配置多个网站">WAMP同一个服务器配置多个网站</span>
            <span class="post-date" title="2021-10-02 16:11:44">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 linux "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/linux/teng-xun-yun-fu-wu-qi-bao-ta-wordpress-an-zhuang-ge-ren-bo-ke/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="腾讯云服务器+宝塔+wordpress安装个人博客">腾讯云服务器+宝塔+wordpress安装个人博客</span>
            <span class="post-date" title="2021-10-02 16:10:05">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 PHP "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/php/php-yu-yan-bi-keng-zhi-nan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PHP语言避坑指南">PHP语言避坑指南</span>
            <span class="post-date" title="2021-10-02 16:08:42">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 人工智能 机器学习 "
           href="/2021/10/02/ji-suan-ji/ren-gong-zhi-neng/ji-qi-xue-xi/san-chong-sou-suo-suan-fa-jie-8-shu-ma-wen-ti/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="三种搜索算法解8数码问题">三种搜索算法解8数码问题</span>
            <span class="post-date" title="2021-10-02 14:56:49">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 人工智能 机器学习 "
           href="/2021/10/02/ji-suan-ji/ren-gong-zhi-neng/ji-qi-xue-xi/shen-jing-wang-luo-bp-suan-fa-xi-tong-kai-fa-yu-yan-zheng/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="神经网络 BP算法系统开发与验证">神经网络 BP算法系统开发与验证</span>
            <span class="post-date" title="2021-10-02 14:44:53">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 WAMP "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/wamp/wamp-guan-yu-lian-jie-shu-ju-ku-shi-bai-de-ke-neng-xing/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="WAMP关于连接数据库失败的可能性">WAMP关于连接数据库失败的可能性</span>
            <span class="post-date" title="2021-10-02 14:41:04">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 Python "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/python/python-hou-duan-xue-xi-lu-xian/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="python后端学习路线">python后端学习路线</span>
            <span class="post-date" title="2021-10-02 14:36:40">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机硬件 "
           href="/2021/10/02/ji-suan-ji/ji-suan-ji-ying-jian/shu-mei-pai-yan-shi-dian-ying/"
           data-tag="python,github"
           data-author="" >
            <span class="post-title" title="树莓派延时电影">树莓派延时电影</span>
            <span class="post-date" title="2021-10-02 14:26:28">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 其它 "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/qi-ta/shell-xue-xi-bi-ji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell学习笔记">Shell学习笔记</span>
            <span class="post-date" title="2021-10-02 14:21:05">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 IDEA "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/idea/idea-an-zhuang/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="IDEA安装">IDEA安装</span>
            <span class="post-date" title="2021-10-02 13:16:19">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 WAMP "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/wamp/wamp-da-jian-ti-shi/"
           data-tag="PHP,WAMP"
           data-author="" >
            <span class="post-title" title="WAMP搭建提示">WAMP搭建提示</span>
            <span class="post-date" title="2021-10-02 13:00:30">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 WAMP "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/wamp/wamp-pei-zhi-yu-ming/"
           data-tag="WAMP"
           data-author="" >
            <span class="post-title" title="WAMP配置域名">WAMP配置域名</span>
            <span class="post-date" title="2021-10-02 12:04:50">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 windows "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/windows/zai-git-zhong-shi-yong-de-wen-ti/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="在git中使用的问题">在git中使用的问题</span>
            <span class="post-date" title="2021-10-02 12:02:22">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 C "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/c/guan-yu-gou-zao-han-shu-he-pu-tong-han-shu-de-si-kao/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="关于构造函数和普通函数的思考">关于构造函数和普通函数的思考</span>
            <span class="post-date" title="2021-10-02 11:59:36">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 windows "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/windows/an-zhuang-mysql/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安装mysql">安装mysql</span>
            <span class="post-date" title="2021-10-02 11:56:10">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 sublime "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/sublime/pei-zhi-sublime-kuai-jie-jian-zhi-xing-html-wen-jian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="配置sublime快捷键执行html文件">配置sublime快捷键执行html文件</span>
            <span class="post-date" title="2021-10-02 11:54:55">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 其他计算机 "
           href="/2021/10/02/ji-suan-ji/qi-ta-ji-suan-ji/ji-lu-yi-ci-guan-yu-bo-cai-pa-chong-jiao-yu-men-hu-wang-zhan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="记录一次关于菠菜爬虫教育门户网站">记录一次关于菠菜爬虫教育门户网站</span>
            <span class="post-date" title="2021-10-02 11:54:03">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2021/10/02/jin-rong/jin-rong-zhi-shi/guan-yu-wai-hui-he-jing-wai-mai-fang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="关于外汇和境外买房">关于外汇和境外买房</span>
            <span class="post-date" title="2021-10-02 11:44:45">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2021/10/02/jin-rong/jin-rong-zhi-shi/zhuan-gu-jie-zhi-shi-shi-me-yi-si/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="转股价值是什么意思">转股价值是什么意思</span>
            <span class="post-date" title="2021-10-02 11:40:12">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2021/10/02/jin-rong/jin-rong-zhi-shi/chang-wai-ji-jin-he-chang-nei-ji-jin-shou-xu-fei-bi-jiao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="场外基金和场内基金手续费比较">场外基金和场内基金手续费比较</span>
            <span class="post-date" title="2021-10-02 11:35:56">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/02/xiu-shen/chuang-ye/shen-qing-qi-ye-zhang-hu-wei-xin-xiao-cheng-xu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="申请企业账户微信小程序">申请企业账户微信小程序</span>
            <span class="post-date" title="2021-10-02 11:33:42">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/02/xiu-shen/chuang-ye/wei-xin-zhi-fu-ping-tai-de-kai-tong/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="微信支付平台的开通">微信支付平台的开通</span>
            <span class="post-date" title="2021-10-02 11:31:00">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/02/xiu-shen/chuang-ye/wei-xin-gong-zhong-ping-tai-ren-zheng-wei-qi-ye/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="微信公众平台认证为企业">微信公众平台认证为企业</span>
            <span class="post-date" title="2021-10-02 11:26:01">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/02/xiu-shen/chuang-ye/ge-ren-cheng-xu-qian-yi-wei-qi-ye/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="个人程序迁移为企业">个人程序迁移为企业</span>
            <span class="post-date" title="2021-10-02 11:24:08">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 linux "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/linux/liang-tai-linux-zhu-ji-lian-jie-mysql-yuan-cheng-shu-ju-ku-shi-bai-de-jing-yan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="两台Linux主机连接mysql远程数据库失败的经验">两台Linux主机连接mysql远程数据库失败的经验</span>
            <span class="post-date" title="2021-10-02 00:38:58">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 C "
           href="/2021/10/02/ji-suan-ji/bian-cheng-yu-yan/c/jing-tai-cheng-yuan-han-shu-fang-wen-wen-ti/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="静态成员函数访问问题">静态成员函数访问问题</span>
            <span class="post-date" title="2021-10-02 00:37:23">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 软件开发 "
           href="/2021/10/02/ji-suan-ji/ruan-jian-kai-fa/xiao-cheng-xu-xue-xi-zhi-nan/"
           data-tag="Java,github,PHP,WAMP"
           data-author="" >
            <span class="post-title" title="小程序学习指南">小程序学习指南</span>
            <span class="post-date" title="2021-10-02 00:33:40">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 VsCode "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/vscode/an-zhuang-pytorch-yu-dao-de-wen-ti/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安装Pytorch遇到的问题">安装Pytorch遇到的问题</span>
            <span class="post-date" title="2021-10-02 00:32:27">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 VsCode "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/vscode/python-pei-zhi-yi-ge-guan-yu-pil-de-wen-ti/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="Python配置一个关于PIL的问题">Python配置一个关于PIL的问题</span>
            <span class="post-date" title="2021-10-02 00:28:38">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 VsCode "
           href="/2021/10/02/ji-suan-ji/ji-cheng-kai-fa-huan-jing/vscode/vscode-pei-zhi-kuai-jie-jian-yun-xing-python-wen-jian/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="VSCODE配置快捷键运行Python文件">VSCODE配置快捷键运行Python文件</span>
            <span class="post-date" title="2021-10-02 00:27:49">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 其他计算机 "
           href="/2021/10/02/ji-suan-ji/qi-ta-ji-suan-ji/pei-zhi-github12306-xiang-mu/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="配置github12306项目">配置github12306项目</span>
            <span class="post-date" title="2021-10-02 00:18:43">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 其他计算机 "
           href="/2021/10/02/ji-suan-ji/qi-ta-ji-suan-ji/bian-ma-fang-shi-asciiunicodeutf-8utf-16-bian-xi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="编码方式-ASCIIUnicodeUTF-8UTF-16辨析">编码方式-ASCIIUnicodeUTF-8UTF-16辨析</span>
            <span class="post-date" title="2021-10-02 00:12:17">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 其他计算机 "
           href="/2021/10/02/ji-suan-ji/qi-ta-ji-suan-ji/pa-chong-pa-dao-de-shi-shi-me/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="爬虫爬到的&amp;#是什么">爬虫爬到的&amp;#是什么</span>
            <span class="post-date" title="2021-10-02 00:10:04">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 windows "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/windows/yi-tai-dian-nao-pei-zhi-liang-ge-github-zhang-hao-er/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="一台电脑配置两个github账号二">一台电脑配置两个github账号二</span>
            <span class="post-date" title="2021-10-01 23:57:10">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 windows "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/windows/yi-tai-dian-nao-pei-zhi-liang-ge-github-zhang-hao/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="一台电脑配置两个github账号">一台电脑配置两个github账号</span>
            <span class="post-date" title="2021-10-01 23:53:37">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 VsCode "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/vscode/pei-zhi-github-xiang-mu-weibo-daily-hotkey/"
           data-tag="python,github"
           data-author="" >
            <span class="post-title" title="配置github项目——weibo_daily_hotkey">配置github项目——weibo_daily_hotkey</span>
            <span class="post-date" title="2021-10-01 23:50:36">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 windows "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/windows/git-xue-xi-bi-ji/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="git学习笔记">git学习笔记</span>
            <span class="post-date" title="2021-10-01 23:50:15">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 Vs2019 "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/vs2019/vs2019-pei-zhi-lian-jie-shu-ju-ku/"
           data-tag="C++,WAMP"
           data-author="" >
            <span class="post-title" title="vs2019配置连接数据库">vs2019配置连接数据库</span>
            <span class="post-date" title="2021-10-01 23:47:48">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 linux "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/linux/an-zhuang-pei-zhi-llvm/"
           data-tag="C++,github"
           data-author="" >
            <span class="post-title" title="安装配置llvm">安装配置llvm</span>
            <span class="post-date" title="2021-10-01 23:46:27">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 linux "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/linux/an-zhuang-pei-zhi-flex-bison-deng/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="安装配置flex+bison等">安装配置flex+bison等</span>
            <span class="post-date" title="2021-10-01 23:43:46">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 算法与数据结构 "
           href="/2021/10/01/ji-suan-ji/suan-fa-yu-shu-ju-jie-gou/apriori-suan-fa/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="Apriori算法">Apriori算法</span>
            <span class="post-date" title="2021-10-01 23:41:14">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 VsCode "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/vscode/pei-zhi-jeesite-yun-xing-huan-jing/"
           data-tag="Java,github"
           data-author="" >
            <span class="post-title" title="配置Jeesite运行环境">配置Jeesite运行环境</span>
            <span class="post-date" title="2021-10-01 23:32:06">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 VsCode "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/vscode/pei-zhi-github-xiang-mu-ccks-kg/"
           data-tag="python,pytorch"
           data-author="" >
            <span class="post-title" title="配置github项目ccks_kg">配置github项目ccks_kg</span>
            <span class="post-date" title="2021-10-01 23:28:59">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 linux "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/linux/centos7-an-zhuang-bu-tong-ban-ben-de-python-bing-she-zhi-mo-ren-python/"
           data-tag="python,github"
           data-author="" >
            <span class="post-title" title="centos7安装不同版本的python并设置默认python">centos7安装不同版本的python并设置默认python</span>
            <span class="post-date" title="2021-10-01 23:27:20">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 linux "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/linux/an-zhuang-wordpress-ming-ling-xing-gong-ju-wp-cli-lai-guan-li-wordpress/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="安装wordpress命令行工具WP-CLI来管理wordpress">安装wordpress命令行工具WP-CLI来管理wordpress</span>
            <span class="post-date" title="2021-10-01 23:25:41">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 linux "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/linux/zai-yun-fu-wu-qi-shang-bu-shu-jian-kong-gu-shi-jiao-ben/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="在云服务器上部署监控股市脚本">在云服务器上部署监控股市脚本</span>
            <span class="post-date" title="2021-10-01 23:23:07">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 VsCode "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/vscode/an-zhuang-tensorflow/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="安装tensorflow">安装tensorflow</span>
            <span class="post-date" title="2021-10-01 23:19:16">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 linux "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/linux/zai-yun-fu-wu-qi-shang-gua-qi-jiao-ben-zhi-xing-pa-qu-shu-ju-ren-wu-xu-yao-zhu-yi-de-dian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="《在云服务器上挂起脚本执行爬取数据任务需要注意的点》">《在云服务器上挂起脚本执行爬取数据任务需要注意的点》</span>
            <span class="post-date" title="2021-10-01 23:16:51">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 算法与数据结构 "
           href="/2021/10/01/ji-suan-ji/suan-fa-yu-shu-ju-jie-gou/32-wei-ji-qi-he-64-wei-ji-qi-cc-ge-lei-xing-suo-zhan-da-xiao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="32位机器和64位机器CC++各类型所占大小">32位机器和64位机器CC++各类型所占大小</span>
            <span class="post-date" title="2021-10-01 23:15:19">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 VsCode "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/vscode/an-zhuang-pei-zhi-senta/"
           data-tag="python,github"
           data-author="" >
            <span class="post-title" title="安装配置senta">安装配置senta</span>
            <span class="post-date" title="2021-10-01 23:11:15">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 linux "
           href="/2021/10/01/ji-suan-ji/ji-cheng-kai-fa-huan-jing/linux/zai-zi-ji-de-fu-wu-qi-shang-an-zhuang-git-fu-wu-qi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="在自己的服务器上安装git服务器">在自己的服务器上安装git服务器</span>
            <span class="post-date" title="2021-10-01 23:10:24">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 计算机 编程语言 C "
           href="/2021/10/01/ji-suan-ji/bian-cheng-yu-yan/c/c-yu-yan-chang-jian-xi-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C语言常见细节">C语言常见细节</span>
            <span class="post-date" title="2021-10-01 23:02:58">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 奇思妙想 "
           href="/2021/10/01/xiu-shen/qi-si-miao-xiang/xue-xi-gan-zhi-ji-hou-de-xiang-fa/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="学习感知机后的想法">学习感知机后的想法</span>
            <span class="post-date" title="2021-10-01 23:01:26">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 生活技能 "
           href="/2021/10/01/xiu-shen/sheng-huo-ji-neng/kuan-dai-jie-ru/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="宽带接入">宽带接入</span>
            <span class="post-date" title="2021-10-01 22:58:33">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2021/10/01/xiu-shen/sheng-huo-zhi-shi/gao-shu-shu-xue-zi-liao-de-xuan-ze/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高数数学资料的选择">高数数学资料的选择</span>
            <span class="post-date" title="2021-10-01 22:51:16">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 奇思妙想 "
           href="/2021/10/01/xiu-shen/qi-si-miao-xiang/ju-zhen-yu-shi-ji-sheng-huo-xiang-lian-xi/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="矩阵与实际生活相联系">矩阵与实际生活相联系</span>
            <span class="post-date" title="2021-10-01 22:48:21">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2021/10/01/xiu-shen/sheng-huo-zhi-shi/kao-yan-jing-yan-fen-xiang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="考研经验分享">考研经验分享</span>
            <span class="post-date" title="2021-10-01 22:47:45">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 学科 文学 村上春树 "
           href="/2021/10/01/xue-ke/wen-xue/cun-shang-chun-shu/guo-jing-yi-nan-tai-yang-yi-xi-cun-shang-xiao-shuo-xun-li-qi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="国境以南，太阳以西——村上小说巡礼七">国境以南，太阳以西——村上小说巡礼七</span>
            <span class="post-date" title="2021-10-01 22:45:00">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 学科 文学 村上春树 "
           href="/2021/10/01/xue-ke/wen-xue/cun-shang-chun-shu/nuo-wei-de-sen-lin-cun-shang-xiao-shuo-xun-li-wu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="挪威的森林——村上小说巡礼五">挪威的森林——村上小说巡礼五</span>
            <span class="post-date" title="2021-10-01 22:44:57">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 学科 文学 村上春树 "
           href="/2021/10/01/xue-ke/wen-xue/cun-shang-chun-shu/wu-wu-wu-cun-shang-xiao-shuo-xun-li-liu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="舞舞舞——村上小说巡礼六">舞舞舞——村上小说巡礼六</span>
            <span class="post-date" title="2021-10-01 22:44:39">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 学科 文学 村上春树 "
           href="/2021/10/01/xue-ke/wen-xue/cun-shang-chun-shu/shi-jie-jin-tou-he-leng-ku-xian-jing-cun-shang-xiao-shuo-xun-li-si/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="世界尽头和冷酷仙境——村上小说巡礼四">世界尽头和冷酷仙境——村上小说巡礼四</span>
            <span class="post-date" title="2021-10-01 22:44:16">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 学科 文学 村上春树 "
           href="/2021/10/01/xue-ke/wen-xue/cun-shang-chun-shu/xun-yang-mou-xian-ji-cun-shang-xiao-shuo-xun-li-san/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="寻羊冒险记——村上小说巡礼三">寻羊冒险记——村上小说巡礼三</span>
            <span class="post-date" title="2021-10-01 22:40:57">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 学科 文学 村上春树 "
           href="/2021/10/01/xue-ke/wen-xue/cun-shang-chun-shu/1973-nian-de-dan-zi-qiu-cun-shang-xiao-shuo-xun-li-er/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="1973年的弹子球——村上小说巡礼二">1973年的弹子球——村上小说巡礼二</span>
            <span class="post-date" title="2021-10-01 22:39:55">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/01/xiu-shen/chuang-ye/kuai-di-dai-qu-xiang-mu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="快递代取项目">快递代取项目</span>
            <span class="post-date" title="2021-10-01 22:25:44">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/01/xiu-shen/chuang-ye/zhong-ying-chuang-ye-xiang-mu-di-yi-ci-pei-xun/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中英创业项目第一次培训">中英创业项目第一次培训</span>
            <span class="post-date" title="2021-10-01 22:04:37">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 奇思妙想 "
           href="/2021/10/01/xiu-shen/qi-si-miao-xiang/li-shang-an-ge-qu-dui-bi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="李上安歌曲对比">李上安歌曲对比</span>
            <span class="post-date" title="2021-10-01 22:02:57">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/01/xiu-shen/chuang-ye/zhong-ying-chuang-ye-xiang-mu-di-er-ci-pei-xun/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中英创业项目第二次培训">中英创业项目第二次培训</span>
            <span class="post-date" title="2021-10-01 21:58:04">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/01/xiu-shen/chuang-ye/zhong-ying-chuang-ye-xiang-mu-di-san-ci-pei-xun/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中英创业项目第三次培训 ">中英创业项目第三次培训 </span>
            <span class="post-date" title="2021-10-01 21:55:43">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/01/xiu-shen/chuang-ye/zhong-ying-chuang-ye-xiang-mu-di-si-ci-pei-xun/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中英创业项目第四次培训">中英创业项目第四次培训</span>
            <span class="post-date" title="2021-10-01 21:54:19">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/01/xiu-shen/chuang-ye/fu-wu-qi-yu-yu-ming-gou-mai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="服务器与域名购买">服务器与域名购买</span>
            <span class="post-date" title="2021-10-01 21:42:58">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 修身 创业 "
           href="/2021/10/01/xiu-shen/chuang-ye/chuang-ban-gong-si-liu-cheng/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创办公司流程">创办公司流程</span>
            <span class="post-date" title="2021-10-01 21:36:31">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 金融 投资记录 "
           href="/2021/09/30/jin-rong/tou-zi-ji-lu/2020-nian-tou-zi-ji-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2020年投资记录">2020年投资记录</span>
            <span class="post-date" title="2021-09-30 00:38:12">2021/09/30</span>
        </a>
        
        
        <a  class="全部文章 修身 生活技能 "
           href="/2021/09/30/xiu-shen/sheng-huo-ji-neng/zheng-quan-cong-ye-zi-ge-kao-shi-ji-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="证券从业资格考试记录">证券从业资格考试记录</span>
            <span class="post-date" title="2021-09-30 00:34:31">2021/09/30</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2021/09/29/jin-rong/jin-rong-zhi-shi/jin-qian-guan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="金钱观">金钱观</span>
            <span class="post-date" title="2021-09-29 00:49:05">2021/09/29</span>
        </a>
        
        
        <a  class="全部文章 金融 投资理念 "
           href="/2021/09/28/jin-rong/tou-zi-li-nian/wei-shi-me-bu-yao-jin-jian-gu-qun-he-gen-zhao-gu-piao-da-v-zou/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="为什么不要进荐股群和跟着股票大V走？">为什么不要进荐股群和跟着股票大V走？</span>
            <span class="post-date" title="2021-09-28 21:39:53">2021/09/28</span>
        </a>
        
        
        <a  class="全部文章 学科 政治 "
           href="/2021/09/21/xue-ke/zheng-zhi/xue-xi-gong-chan-zhu-yi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="学习共产主义">学习共产主义</span>
            <span class="post-date" title="2021-09-21 15:23:58">2021/09/21</span>
        </a>
        
        
        <a  class="全部文章 学科 政治 "
           href="/2021/09/21/xue-ke/zheng-zhi/ru-dang-shen-qing-shu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="入党申请书">入党申请书</span>
            <span class="post-date" title="2021-09-21 15:23:55">2021/09/21</span>
        </a>
        
        
        <a  class="全部文章 金融 金融知识 "
           href="/2021/09/20/jin-rong/jin-rong-zhi-shi/fintech-jin-rong-ke-ji-de-chuang-xin-chuang-ye-yu-an-li/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="FinTech+金融科技的创新,创业与案例">FinTech+金融科技的创新,创业与案例</span>
            <span class="post-date" title="2021-09-20 12:14:55">2021/09/20</span>
        </a>
        
        
        <a  class="全部文章 运动 足球 "
           href="/2021/09/18/yun-dong/zu-qiu/zhu-li-cai-pan-zhi-ze/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="助理裁判职责">助理裁判职责</span>
            <span class="post-date" title="2021-09-18 23:55:14">2021/09/18</span>
        </a>
        
        
        <a  class="全部文章 运动 足球 "
           href="/2021/09/16/yun-dong/zu-qiu/di-si-guan-yuan-zhi-ze/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="第四官员职责">第四官员职责</span>
            <span class="post-date" title="2021-09-16 00:04:38">2021/09/16</span>
        </a>
        
        
        <a  class="全部文章 计算机 其他计算机 "
           href="/2021/09/14/ji-suan-ji/qi-ta-ji-suan-ji/ji-suan-ji-lun-wen-fa-biao/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="计算机论文发表">计算机论文发表</span>
            <span class="post-date" title="2021-09-14 19:11:31">2021/09/14</span>
        </a>
        
        
        <a  class="全部文章 学科 其他学科 "
           href="/2021/09/14/xue-ke/qi-ta-xue-ke/hao-ju-zi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="好句子">好句子</span>
            <span class="post-date" title="2021-09-14 19:03:54">2021/09/14</span>
        </a>
        
        
        <a  class="全部文章 学科 其他学科 "
           href="/2021/09/14/xue-ke/qi-ta-xue-ke/kai-nao-dong/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="开脑洞">开脑洞</span>
            <span class="post-date" title="2021-09-14 19:03:17">2021/09/14</span>
        </a>
        
        
        <a  class="全部文章 学科 其他学科 "
           href="/2021/09/14/xue-ke/qi-ta-xue-ke/xiao-hua/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="笑话">笑话</span>
            <span class="post-date" title="2021-09-14 19:02:50">2021/09/14</span>
        </a>
        
        
        <a  class="全部文章 学科 其他学科 "
           href="/2021/09/14/xue-ke/qi-ta-xue-ke/qi-ta/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="其它">其它</span>
            <span class="post-date" title="2021-09-14 19:02:21">2021/09/14</span>
        </a>
        
        
        <a  class="全部文章 学科 社会科学 "
           href="/2021/09/14/xue-ke/she-hui-ke-xue/xiang-tu-zhong-guo/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="乡土中国">乡土中国</span>
            <span class="post-date" title="2021-09-14 19:01:01">2021/09/14</span>
        </a>
        
        
        <a  class="全部文章 学科 社会科学 "
           href="/2021/09/13/xue-ke/she-hui-ke-xue/she-hui-xing-dong-wu-wei/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="社会性动物(未)">社会性动物(未)</span>
            <span class="post-date" title="2021-09-13 22:25:00">2021/09/13</span>
        </a>
        
        
        <a  class="全部文章 计算机 实验室 "
           href="/2021/09/13/ji-suan-ji/shi-yan-shi/pjsua2-python-ben-di-fu-xian/"
           data-tag="C++,python"
           data-author="" >
            <span class="post-title" title="pjsua2_python本地复现">pjsua2_python本地复现</span>
            <span class="post-date" title="2021-09-13 22:20:53">2021/09/13</span>
        </a>
        
        
        <a  class="全部文章 最近 "
           href="/2021/09/13/zui-jin/ying-yong-ruan-jian-ji-kai-fa-huan-jing/"
           data-tag="C++,Java,python,github,PHP"
           data-author="" >
            <span class="post-title" title="应用软件及开发环境">应用软件及开发环境</span>
            <span class="post-date" title="2021-09-13 21:26:05">2021/09/13</span>
        </a>
        
        
        <a  class="全部文章 计算机 实验室 "
           href="/2021/09/07/ji-suan-ji/shi-yan-shi/biogears/"
           data-tag="C++,Java,python,github"
           data-author="" >
            <span class="post-title" title="biogears">biogears</span>
            <span class="post-date" title="2021-09-07 21:36:47">2021/09/07</span>
        </a>
        
        
        <a  class="全部文章 计算机 "
           href="/2021/09/07/ji-suan-ji/2021-nian-zu-hui-hui-bao/"
           data-tag="C++,Java,python,github"
           data-author="" >
            <span class="post-title" title="2021年组会汇报">2021年组会汇报</span>
            <span class="post-date" title="2021-09-07 21:28:12">2021/09/07</span>
        </a>
        
        
        <a  class="全部文章 计算机 计算机硬件 "
           href="/2021/09/07/ji-suan-ji/ji-suan-ji-ying-jian/zhuang-ji-zhi-shi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="装机知识">装机知识</span>
            <span class="post-date" title="2021-09-07 20:54:21">2021/09/07</span>
        </a>
        
        
        <a  class="全部文章 计算机 集成开发环境 windows "
           href="/2021/09/07/ji-suan-ji/ji-cheng-kai-fa-huan-jing/windows/typora-picgo-pei-zhi-ben-di-bi-ji/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="typora+picgo配置本地笔记">typora+picgo配置本地笔记</span>
            <span class="post-date" title="2021-09-07 20:17:11">2021/09/07</span>
        </a>
        
        
        <a  class="全部文章 修身 生活知识 "
           href="/2021/04/15/xiu-shen/sheng-huo-zhi-shi/jing-wai-lu-you-xue-xi-ru-he-shi-yong-fu-kuan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="境外旅游学习如何使用付款">境外旅游学习如何使用付款</span>
            <span class="post-date" title="2021-04-15 15:06:10">2021/04/15</span>
        </a>
        
        
        <a  class="全部文章 真其它 "
           href="/2021/01/27/zhen-qi-ta/distributed-representations-of-words-and-phrases-and-their-compositionality/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Distributed Representations of Words and Phrases and their Compositionality">Distributed Representations of Words and Phrases and their Compositionality</span>
            <span class="post-date" title="2021-01-27 19:38:27">2021/01/27</span>
        </a>
        
        
        <a  class="全部文章 修身 奇思妙想 "
           href="/2019/11/16/xiu-shen/qi-si-miao-xiang/zhu-guan-shi-jie-he-ke-guan-shi-jie-de-tao-lun-2019-11-16/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="主观世界和客观世界的讨论">主观世界和客观世界的讨论</span>
            <span class="post-date" title="2019-11-16 00:00:00">2019/11/16</span>
        </a>
        
        
        <a  class="全部文章 学科 影评 "
           href="/2019/07/05/xue-ke/ying-ping/tian-cai-qiang-shou-2019-07-05/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="天才枪手">天才枪手</span>
            <span class="post-date" title="2019-07-05 00:00:00">2019/07/05</span>
        </a>
        
        
        <a  class="全部文章 学科 文学 "
           href="/2019/07/05/xue-ke/wen-xue/tai-si-2019-07-05/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="苔丝">苔丝</span>
            <span class="post-date" title="2019-07-05 00:00:00">2019/07/05</span>
        </a>
        
        
        <a  class="全部文章 修身 奇思妙想 "
           href="/2018/11/04/xiu-shen/qi-si-miao-xiang/lun-xue-xi-he-ying-shi-jiao-yu-2018-11-04/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="论学习和应试教育">论学习和应试教育</span>
            <span class="post-date" title="2018-11-04 00:00:00">2018/11/04</span>
        </a>
        
        
        <a  class="全部文章 学科 文学 "
           href="/2018/09/08/xue-ke/wen-xue/xian-yi-ren-x-de-xian-shen-2018-09-08/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="嫌疑人X的献身">嫌疑人X的献身</span>
            <span class="post-date" title="2018-09-08 00:00:00">2018/09/08</span>
        </a>
        
        
        <a  class="全部文章 学科 影评 "
           href="/2018/08/28/xue-ke/ying-ping/peng-ran-xin-dong-2018-08-28/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="怦然心动">怦然心动</span>
            <span class="post-date" title="2018-08-28 00:00:00">2018/08/28</span>
        </a>
        
        
        <a  class="全部文章 学科 文学 "
           href="/2018/08/19/xue-ke/wen-xue/liao-bu-qi-de-gai-ci-bi-2018-08-19/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="了不起的盖茨比">了不起的盖茨比</span>
            <span class="post-date" title="2018-08-19 00:00:00">2018/08/19</span>
        </a>
        
        
        <a  class="全部文章 修身 奇思妙想 "
           href="/2018/08/18/xiu-shen/qi-si-miao-xiang/nan-nu-sui-tan-2018-08-18/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="男女随谈">男女随谈</span>
            <span class="post-date" title="2018-08-18 00:00:00">2018/08/18</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-最近/LeetCode刷题" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">LeetCode刷题</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="最近">最近</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color4">C++</a>
            
            <a class="color5">Java</a>
            
            <a class="color2">python</a>
            
            <a class="color2">github</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-07-19 10:22:20'>2021-12-15 12:14</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:42.5k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E5%8F%B7-%E9%A2%98%E7%9B%AE"><span class="toc-text">题号.题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B31%E5%90%8D%E7%A7%B0-self"><span class="toc-text">思想1名称(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B32%E5%90%8D%E7%A7%B0"><span class="toc-text">思想2名称*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8"><span class="toc-text">数据结构入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">217.存在重复元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%90%8E%E6%89%AB%E6%8F%8F"><span class="toc-text">排序后扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95-%E8%BE%B9%E6%AF%94%E8%BE%83%E8%BE%B9%E6%89%AB%E6%8F%8F"><span class="toc-text">选择排序法,边比较边扫描*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%95%BF%E5%BA%A6%E5%B0%8F%E4%BA%8E%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6-%E5%88%99%E9%87%8D%E5%A4%8D"><span class="toc-text">集合长度小于数组长度,则重复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%9C%A8%E6%8F%92%E5%85%A5%E7%9A%84%E6%97%B6%E5%80%99%E5%A6%82%E5%AD%98%E5%9C%A8%E5%88%99%E9%87%8D%E5%A4%8D"><span class="toc-text">哈希表,在插入的时候如存在则重复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-text">53.最大子序和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">1.两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8map-self"><span class="toc-text">用map(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE"><span class="toc-text">暴力枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-4"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-5"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">88:合并两个有序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6-%E8%87%AA%E5%B7%B1"><span class="toc-text">归并(自己</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-6"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6-%E8%83%8C-%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E9%9D%9E%E5%B8%B8%E7%AE%80%E6%B4%81%E7%B2%BE%E5%A6%99"><span class="toc-text">归并(背, 一行代码, 非常简洁精妙</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-7"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%90%88%E5%B9%B6%E5%90%8E%E8%B0%83%E7%94%A8%E6%8E%92%E5%BA%8F-%E7%AE%97%E6%B3%95%E5%B7%A5%E5%85%B7%E7%9A%84%E7%B2%BE%E9%AB%93"><span class="toc-text">直接合并后调用排序(算法工具的精髓</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-8"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II"><span class="toc-text">350:两个数组的交集II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-%E5%8F%8C%E6%8C%87%E9%92%88-self"><span class="toc-text">排序+双指针(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-9"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%AE%98%E6%96%B9"><span class="toc-text">哈希表(官方</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-10"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text">121:买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E5%8F%8C%E5%BE%AA%E7%8E%AF-self"><span class="toc-text">暴力双循环(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-11"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-text">动态规划*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-12"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5"><span class="toc-text">566:重塑矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E8%B5%8B%E5%80%BC-self"><span class="toc-text">新建数组循环赋值(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-13"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-text">118:杨辉三角</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%89%8B%E7%AE%97-self"><span class="toc-text">模拟手算(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-14"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC"><span class="toc-text">36:有效的数独</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Map%E5%AD%98%E5%82%A8%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0-self"><span class="toc-text">Map存储是否出现(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-15"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="toc-text">73:矩阵置零</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%B8%A4%E4%B8%AAset%E8%AE%B0%E5%BD%950%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84%E8%A1%8C%E6%95%B0%E5%92%8C%E5%88%97%E6%95%B0-self"><span class="toc-text">用两个set记录0所对应的行数和列数(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-16"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%87%E8%AE%B0%E5%8F%98%E9%87%8F"><span class="toc-text">使用两个标记变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-17"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8BigSet%E7%B1%BB"><span class="toc-text">使用BigSet类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6"><span class="toc-text">387:字符串中的第一个唯一字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E5%AD%98%E5%AD%97%E7%AC%A6-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0-self"><span class="toc-text">Hash存字符-出现次数(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-18"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-18"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#383-%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-text">383:赎金信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AAMap%E5%AD%98%E5%82%A8%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0-%E7%84%B6%E5%90%8E%E9%81%8D%E5%8E%86%E6%AF%94%E8%BE%83-self"><span class="toc-text">两个Map存储出现次数, 然后遍历比较(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-19"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-19"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%BB%9F%E8%AE%A1-%E5%8F%98%E4%BD%93%E6%AF%94%E8%BE%83"><span class="toc-text">数组统计+变体比较*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-20"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-20"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">242. 有效的字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%90%8E%E6%AF%94%E8%BE%83"><span class="toc-text">排序后比较*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-21"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-21"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-text">141:环形链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-self"><span class="toc-text">快慢指针(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-22"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-22"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-1"><span class="toc-text">哈希表*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-23"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-23"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">21:合并两个有序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E5%A4%B4%E6%8C%87%E9%92%88-self"><span class="toc-text">假头指针(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-24"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-24"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-25"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-25"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-text">203:移除链表元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-self"><span class="toc-text">递归(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-26"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-26"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-text">迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">206:反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E5%A4%B4-%E4%B8%B4%E6%97%B6%E8%8A%82%E7%82%B9-self"><span class="toc-text">假头+临时节点(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-27"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-27"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">83. 删除排序链表中的重复元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E8%BF%AD%E4%BB%A3-self"><span class="toc-text">双指针迭代(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-28"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-28"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E5%A4%AA%E5%A6%99%E4%BA%86"><span class="toc-text">递归*(太妙了</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-29"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-29"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">20. 有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88-self"><span class="toc-text">栈(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-30"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-30"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-text">232. 用栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F-self"><span class="toc-text">模拟(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-32"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-31"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F-%E4%B8%AD%E5%BA%8F-94-%E5%90%8E%E5%BA%8F-145-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">144. 二叉树的前序, 中序(94), 后序(145), 层次遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-self-1"><span class="toc-text">递归(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E6%80%9D%E8%B7%AF"><span class="toc-text">前序思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E4%BB%A3%E7%A0%81"><span class="toc-text">前序代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">前序复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%89%8B%E5%8A%A8%E6%A8%A1%E6%9D%BF%E5%A5%97%E8%B7%AF"><span class="toc-text">模拟手动模板套路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%BB%A3%E7%A0%81"><span class="toc-text">前序思路及代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%BB%A3%E7%A0%81"><span class="toc-text">中序思路及代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%BB%A3%E7%A0%81"><span class="toc-text">后序思路及代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%A0%88%E8%BF%AD%E4%BB%A3"><span class="toc-text">用栈迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%BB%A3%E7%A0%81"><span class="toc-text">前序遍历思路及代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%80%9D%E8%B7%AF%E5%8F%8A%E4%BB%A3%E7%A0%81"><span class="toc-text">后序遍历思路及代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102. 二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1-%E7%94%A8%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0-self"><span class="toc-text">奇淫巧计-用前序遍历实现(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-33"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-32"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-31"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">层次遍历*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-34"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-33"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-32"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">104. 二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-self-2"><span class="toc-text">递归(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-35"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-34"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-33"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-text">一行代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-36"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-35"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-34"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">101. 对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%B3%95-self-%E5%81%9A%E4%B8%8D%E5%87%BA%E6%9D%A5"><span class="toc-text">遍历法(self, 做不出来</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-37"><span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">迭代*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-38"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-36"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-35"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">226. 翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-self-3"><span class="toc-text">递归(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-39"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-37"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-36"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text">112. 路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%8E%9F%E6%A0%91%E4%BD%BF%E5%BE%97%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E4%B8%BA%E8%B7%AF%E5%BE%84%E5%92%8C-self"><span class="toc-text">改变原树使得节点的值为路径和(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-40"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-38"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-37"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-1"><span class="toc-text">递归*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-41"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-39"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-38"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-text">700. 二叉搜索树中的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-self-4"><span class="toc-text">递归(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-42"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-40"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-39"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-2"><span class="toc-text">迭代*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-43"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-41"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-40"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%8F%8D%E6%80%9D"><span class="toc-text">错误反思*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-44"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-42"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">701. 二叉搜索树中的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-self"><span class="toc-text">迭代(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-45"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-43"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-41"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-2"><span class="toc-text">递归*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-44"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-42"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">98. 验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%9A%84%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3-self"><span class="toc-text">错误的递归思想(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-46"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-45"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-43"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-text">正确的递归*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-47"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-46"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-44"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%BA%E9%80%92%E5%A2%9E"><span class="toc-text">中序遍历的结果为递增*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-48"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-47"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-45"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#653-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-IV-%E8%BE%93%E5%85%A5-BST"><span class="toc-text">653. 两数之和 IV - 输入 BST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E8%BF%9B%E9%9B%86%E5%90%88-%E8%BF%9B%E4%B9%8B%E5%89%8D%E5%85%88%E5%88%A4%E6%96%AD-self"><span class="toc-text">层次遍历进集合,进之前先判断(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-49"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-48"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-46"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-50"><span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">235. 二叉搜索树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-self-5"><span class="toc-text">递归(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-51"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-49"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-47"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B32%E5%90%8D%E7%A7%B0-1"><span class="toc-text">思想2名称*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-52"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-50"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-48"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="toc-text">207. 课程表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-self"><span class="toc-text">拓扑排序(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-53"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-51"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-49"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode%E7%83%AD%E9%A2%98Hot100"><span class="toc-text">LeetCode热题Hot100</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-text">2. 两数相加</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%BA%BA%E5%B7%A5%E5%8A%A0%E6%B3%95-self"><span class="toc-text">模拟人工加法(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-54"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-52"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-50"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-self-1"><span class="toc-text">迭代(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-55"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-53"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-51"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-text">3. 无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-%E6%83%B3%E9%94%99%E6%96%B9%E5%90%91"><span class="toc-text">动态规划(self, 想错方向</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-56"><span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">滑动窗口*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-57"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-54"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-52"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">4. 寻找两个正序数组的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B31%E5%90%8D%E7%A7%B0-self-1"><span class="toc-text">思想1名称(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-58"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-55"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-53"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%96%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">合并排序取中位数*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-59"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-56"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-54"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">5. 最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%8A%98%E6%AF%94%E8%BE%83%E7%9B%B8%E7%AD%89-self"><span class="toc-text">对折比较相等(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-60"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-57"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-55"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">10. 正则表达式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-self-%E5%8F%AA%E8%BF%87%E4%BA%86%E4%B8%80%E5%8D%8A%E6%A0%B7%E4%BE%8B-%E6%B2%A1%E5%81%9A%E5%87%BA%E6%9D%A5"><span class="toc-text">递归(self, 只过了一半样例, 没做出来</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-61"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-58"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0"><span class="toc-text">错误原因:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-text">动态规划*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-62"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-59"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-56"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">11. 盛最多水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-63"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-60"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-57"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">15. 三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%BE%AA%E7%8E%AF-map%E8%AE%A1%E6%95%B0-set%E5%AD%98%E5%82%A8-self"><span class="toc-text">双循环+map计数+set存储(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-64"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-61"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-58"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">排序+双指针*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-65"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-62"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-59"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-text">17. 电话号码的字母组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E5%BE%AA%E7%8E%AF-self"><span class="toc-text">递归+循环(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-66"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-63"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-60"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-67"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-64"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-61"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">19. 删除链表的倒数第 N 个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-self-1"><span class="toc-text">快慢指针(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-68"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-65"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-62"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-text">22. 括号生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%8B%AC%E5%8F%B7-self"><span class="toc-text">递归+迭代加括号(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-69"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-66"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-63"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B32%E5%90%8D%E7%A7%B0-2"><span class="toc-text">思想2名称*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-70"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-67"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-64"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">23. 合并K个升序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E6%94%BE%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E5%BD%A2%E6%88%90%E9%93%BE%E8%A1%A8-self"><span class="toc-text">存放数组排序后形成链表(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-71"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-68"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-65"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB-self"><span class="toc-text">分治*(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-72"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%811"><span class="toc-text">代码1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%812"><span class="toc-text">代码2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-66"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-self"><span class="toc-text">优先队列(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-73"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-69"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-67"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-text">31. 下一个排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95"><span class="toc-text">下一个排列算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-74"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-70"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-68"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-text">32. 最长有效括号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-75"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-71"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-69"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">33. 搜索旋转排序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%81%8D%E5%8E%86-self"><span class="toc-text">顺序遍历(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-76"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-72"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-70"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93-self"><span class="toc-text">二分查找变体(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-77"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-73"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-71"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93-self-1"><span class="toc-text">二分查找变体(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-78"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-74"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%812-1"><span class="toc-text">代码2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-72"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-self-%E6%B2%A1%E5%81%9A%E5%87%BA%E6%9D%A5"><span class="toc-text">回溯(self, 没做出来</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-79"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-75"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-80"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-76"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-73"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">46. 全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E7%A9%BA-self%E6%B2%A1%E5%81%9A%E5%87%BA%E6%9D%A5"><span class="toc-text">填空(self没做出来</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-81"><span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-82"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-77"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-74"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-text">48. 旋转图像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE%E5%8A%A0%E9%95%9C%E5%83%8F"><span class="toc-text">利用矩阵的转置加镜像*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-83"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-78"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-75"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-text">49. 字母异位词分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-self"><span class="toc-text">Map(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-84"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-79"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-76"><span class="toc-text">复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-80"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-text">55. 跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self"><span class="toc-text">动态规划?(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-85"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-77"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-text">56. 合并区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F-self-%E6%B2%A1%E5%81%9A%E5%87%BA%E6%9D%A5"><span class="toc-text">模拟(self, 没做出来</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-86"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-82"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%90%8E%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="toc-text">排序后找规律*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-87"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-83"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-78"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">62. 不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-1"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-88"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-84"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-79"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="toc-text">动态规划*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-89"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-85"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-80"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6"><span class="toc-text">组合数学</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-90"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-86"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-81"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">64. 最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-2"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-91"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-87"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-82"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="toc-text">动态规划*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-92"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-83"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-text">75. 颜色分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3-self"><span class="toc-text">桶排序思想(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-93"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-84"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="toc-text">双指针*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-94"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-88"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-85"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-text">78. 子集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-self"><span class="toc-text">回溯(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-95"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-89"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-86"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-3"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-96"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-90"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-87"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-text">79. 单词搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-97"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-91"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">96. 不同的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-4"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-98"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-92"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-88"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%9E%84%E9%80%A0-self"><span class="toc-text">递归构造(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-99"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-93"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-89"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-text">114. 二叉树展开为链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95-self"><span class="toc-text">递归原地算法(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-100"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-94"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-95"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-90"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%86%8D%E6%9E%84%E9%80%A0"><span class="toc-text">前序遍历再构造*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-101"><span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-text">128. 最长连续序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F%E8%AE%A1%E6%95%B0-self"><span class="toc-text">去重排序计数(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-102"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-96"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-91"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash"><span class="toc-text">Hash*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-103"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-97"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-92"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">136. 只出现一次的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97-1"><span class="toc-text">位运算*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-104"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-98"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-93"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-alarm-clock"><span class="toc-text">139. 单词拆分⏰</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8set%E5%AD%98%E5%82%A8%E5%90%8E%E9%80%92%E5%BD%92-self-%E6%B2%A1%E8%A7%A3%E5%86%B3"><span class="toc-text">用set存储后递归(self, 没解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-105"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-99"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-94"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B32%E5%90%8D%E7%A7%B0-3"><span class="toc-text">思想2名称*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-106"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-100"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-95"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="toc-text">142. 环形链表 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-%E4%B8%80%E4%BA%8C%E4%B8%A4%E6%AC%A1%E7%9B%B8%E9%81%87"><span class="toc-text">快慢指针+一二两次相遇</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-107"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-101"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-96"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%93%BE%E8%A1%A8"><span class="toc-text">修改链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-108"><span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="toc-text">146. LRU 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%88%B6%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-self"><span class="toc-text">自制双向链表(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-109"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-102"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">148. 排序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%AD%98%E5%82%A8%E5%BF%AB%E6%8E%92%E5%90%8E%E5%86%8D%E8%B5%8B%E5%80%BC-self"><span class="toc-text">list存储快排后再赋值(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-110"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-103"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-97"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6-slef"><span class="toc-text">归并(slef*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-111"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-104"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-98"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">152. 乘积最大子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A50%E5%88%86%E5%89%B2%E5%90%8E%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86%E9%81%87%E5%88%B0%E8%B4%9F%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%BA%E5%A5%87%E6%95%B0%E6%97%B6%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%A5%87%E6%95%B0%E5%81%9C%E6%AD%A2"><span class="toc-text">以0分割后双向遍历遇到负数个数为奇数时最后一个奇数停止</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-112"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-105"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-99"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-alarm-clock"><span class="toc-text">动态规划⏰</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-113"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-106"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-100"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-text">155. 最小栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E6%A0%88%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%E6%A0%88-self"><span class="toc-text">一个数字栈一个最小数字栈(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-114"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-107"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-101"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89pair%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8"><span class="toc-text">自定义pair链表存储*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-115"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-108"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-text">160. 相交链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%B3%95-self"><span class="toc-text">指针法(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-116"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-109"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-102"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E9%9B%85%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%97%B6"><span class="toc-text">双指针优雅永不过时*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-117"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-110"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-103"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-text">169. 多数元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8"><span class="toc-text">摩尔投票</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-118"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-111"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-104"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-text">200. 岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86-self"><span class="toc-text">深度遍历(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-119"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-112"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-105"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208. 实现 Trie (前缀树)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie"><span class="toc-text">Trie</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-120"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-113"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-alarm-clock"><span class="toc-text">215. 数组中的第K个最大元素⏰</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0-self"><span class="toc-text">调用库函数(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-114"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-106"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B32%E5%90%8D%E7%A7%B0-4"><span class="toc-text">思想2名称*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-121"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-115"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-107"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-text">221. 最大正方形</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-5"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-122"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-116"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-108"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-5"><span class="toc-text">动态规划*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-123"><span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">234. 回文链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E5%8F%8D%E8%BD%AC%E5%AF%B9%E6%AF%94-self"><span class="toc-text">折半反转对比(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-124"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-117"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-109"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-alarm-clock"><span class="toc-text">快慢指针*(⏰</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-125"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-118"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-110"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-LCA"><span class="toc-text">236. 二叉树的最近公共祖先(LCA)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-126"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-119"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-111"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">238. 除自身以外数组的乘积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E7%B4%AF%E4%B9%98%E5%8F%B3%E7%B4%AF%E4%B9%98%E5%86%8D%E7%9B%B8%E4%B9%98"><span class="toc-text">左累乘右累乘再相乘</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-127"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-120"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-112"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="toc-text">240. 搜索二维矩阵 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%81%8D%E5%8E%86"><span class="toc-text">暴力遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-128"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-121"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-113"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%8F%E8%A1%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">对每行二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-129"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-122"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-114"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">279. 完全平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-6"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-130"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-123"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-115"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E6%B3%95"><span class="toc-text">数学法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-131"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-124"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-116"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-text">283. 移动零</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E9%9D%9E0%E8%A6%86%E7%9B%96%E5%88%B0%E6%95%B0%E7%BB%84%E5%89%8D%E9%9D%A2%E5%90%8E%E9%9D%A2%E8%B5%8B%E5%80%BC0-self"><span class="toc-text">将非0覆盖到数组前面后面赋值0(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-132"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-125"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-117"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88-alarm-clock"><span class="toc-text">左右指针⏰</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-133"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-126"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-118"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="toc-text">287. 寻找重复数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text">快慢指针法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-134"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-127"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-119"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">300. 最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-7"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-135"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-128"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-120"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-text">309. 最佳买卖股票时机含冷冻期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-8"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-136"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-129"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-121"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-text">322. 零钱兑换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-text">从上往下记忆化搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-137"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-130"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-122"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-9"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-138"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-131"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-123"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0"><span class="toc-text">338. 比特位计数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-6"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-139"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-132"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-124"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-text">347. 前 K 个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E5%A0%86"><span class="toc-text">哈希表+优先队列(堆)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-140"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-133"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-125"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-text">394. 字符串解码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-141"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-134"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-126"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-10"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-text">509. 斐波那契数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-11"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-142"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-135"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-127"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="toc-text">动态规划+滚动数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-3"><span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-143"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-136"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-128"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-text">递归+记忆化搜索*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-144"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-137"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-129"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1137-%E7%AC%AC-N-%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-text">1137. 第 N 个泰波那契数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%EF%BC%88self"><span class="toc-text">递归（self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-145"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-138"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%98%E5%82%A8%E5%90%8E%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE-self"><span class="toc-text">动态规划存储后随机访问(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-146"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-139"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-130"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E6%8E%A8%E5%AF%BC%E4%BA%8C%E5%8F%89%E9%80%92%E5%BD%92-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="toc-text">递归(推导二叉递归+滚动数组)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-147"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-140"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-131"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">70. 爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%BE%85%E5%8A%A9%E6%95%B0%E7%BB%84-self"><span class="toc-text">动态规划+辅助数组(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-148"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-141"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-132"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84-1"><span class="toc-text">动态规划+滚动数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-149"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-142"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-133"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">746. 使用最小花费爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%89%BE%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B-self"><span class="toc-text">动态规划找转移方程(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-150"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-143"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-134"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B"><span class="toc-text">动态规划另外一个转移方程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-151"><span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-self-6"><span class="toc-text">递归(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-152"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-144"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-135"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%89%BE%E5%8A%A8%E6%80%81%E6%96%B9%E7%A8%8B"><span class="toc-text">动态规划找动态方程*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-153"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-145"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-136"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%BB%91%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="toc-text">动态规划滑动数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-146"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-137"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="toc-text">213. 打家劫舍 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%A6%96%E5%B0%BE%E5%A4%84%E7%90%86-self"><span class="toc-text">动态规划+首尾处理(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-154"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-147"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-138"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#740-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A3-%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0"><span class="toc-text">740. 打家劫舍Ⅳ(删除并获得点数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E6%95%B0%E6%8D%AE%E4%B8%8B%E6%A0%87%E8%AE%A1%E6%95%B0-self"><span class="toc-text">观察数据下标计数(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-155"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-148"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-139"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="toc-text">337. 打家劫舍 III</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%89%BE-self"><span class="toc-text">动态规划找(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-156"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A0%B8%E5%BF%83"><span class="toc-text">代码核心</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-149"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-140"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B-%E5%BE%85"><span class="toc-text">动态规划另一个转移方程(待</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-157"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-150"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-141"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-text">查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98"><span class="toc-text">每日一题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1037-%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%97%8B%E9%95%96-22-06-08"><span class="toc-text">1037. 有效的回旋镖 22-06-08</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6-%E5%8F%89%E4%B9%98%E7%9A%84%E4%BA%8C%E7%BB%B4%E5%BA%94%E7%94%A8"><span class="toc-text">数学-叉乘的二维应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-158"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-151"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-142"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E7%82%B9%E7%9A%84%E4%B8%89%E7%82%B9%E6%96%9C%E7%8E%87%E7%9B%B8%E5%90%8C%E4%B8%BA%E4%B8%80%E6%9D%A1%E7%9B%B4%E7%BA%BF"><span class="toc-text">共点的三点斜率相同为一条直线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-159"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-152"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#497-%E9%9D%9E%E9%87%8D%E5%8F%A0%E7%9F%A9%E5%BD%A2%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%82%B9-22-06-09"><span class="toc-text">497. 非重叠矩形中的随机点 22-06-09</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">前缀和+二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-160"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-153"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-143"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-4 i,
    .toc-level-4 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Leetcode时间限制</p>
<p><img src="D:\pic-bed\img\1610787167-ACRBUz-complexity.png" alt="complexity.png"></p>
<p>注意:</p>
<p><span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>表示未完成</p>
<p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>表示重要</p>
<p><span class="github-emoji"><span>🌟</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>表示超级重要</p>
<h3 id="题号-题目"><a href="#题号-题目" class="headerlink" title="题号.题目"></a>题号.题目</h3><p>描述</p>
<p>样例</p>
<h4 id="思想1名称-self"><a href="#思想1名称-self" class="headerlink" title="思想1名称(self"></a>思想1名称(self</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code>\\语法, 以后搜索\\语法可以学习语法
\\思想, 学习思想
</code></pre>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="思想2名称"><a href="#思想2名称" class="headerlink" title="思想2名称*"></a>思想2名称*</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h2 id="数据结构入门"><a href="#数据结构入门" class="headerlink" title="数据结构入门"></a>数据结构入门</h2><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate/">存在重复元素</a></h3><h4 id="排序后扫描"><a href="#排序后扫描" class="headerlink" title="排序后扫描"></a>排序后扫描</h4><p><strong>算法</strong></p>
<p>排序后再扫描,有相邻两位数字相同即存在相同元素,可以用Arrays.sort()进行排序</p>
<pre><code class="java">        Arrays.sort(nums);		//语法
        int n = nums.length;
        for (int i = 0; i &lt; n - 1; i++) {
            if (nums[i] == nums[i + 1]) {
                return true;
            }
        }
        return false;
</code></pre>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度:O(NlogN).</li>
<li>空间空咋读:O(logN),为递归调用栈的深度.</li>
</ul>
<h4 id="选择排序法-边比较边扫描"><a href="#选择排序法-边比较边扫描" class="headerlink" title="选择排序法,边比较边扫描*"></a>选择排序法,边比较边扫描*</h4><pre><code class="java">        for (i = 1; i &lt; nums.length;i++) {
            for (j = i-1; j &gt;= 0; j--) {
                if (nums[i] == nums[j]) {
                    return true;
                }else if(nums[i] &gt; nums[j]){
                    break;
                }
            }
            j++;		//语法,j指向的是要替换的元素
            int temp = nums[i];
            for (int k = i; k &gt; j; k--) {
                nums[k] = nums[k-1];
            }
            nums[j] = temp;
        }
        return false;
</code></pre>
<ul>
<li>时间:O(N^2)</li>
<li>空间:O(1)</li>
</ul>
<h4 id="集合长度小于数组长度-则重复"><a href="#集合长度小于数组长度-则重复" class="headerlink" title="集合长度小于数组长度,则重复"></a>集合长度小于数组长度,则重复</h4><pre><code class="java">        Set&lt;Integer&gt; res = new HashSet&lt;Integer&gt;();//语法
        for(int i:nums)
            res.add(i);
        return res.size()&lt;nums.length?true:false;
</code></pre>
<ul>
<li>时间:O(N)</li>
<li>空间:O(N)</li>
</ul>
<h4 id="哈希表-在插入的时候如存在则重复"><a href="#哈希表-在插入的时候如存在则重复" class="headerlink" title="哈希表,在插入的时候如存在则重复"></a>哈希表,在插入的时候如存在则重复</h4><pre><code class="java">        unordered_set&lt;int&gt; s;	//语法
        for (int x: nums) {		//语法
            if (s.find(x) != s.end()) {//语法
                return true;
            }
            s.insert(x);
        }
</code></pre>
<ul>
<li>时间:O(N)</li>
<li>空间:O(N)</li>
</ul>
<h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和</a></h3><p>求数组中连续子序列最大的一段子数组.</p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>假设$nums$数组的长度为$0$到$n-1$.</p>
<p>设**$f(i)$为以下标$i$元素结尾的「连续子数组的和**[^ 1]那么,答案为<br>$$<br>\sum_{0\leq i\leq n-1}{\max \left{ f\left( i \right) \right}}<br>$$<br>而基于$f(i)$的定义的假设,我们可以得到$f(i)$的递推公式:<br>$$<br>f(i) = max(f(i-1)+a_n,a_n)<br>$$<br>注意到$f(i)$只与$f(i-1)$有关,所以可以将空间复杂度将为$O(1)$.</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0;
        int maxAns = nums[0];
        for (int a:nums){
            pre = Math.max(pre+a,a);    	//f(i)
            maxAns = Math.max(pre,maxAns);	//f(0)-f(n-1)求最大值
        }
        return maxAns;
    }
}
</code></pre>
<h5 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度:$O(n)$</p>
<p>空间复杂度:$O(1)$</p>
<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<pre><code>输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
</code></pre>
<h4 id="用map-self"><a href="#用map-self" class="headerlink" title="用map(self"></a>用map(self</h4><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>扫描一遍, 将nums[i]为<code>key</code>, i为<code>value</code>, 如果遇到相同的存储在第二个map里面</p>
<p>得到答案的话用直接取<code>key=nums[i]和key=target-nums[i]</code>的<code>value</code>值即可, 需要注意当两个数字相同的这种情况.</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer,Integer&gt; m1 =new HashMap&lt;&gt;();	//语法, 只能用Integer
        Map&lt;Integer, Integer&gt; m2 = new HashMap&lt;&gt;();
        for(int i =0; i &lt; nums.length;i++){			//语法, nums.length
            int num = nums[i];
            if(!m1.containsKey(num)) {
                m1.put(num,i);						//语法
            }else{
                m2.put(num,i);
            }
        }
        // System.out.println(m1);
        // System.out.println(m2);
        int []result = new int[2];					//语法, 用[]而不是()
        for(int num : nums){
            int first = num;
            int second = target-num;
            if (first==second) {
                if(m1.containsKey(first)&amp;&amp;m2.containsKey(second)) {//语法
                    result[0] = m1.get(first);
                    result[1] = m2.get(second);
                }
            }else if(m1.containsKey(first)&amp;&amp;m1.containsKey(second)) {
                result[0] =m1.get(first);			//语法
                result[1] = m1.get(second);
                break;
            }
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(N)</li>
</ul>
<h4 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h4><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>两个for循环, 第一个for遍历所有元素nums[i], 第二个for从第一个for的当前元素向后扫描nums[j], 如果等于nums[j]= target-nums[i]的话, 返回i,j即可.</p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = i + 1; j &lt; n; ++j) {
                if (nums[i] + nums[j] == target) {	//思想
                    return new int[]{i, j};			//语法
                }
            }
        }
        return new int[0];
    }
}
</code></pre>
<h5 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N^2)</li>
<li>空间: O(1)</li>
</ul>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表*"></a>哈希表*</h4><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p>扫描元素, 如果已经包含$target-nums[i]$的话, 返回当前下标和另一个数字存储在map中的下标, 否则的话把这个数字当作key, 其对应的下标当作value进行存储.</p>
<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();
        for (int i = 0; i &lt; nums.length; ++i) {
            /*思想, 太精妙了, 如果扫描到第一个数字, 则放入, 如果扫描第二个数字, 则直接返回答案
             *相等数字情况下, 正好避免了两个key相同
             *不相等数字下, 直接返回答案, 不进行存储, 非常高效
             */
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};//语法
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];		//语法
    }
}
</code></pre>
<h5 id="复杂度-5"><a href="#复杂度-5" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间: O(N)</p>
<p>空间: O(N))</p>
<h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88:合并两个有序数组"></a>88:合并两个有序数组</h3><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<pre><code>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
</code></pre>
<h4 id="归并-自己"><a href="#归并-自己" class="headerlink" title="归并(自己"></a>归并(自己</h4><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><p>从后往前归并排序</p>
<h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m-1;
        int j = n-1;
        int point = m+n-1;
        //系统的特殊数据,不具有普适性
        if (m==0) {
            for (int l = 0; l &lt; n; l++) {
                nums1[l] = nums2[l];
            }
        }
        //思想, 归并
        while(i!=-1 &amp;&amp; j!=-1) {
            if(nums1[i] &gt;nums2[j]) {
                nums1[point] = nums1[i];
                i--;
            }else {
                nums1[point] = nums2[j];
                j--;
            }
            point--;
        }
        //思想,当第二个数组剩下的话需要补上去, 第一个数组自动补了(正宗归并的话都要补)
        while(j!=-1) {
            nums1[point] = nums2[j];
            point--;
            j--;
        }
        return;
    }
}
</code></pre>
<h5 id="复杂度-6"><a href="#复杂度-6" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(n)</li>
<li>空间: O(1)</li>
</ul>
<h4 id="归并-背-一行代码-非常简洁精妙"><a href="#归并-背-一行代码-非常简洁精妙" class="headerlink" title="归并(背, 一行代码, 非常简洁精妙"></a>归并(背, 一行代码, 非常简洁精妙</h4><h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><p>$m$指向第一个数组的有数字的末尾, $n$指向第二个数组的有数字的末尾, 而$n+m-1$自然是真正的$point$, 不需要单独设置$point$.</p>
<p><strong>在第二个指针没有穷尽时:</strong></p>
<p>​	<strong>如果m到第一个数组移动完</strong> 或者 <strong>第一个数组的指针的数值小于第二个数组的指针的数值的话</strong>, 将第二个数组指针指向的数值赋值给n+m-1位置, 否则将第一个数组指针指向的数值赋值给n+m-1位置.</p>
<h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
       while(n&gt;0) {

           nums1[n+m-1] = m&lt;1||(nums1[m-1]&lt; nums2[n-1])?nums2[--n]:nums1[--m];
           
       }
    }
}
</code></pre>
<ol>
<li>$while(n&gt;0)$和将$nums2[–-n]$配合消除了正宗归并排序的剩余的第二个数组的补齐操作.</li>
<li>$m&lt;1$和$nums1[–m]$配合消除了第一个数组的补齐操作.</li>
<li>$–n$和$–m$则消除了我的需要将$i=m-1, j=n-1$作为指针.</li>
</ol>
<h5 id="复杂度-7"><a href="#复杂度-7" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(1).</li>
</ul>
<h4 id="直接合并后调用排序-算法工具的精髓"><a href="#直接合并后调用排序-算法工具的精髓" class="headerlink" title="直接合并后调用排序(算法工具的精髓"></a>直接合并后调用排序(算法工具的精髓</h4><h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h5><p>调用算法库</p>
<h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        for (int i = 0; i != n; ++i) {
            nums1[m + i] = nums2[i];
        }
        Arrays.sort(nums1);
        //C++ sort(nums1.begin(), nums1.end());
        //python nums1.sort()
    }
}
</code></pre>
<h5 id="复杂度-8"><a href="#复杂度-8" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间: $O((N+M)log(N+M))$</p>
<p>空间: $log(N+M))$</p>
<h3 id="350-两个数组的交集II"><a href="#350-两个数组的交集II" class="headerlink" title="350:两个数组的交集II"></a>350:两个数组的交集II</h3><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
<p>示例 1：</p>
<pre><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
</code></pre>
<h4 id="排序-双指针-self"><a href="#排序-双指针-self" class="headerlink" title="排序+双指针(self"></a>排序+双指针(self</h4><h5 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h5><p>本来想着用两个<code>set</code>存储两个数组, 然后求交集, 但是发现多个重复元素的话集合只能保留一个, 所以还是用人工思想转代码, 先排序, 然后双指针.</p>
<h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        List&lt;Integer&gt; l = new ArrayList&lt;&gt;();
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int i = 0;
        int j = 0;
        while (i &lt;nums1.length &amp;&amp; j &lt;nums2.length) {
            if (nums1[i] == nums2[j]) {
                l.add(nums1[i]);
                i++;
                j++;
            }else if(nums1[i] &lt; nums2[j]) {	//思想,哪个小移动哪个
                i++;
            }else {
                j++;
            }
        }
        int[] result = new int[l.size()];
        for(int k = 0; k &lt; l.size(); k++) {
            result[k] = l.get(k);
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-9"><a href="#复杂度-9" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(max{N, M}log(max{N, M}), 主要是排序, 算法本身是O(N)</li>
<li>空间: O(N+M) 结果的返回</li>
</ul>
<h4 id="哈希表-官方"><a href="#哈希表-官方" class="headerlink" title="哈希表(官方"></a>哈希表(官方</h4><h5 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h5><p>由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数。对于一个数字，其在交集中出现的次数等于该数字在两个数组中出现次数的最小值。</p>
<p>首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。</p>
<p>为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。</p>
<h5 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        if (nums1.length &gt; nums2.length) {
            return intersect(nums2, nums1);
        }
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for (int num : nums1) {
            int count = map.getOrDefault(num, 0) + 1;
            map.put(num, count);
        }
        int[] intersection = new int[nums1.length];
        int index = 0;
        for (int num : nums2) {
            int count = map.getOrDefault(num, 0);
            if (count &gt; 0) {
                intersection[index++] = num;
                count--;
                if (count &gt; 0) {
                    map.put(num, count);
                } else {
                    map.remove(num);
                }
            }
        }
        return Arrays.copyOfRange(intersection, 0, index);
    }
}
</code></pre>
<h5 id="复杂度-10"><a href="#复杂度-10" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(m+n)</li>
<li>空间: O(min⁡(m,n))</li>
</ul>
<h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121:买卖股票的最佳时机"></a>121:买卖股票的最佳时机</h3><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
</code></pre>
<h4 id="暴力双循环-self"><a href="#暴力双循环-self" class="headerlink" title="暴力双循环(self"></a>暴力双循环(self</h4><h5 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h5><p>找外循环后面的比该元素大的, 计算差值,如果比max大, 则替换, 否则继续循环.</p>
<h5 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        int length = prices.length;
        for (int i = 0; i &lt; length-1; i++) {//思想, 要记得-1,因为j+1, 否则会越界
            for (int j = i+1; j &lt; length; j++){
                max = prices[j]-prices[i]&gt;max?prices[j]-prices[i]:max;
            }
        }
        return max;

    }
}
</code></pre>
<h5 id="复杂度-11"><a href="#复杂度-11" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N^2)超时了</li>
<li>空间: O(1)</li>
</ul>
<h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划*"></a>动态规划*</h4><h5 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h5><p>动态规划 前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</p>
<h5 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        int smallest = prices[0];
        for (int i = 0; i &lt; prices.length; i++) {
            max = Math.max(max, prices[i]-smallest);	//语法//思想
            if(prices[i] &lt; smallest) smallest = prices[i];
        }
        return max;

    }
}
</code></pre>
<h5 id="复杂度-12"><a href="#复杂度-12" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(1)</li>
</ul>
<h3 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566:重塑矩阵"></a>566:重塑矩阵</h3><p>在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。</p>
<p>给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。</p>
<p>重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。</p>
<p>如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>
<h4 id="新建数组循环赋值-self"><a href="#新建数组循环赋值-self" class="headerlink" title="新建数组循环赋值(self"></a>新建数组循环赋值(self</h4><h5 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h5><p>对于一个矩阵[m,n], i个元素在数组中对应的下标是[i/n, i%n];</p>
<h5 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[][] matrixReshape(int[][] mat, int r, int c) {
        int row = mat.length;						//语法
        int col = mat[0].length;					//语法
        if (row*col == r*c) {
            int [][]result = new int[r][c];			//语法
            for(int i = 0; i &lt; row*col; i++) {
                result[i/c][i%c] = mat[i/col][i%col];//语法//思想, 数组的下标和总长度的关系只有列有关
            }
            return result;
        }
        return mat;
    }
}
</code></pre>
<h5 id="复杂度-13"><a href="#复杂度-13" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(r*c)</li>
<li>空间: O(1)</li>
</ul>
<h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118:杨辉三角"></a>118:杨辉三角</h3><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行, 在杨辉三角中, 每个数是它左上方和右上方的数的和.</p>
<h4 id="模拟手算-self"><a href="#模拟手算-self" class="headerlink" title="模拟手算(self"></a>模拟手算(self</h4><h5 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h5><p>杨辉三角递推公式:<br>$$<br>result[row][j] =\left{<br>\begin{align}<br>1(第一行为1) &amp;&amp;{row=0,j=0}\<br>1(头尾为1) &amp;&amp;{row!=0,j=0 ||row!=0, j=row-1} \<br>result[row-1][j-1]+result[row-1][j] &amp; &amp; row&gt;0,j&gt;0 \<br>\end{align}<br>\right.<br>$$</p>
<h5 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; firstRow = new ArrayList&lt;&gt;();
        firstRow.add(1);
        result.add(firstRow);
        for(int numRow = 2; numRow &lt;= numRows; numRow++) {
            List&lt;Integer&gt; row = new ArrayList&lt;&gt;(numRow);
            result.add(row);
            for (int j = 0; j &lt; numRow; j++) {
                if (j==0||j==numRow-1) {
                    result.get(numRow-1).add(1);	//语法
                }
                else {
                    Integer num = result.get(numRow-2).get(j-1)+result.get(numRow-2).get(j);//思想, 递推公式
                    result.get(numRow-1).add(num);
                }
            }
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-14"><a href="#复杂度-14" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(N^2)$</li>
</ul>
<h3 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36:有效的数独"></a>36:有效的数独</h3><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<pre><code>数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
</code></pre>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>空白格用 <code>'.'</code> 表示。</li>
</ul>
<pre><code>输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
</code></pre>
<h4 id="Map存储是否出现-self"><a href="#Map存储是否出现-self" class="headerlink" title="Map存储是否出现(self"></a>Map存储是否出现(self</h4><h5 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h5><p>有9行个Map来存储每一行的出现,有9列个Map存储每一列的出现, 有3*3个Map存储对应第三条3*3个九宫格的出现.</p>
<p><strong>其实我用Map的原因是因为输入是Char, 其实可以将char转化为int, 然后就只需要用bool的二维数组就可以了,比如boolean[][] row=new boolean[9][9]记i行的数j是否已经摆放, i起list的作用, j起map的作用</strong></p>
<h5 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean isValidSudoku(char[][] board) {
        List&lt;Map&lt;Character, Boolean&gt;&gt; row = new ArrayList&lt;&gt;();	//语法, //思想, 其实用bool [][]
        List&lt;Map&lt;Character, Boolean&gt;&gt; col = new ArrayList&lt;&gt;();
        List&lt;List&lt;Map&lt;Character, Boolean&gt;&gt;&gt; nine_Square = new ArrayList&lt;&gt;();//语法//思想,
        for (int k = 0; k &lt; 9; k++) {
            row.add(new HashMap&lt;&gt;());   //语法, 注意可以省略Key和Value的类型自行推断.
            col.add(new HashMap&lt;&gt;());
        }
        for (int i = 0; i &lt; 3; i++) {
            List&lt;Map&lt;Character, Boolean&gt;&gt; temp = new ArrayList&lt;&gt;(3);
            for(int j = 0; j &lt; 3; j++){
                temp.add(new HashMap&lt;Character, Boolean&gt;());
            }
            nine_Square.add(temp);
        }
        int r = board.length;
        int c = board[0].length;
        for (int i = 0;i &lt; r; i++) {
            for (int j = 0; j &lt; c; j++) {
                if(board[i][j] == '.') continue;
                if(!row.get(i).containsKey(board[i][j])) row.get(i).put(board[i][j], true);
                else return false;

                if(!col.get(j).containsKey(board[i][j])) col.get(j).put(board[i][j], true);
                else return false;

                if(!nine_Square.get(i/3).get(j/3).containsKey(board[i][j])) nine_Square.get(i/3).get(j/3).put(board[i][j], true);
                else return false;
            }
        }
        return true;
    }
}
</code></pre>
<h5 id="复杂度-15"><a href="#复杂度-15" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(r*c)$</li>
<li>空间: $O(r*c)$</li>
</ul>
<h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73:矩阵置零"></a>73:矩阵置零</h3><p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法.</p>
<h4 id="用两个set记录0所对应的行数和列数-self"><a href="#用两个set记录0所对应的行数和列数-self" class="headerlink" title="用两个set记录0所对应的行数和列数(self"></a>用两个set记录0所对应的行数和列数(self</h4><h5 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h5><h5 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h5><pre><code>class Solution {
    public void setZeroes(int[][] matrix) {
        Set&lt;Integer&gt; row = new HashSet&lt;&gt;();	
        Set&lt;Integer&gt; col = new HashSet&lt;&gt;();
        
        for (int i = 0; i &lt; matrix.length; i++) {
            for (int j = 0; j &lt; matrix[0].length; j++) {
                if(matrix[i][j]==0) {
                    row.add(i);	//思想
                    col.add(j);	//思想
                }
            }
        }
        for(Integer r:row) {	//语法
            for(int j = 0; j &lt; matrix[0].length; j++) {
                matrix[r][j] = 0;
            }
        }
        for(Integer c:col) {
            for(int i = 0; i &lt; matrix.length; i++) {
                matrix[i][c] = 0;
            }
        }  
    }
}
</code></pre>
<h5 id="复杂度-16"><a href="#复杂度-16" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(M+N)$</li>
</ul>
<h4 id="使用两个标记变量"><a href="#使用两个标记变量" class="headerlink" title="使用两个标记变量"></a>使用两个标记变量</h4><h5 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h5><p>我们可以用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 O(1)O(1)O(1) 的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 000。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 000。</p>
<p>在实际代码中，我们首先预处理出两个标记变量，接着使用其他行与列去处理第一行与第一列，然后反过来使用第一行与第一列去更新其他行与列，最后使用两个标记变量更新第一行与第一列即可。</p>
<h5 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-17"><a href="#复杂度-17" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="使用BigSet类"><a href="#使用BigSet类" class="headerlink" title="使用BigSet类"></a>使用BigSet类</h4><h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387:字符串中的第一个唯一字符"></a>387:字符串中的第一个唯一字符</h3><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p><strong>示例：</strong></p>
<pre><code>s = "leetcode"
返回 0

s = "loveleetcode"
返回 2
</code></pre>
<h4 id="Hash存字符-出现次数-self"><a href="#Hash存字符-出现次数-self" class="headerlink" title="Hash存字符-出现次数(self"></a>Hash存字符-出现次数(self</h4><h5 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h5><p>Hash存字符-出现次数, 第一遍遍历获取, 第二遍遍历检验</p>
<h5 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h5><pre><code>class Solution {
    public int firstUniqChar(String s) {
        Map&lt;Character, Integer&gt; m = new HashMap&lt;&gt;();
        Integer min = Integer.MAX_VALUE;
        for(int i = 0; i &lt; s.length(); i++) {
            m.put(s.charAt(i), m.getOrDefault(s.charAt(i),0)+1);//语法,//思想
        }
        for(int i = 0; i &lt; s.length(); i++) {
            if(m.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        return -1;
    }
}
</code></pre>
<h5 id="复杂度-18"><a href="#复杂度-18" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(\sum)$ $\sum$是字符集的大小.</li>
</ul>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383:赎金信"></a>383:赎金信</h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p>
<p>如果可以，返回 true ；否则返回 false 。</p>
<p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：ransomNote = "a", magazine = "b"
输出：false
</code></pre>
<h4 id="两个Map存储出现次数-然后遍历比较-self"><a href="#两个Map存储出现次数-然后遍历比较-self" class="headerlink" title="两个Map存储出现次数, 然后遍历比较(self"></a>两个Map存储出现次数, 然后遍历比较(self</h4><h5 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        Map&lt;Character, Integer&gt; ransomNoteMap = new HashMap&lt;&gt;();
        Map&lt;Character, Integer&gt; magazineMap = new HashMap&lt;&gt;();

        for(int i = 0; i &lt; ransomNote.length(); i++) {
            ransomNoteMap.put(ransomNote.charAt(i), ransomNoteMap.getOrDefault(ransomNote.charAt(i),0)+1);
        }
        for(int i = 0; i &lt; magazine.length(); i++) {
            magazineMap.put(magazine.charAt(i), magazineMap.getOrDefault(magazine.charAt(i),0)+1);
        }
        for(int i = 0; i &lt; ransomNote.length(); i++) {
            if (!magazineMap.containsKey(ransomNote.charAt(i))) {//思想
                return false;
            }
            if (ransomNoteMap.get(ransomNote.charAt(i)) &gt; magazineMap.get(ransomNote.charAt(i))) {//思想
                return false;
            }
        }
        return true;
    }
}
</code></pre>
<h5 id="复杂度-19"><a href="#复杂度-19" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(max{N,M})$</li>
<li>空间: $O(N+M)$</li>
</ul>
<h4 id="数组统计-变体比较"><a href="#数组统计-变体比较" class="headerlink" title="数组统计+变体比较*"></a>数组统计+变体比较*</h4><h5 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h5><p>统计用<code>int[]</code>来做, 只不过下标由<code>map</code>转变了<code>int</code>, 利用了数组本身的特性.</p>
<p>将两个map和比较大小转化成了一个<code>array</code>和相减操作比大小.</p>
<h5 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        if (ransomNote.length() &gt; magazine.length()) {
            return false;
        }
        int[] cnt = new int[26];
        for (char c : magazine.toCharArray()) {	//语法
            cnt[c - 'a']++;	//思想
        }
        for (char c : ransomNote.toCharArray()) {
            cnt[c - 'a']--;	//思想
            if(cnt[c - 'a'] &lt; 0) {	//思想
                return false;
            }
        }
        return true;
    }
}
</code></pre>
<h5 id="复杂度-20"><a href="#复杂度-20" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: </li>
<li>空间:  $O(\sum)$ $\sum$是字符集的大小.</li>
</ul>
<h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: s = "anagram", t = "nagaram"
输出: true
</code></pre>
<h4 id="排序后比较"><a href="#排序后比较" class="headerlink" title="排序后比较*"></a>排序后比较*</h4><h5 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h5><p>异位词等价于排序后字符串相等</p>
<h5 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        char[] str1 = s.toCharArray();	//语法
        char[] str2 = t.toCharArray();
        Arrays.sort(str1);				//语法
        Arrays.sort(str2);
        return Arrays.equals(str1, str2);//思想
    }
}
</code></pre>
<h5 id="复杂度-21"><a href="#复杂度-21" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(nlogn)</li>
<li>空间: O(logn)</li>
</ul>
<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141:环形链表"></a>141:环形链表</h3><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<h4 id="快慢指针-self"><a href="#快慢指针-self" class="headerlink" title="快慢指针(self"></a>快慢指针(self</h4><h5 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode first = head;
        ListNode second = head;
        while(first!=null&amp;&amp;second!=null&amp;&amp;second.next!=null) {//重要
            first = first.next;
            second = second.next.next;
            if (first == second) {
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<h5 id="复杂度-22"><a href="#复杂度-22" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(1)</li>
</ul>
<h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表*"></a>哈希表*</h4><h5 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h5><p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>
<h5 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public class Solution {
    public boolean hasCycle(ListNode head) {
        Set&lt;ListNode&gt; seen = new HashSet&lt;ListNode&gt;();	//思想, 可以把ListNode也可以放集合
        while (head != null) {
            if (!seen.add(head)) {
                return true;
            }
            head = head.next;
        }
        return false;
    }
}
</code></pre>
<h5 id="复杂度-23"><a href="#复杂度-23" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(N)</li>
</ul>
<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21:合并两个有序链表"></a>21:合并两个有序链表</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<h4 id="假头指针-self"><a href="#假头指针-self" class="headerlink" title="假头指针(self"></a>假头指针(self</h4><h5 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h5><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<h5 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        ListNode point = new ListNode();//语法
        ListNode head = point;			//语法//思想
        while(list1!=null&amp;&amp;list2!=null) {
            if (list1.val &lt; list2.val) {
                point.next = list1;		//思想
                point = point.next;		//思想
                list1 = list1.next;		//思想
            }else {
                point.next = list2;
                point = point.next;
                list2 = list2.next;
            }
        }
        if (list1==null) {
            point.next = list2;
        }
        if (list2 ==null) {
            point.next = list1;
        }
        //语法,上面两句可以合并成point.next = list1==null?list2:list1;
        return head.next;
    }
}
</code></pre>
<h5 id="复杂度-24"><a href="#复杂度-24" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归*"></a>递归*</h4><h5 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h5><p>链表的定义否和递归, 所以常用递归来解决链表问题.</p>
<h5 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">/*
LeetCode官方代码, 好清晰啊
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        } else if (l1.val &lt; l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
*/
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode point = new ListNode();
        ListNode head = point;
        merge(head, list1, list2);
        return head.next;
        
    }
    private void merge(ListNode point, ListNode list1, ListNode list2) {
        if(list1 == null) {
            point.next = list2;
            return;
        }
        if(list2 == null) {
            point.next = list1;
            return;
        }
        if (list1.val &lt; list2.val) {
            point.next = list1;
            merge(point.next, list1.next, list2);
        }else{
            point.next = list2;
            merge(point.next, list1, list2.next);
        }
    }
}
</code></pre>
<h5 id="复杂度-25"><a href="#复杂度-25" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(N)</li>
</ul>
<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203:移除链表元素"></a>203:移除链表元素</h3><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<h4 id="递归-self"><a href="#递归-self" class="headerlink" title="递归(self"></a>递归(self</h4><h5 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h5><p>考虑返回值是什么, 什么时候停止,</p>
<h5 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">/*
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
    }
}
*/
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head==null) {
            return head;
        }
        if (head.val == val) {
            return removeElements(head.next, val);
        }else{
            head.next = removeElements(head.next, val);
            return head;
        }
    }
}
</code></pre>
<h5 id="复杂度-26"><a href="#复杂度-26" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(N)</li>
</ul>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206:反转链表"></a>206:反转链表</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<h4 id="假头-临时节点-self"><a href="#假头-临时节点-self" class="headerlink" title="假头+临时节点(self"></a>假头+临时节点(self</h4><h5 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h5><p>迭代,用假头节点和临时节点</p>
<h5 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode fake_head = new ListNode();
        ListNode temp;
        while(head!=null) {
            temp = fake_head.next;		//思想
            fake_head.next = head;		//思想
            head = head.next;			//思想,非常重要, 不能写在下一条语句的后面,前三句承上启下
            
            fake_head.next.next = temp;	//思想,temp是暂存的, 放在最后没有任何问题, 其他的都是复用
        }
        return fake_head.next;
    }
}
</code></pre>
<h5 id="复杂度-27"><a href="#复杂度-27" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(1)</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h5><p>用栈或者反转值.</p>
<h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h3><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素<strong>只出现一次</strong> 。</p>
<p>返回同样按升序排列的结果链表。</p>
<h4 id="双指针迭代-self"><a href="#双指针迭代-self" class="headerlink" title="双指针迭代(self"></a>双指针迭代(self</h4><h5 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode prev;						//其实用cur也可以
        ListNode follow;
        if(head==null) {
            return head;
        }
        prev = head;
        follow = head.next;
        while(follow!=null) {
            if (prev.val == follow.val) {	//思想
                prev.next = follow.next;	//删除相同元素
                follow = follow.next;		//相等只移动follow
            }else{
                follow = follow.next;		//不相等都移动
                prev = prev.next;
            }
        }
        return head;
    }
}
/*
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return head;
        }

        ListNode cur = head;				//思想, 其实不需要用follow指针
        while (cur.next != null) {
            if (cur.val == cur.next.val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }

        return head;
    }
}
*/
</code></pre>
<h5 id="复杂度-28"><a href="#复杂度-28" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: </li>
<li>空间:</li>
</ul>
<h4 id="递归-太妙了"><a href="#递归-太妙了" class="headerlink" title="递归*(太妙了"></a>递归*(太妙了</h4><h5 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h5><p>递归套路解决链表问题：</p>
<ol>
<li>找终止条件：当head指向链表只剩一个元素的时候，自然是不可能重复的，因此return</li>
<li>想想应该返回什么值：应该返回的自然是已经去重的链表的头节点</li>
<li>每一步要做什么：宏观上考虑，此时head.next已经指向一个去重的链表了，而根据第二步，我应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的head和head.next是否相等，如果相等则说明重了，返回head.next，否则返回head</li>
</ol>
<ul>
<li>如果独立写递归函数有困难的，可以参考一下我写的一个博客，附有详细的图文介绍：<a target="_blank" rel="noopener" href="https://lyl0724.github.io/2020/01/25/1/">博客链接</a></li>
</ul>
<h5 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        head.next = deleteDuplicates(head.next);		//思想,先让后面的不重复
        if(head.val == head.next.val) head = head.next;	//思想,解决现有头和后面的头相同的问题
        return head;
    }
}
/*
刚开始我也想的是递归, 但是有一点点问题, 就放弃了,问题出现在我是没有解决head和deleteDuplicates返回的节点如果相同的问题, 而原Po主解决了,就是先将后面的链表删除重复元素, 再来解决返回的链表的头和现有的头相同的问题, 另一个解决方法是我下面的注释中写的, 是在评论区找到的
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head==null||head.next==null) {
            return head;
        }
        if (head.val==head.next.val) {
            head.next = deleteDuplicates(head.next.next);	
            //这条语句有问题,当相等的时候应该是head = deleteDuplicates(head.next);
        }else{
            head.next = deleteDuplicates(head.next);
        }
        return head;
    }
}
*/
</code></pre>
<h5 id="复杂度-29"><a href="#复杂度-29" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: 分析不出来</li>
<li>空间: O(N)</li>
</ul>
<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h3><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = "()"
输出：true
</code></pre>
<h4 id="栈-self"><a href="#栈-self" class="headerlink" title="栈(self"></a>栈(self</h4><h5 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for(char c:s.toCharArray()) {
            if (c=='('||c=='['||c=='{') {
                stack.push(c);
            }else{
                if (stack.empty()) return false;	//思想,一定在每次取栈顶前都加这种判断
                char temp = stack.peek();

                if(c==')'&amp;&amp;temp=='(') stack.pop();
                else if(c==']'&amp;&amp;temp=='[') stack.pop();//思想, 要用else if
                else if(c=='}'&amp;&amp;temp=='{') stack.pop();
                else return false;
            }
        }
        if(stack.empty()) return true;
        return false;
    }
}
</code></pre>
<h5 id="复杂度-30"><a href="#复杂度-30" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(N)</li>
</ul>
<h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）</p>
<h4 id="模拟-self"><a href="#模拟-self" class="headerlink" title="模拟(self"></a>模拟(self</h4><h5 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h5><p>当取队头的时候, 将A栈送入B栈,然后取B栈头,取完后再入A栈, 读取队头也一样.</p>
<p>当入队的时候, 直接入A栈尾.</p>
<h5 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class MyQueue {
    private Stack&lt;Integer&gt; s1;      //语法, 在这里声明变量
    private Stack&lt;Integer&gt; s2;          
    public MyQueue() {
        s1 = new Stack&lt;&gt;();         //语法, 初始化
        s2 = new Stack&lt;&gt;();
    }
    public void push(int x) {
        s1.push(x);
    }
    public int pop() {
        if(s1.empty()) return -1;
        int result;
        while(!s1.empty()) {
            int temp = s1.pop();
            s2.push(temp);
        }
        result = s2.pop();
        while(!s2.empty()) {
            int temp = s2.pop();
            s1.push(temp);
        }
        return result;
    }
    public int peek() {
        int result;
        while(!s1.empty()) {
            int temp = s1.pop();
            s2.push(temp);
        }
        result = s2.peek();
        while(!s2.empty()) {
            int temp = s2.pop();
            s1.push(temp);
        }
        return result;
    }
    
    public boolean empty() {
        return s1.empty();
    }
}
</code></pre>
<h3 id="144-二叉树的前序-中序-94-后序-145-层次遍历"><a href="#144-二叉树的前序-中序-94-后序-145-层次遍历" class="headerlink" title="144. 二叉树的前序, 中序(94), 后序(145), 层次遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序, 中序(94), 后序(145), 层次遍历</a></h3><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<pre><code>输入：root = [1,null,2,3]
输出：[1,2,3]
</code></pre>
<h4 id="递归-self-1"><a href="#递归-self-1" class="headerlink" title="递归(self"></a>递归(self</h4><h5 id="前序思路"><a href="#前序思路" class="headerlink" title="前序思路"></a>前序思路</h5><p>因为要存储为LIst,使用一个帮助函数, 中, 后序改动少量代码即可.</p>
<h5 id="前序代码"><a href="#前序代码" class="headerlink" title="前序代码"></a>前序代码</h5><pre><code class="java">class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        preorderHelp(result, root);
        return result;
    }
    private void preorderHelp(List&lt;Integer&gt; l, TreeNode root) { 	//思想
        if (root==null) {
            return;
        }
        l.add(root.val);											//思想
        preorderHelp(l, root.left);
        preorderHelp(l, root.right);
    }
}
</code></pre>
<h5 id="前序复杂度"><a href="#前序复杂度" class="headerlink" title="前序复杂度"></a>前序复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(logN)$</li>
</ul>
<h4 id="模拟手动模板套路"><a href="#模拟手动模板套路" class="headerlink" title="模拟手动模板套路"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/tu-jie-er-cha-shu-de-si-chong-bian-li-by-z1m/">模拟手动模板套路</a></h4><h5 id="前序思路及代码"><a href="#前序思路及代码" class="headerlink" title="前序思路及代码"></a>前序思路及代码</h5><p>将手动求前序的过程进行模拟,</p>
<ul>
<li><p>当栈不为空或者当前指针不为空的时候:</p>
<ul>
<li><p>遍历左子树</p>
<ol>
<li><p>先访问cur</p>
</li>
<li><p>入栈cur(父节点)</p>
</li>
<li><p>然后cur指向它的左子树继续第一步</p>
</li>
</ol>
</li>
<li><p>出栈(得到父节点)</p>
</li>
<li><p>访问右子树</p>
</li>
</ul>
</li>
</ul>
<pre><code class="java">//记忆
class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if(root==null) return result;			//思想
        TreeNode cur = root;
        while(cur!=null || !s.empty()) {		//思想
            while(cur!=null) {					//思想, 遍历左子树
                result.add(cur.val);
                s.push(cur);
                cur = cur.left;
            }
            TreeNode peek = s.pop();			//取父节点
            cur = peek.right;					//思想, 指向右节点
        }
        return result;
    }
}
</code></pre>
<h5 id="中序思路及代码"><a href="#中序思路及代码" class="headerlink" title="中序思路及代码"></a><strong>中序思路及代码</strong></h5><p>在前序的基础上, 取栈顶元素(父节点)后访问父节点元素(而不是入栈前),在指向右孩子.</p>
<pre><code class="java">class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if(root==null) return result;
        TreeNode cur = root;
        while(cur!=null || !s.empty()) {
            while(cur!=null) {

                s.push(cur);
                cur = cur.left;
            }
            TreeNode peek = s.pop();
            result.add(peek.val);		//思想
            cur = peek.right;
        }
        return result;
    }
}
</code></pre>
<h5 id="后序思路及代码"><a href="#后序思路及代码" class="headerlink" title="后序思路及代码"></a><strong>后序思路及代码</strong></h5><p>相当于”先访问后孩子的前序”, 对结果再进行逆序</p>
<pre><code class="java">class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if(root==null) return result;
        TreeNode cur = root;
        while(cur!=null || !s.empty()) {
            while(cur!=null) {
                result.add(cur.val);
                s.push(cur);
                cur = cur.right;			//思想, 先访问右孩子的前序
            }
            TreeNode peek = s.pop();		
            cur = peek.left;				//思想, 后访问左孩子的前序
        }
        Collections.reverse(result);		//语法,//思想, 逆序
        return result;
    }
}
</code></pre>
<h4 id="用栈迭代"><a href="#用栈迭代" class="headerlink" title="用栈迭代"></a>用栈迭代</h4><p>下面的前序遍历代码相比于前一个更简洁一点, 也可以在这个基础上改后序, 但是需要添加标志位, 前序的话访问父节点的时候就直接访问元素, 再压栈右孩子, 左孩子(访问的话就左孩子, 右孩子了), 而后序的时候是第一次访问父节点的时候不访问元素, 而是在第二次访问父节点入栈右孩子和左孩子的时候再访问其元素.</p>
<h5 id="前序遍历思路及代码"><a href="#前序遍历思路及代码" class="headerlink" title="前序遍历思路及代码"></a>前序遍历思路及代码</h5><p>用栈来存放节点, 先入root, 然后如果栈不为空一直做一下事情:</p>
<ol>
<li>出栈,</li>
<li>临时节点为空则继续</li>
<li>否则访问(前序遍历)</li>
<li>然后将临时节点的右孩子入栈</li>
<li>然后将临时节点的左孩子入栈</li>
</ol>
<pre><code class="java">class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        s.push(root);
        while(!s.empty()){
            TreeNode temp = s.pop();			//语法
            if (temp==null) continue;
            result.add(temp.val);
            s.push(temp.right);
            s.push(temp.left);
        }
        return result;
    }
}
</code></pre>
<ul>
<li>时间: O(N)</li>
<li>空间: O(logN)</li>
</ul>
<h5 id="后序遍历思路及代码"><a href="#后序遍历思路及代码" class="headerlink" title="后序遍历思路及代码"></a>后序遍历思路及代码</h5><p>可以维护Pair的栈, 也可以维护一个标志位栈.</p>
<pre><code class="java">import java.util.AbstractMap; 
//https://blog.csdn.net/allway2/article/details/117630517 java pair代替的五种方案.
class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        Stack&lt;Map.Entry&lt;TreeNode,Boolean&gt;&gt; s = new Stack&lt;&gt;();
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        s.push(new AbstractMap.SimpleEntry&lt;&gt;(root, false));
        while(!s.empty()){
            TreeNode temp = s.peek().getKey();			//语法, 此时还不能出栈,
            Boolean flag = s.peek().getValue();
            s.pop();
            if (temp==null) continue;
            if (flag==true){							//第二次访问的时候才添加元素
                result.add(temp.val);
            }else{
                s.push(new AbstractMap.SimpleEntry&lt;&gt;(temp, true));
                s.push(new AbstractMap.SimpleEntry&lt;&gt;(temp.right, false));
                s.push(new AbstractMap.SimpleEntry&lt;&gt;(temp.left, false));
            }
        }
        return result;
    }
}

/*
不用pair的话
class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;();
        Stack&lt;Boolean&gt; s2 = new Stack&lt;&gt;();
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        s1.push(root);
        s2.push(false);
        while(!s1.empty()){
            TreeNode temp = s1.pop();			//语法
            boolean falg = s2.pop();
            if (temp==null) continue;
            if (falg==true){
                result.add(temp.val);
            }else{
                s1.push(temp);
                s2.push(true);
                s1.push(temp.right);
                s2.push(false);
                s1.push(temp.left);
                s2.push(false);
            }
        }
        return result;
    }
}
*/
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>先三种递归 =&gt; 模板(不要求递归的话) =&gt; 用栈迭代(后序不允许逆转).</p>
<h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<h4 id="奇淫巧计-用前序遍历实现-self"><a href="#奇淫巧计-用前序遍历实现-self" class="headerlink" title="奇淫巧计-用前序遍历实现(self"></a>奇淫巧计-用前序遍历实现(self</h4><h5 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h5><p>只考虑答案的话, 只需要每次访问元素将其入到对应层数的数组中即可.</p>
<h5 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        
        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();//语法, 不要写成new LinkedList&lt;LinkedList&lt;Integer&gt;&gt;()
        int height = getHeight(root);		//思想, 目的是为了得到需要多少个内层list
        for(int i = 0; i &lt; height; i++) {
            List&lt;Integer&gt; child_result= new LinkedList&lt;Integer&gt;();
            result.add(child_result);
        }
        preOrder(root, 0, result);			//思想, 前序遍历加入对应层数的list
        return result;
    }
    private int getHeight(TreeNode node) {
        if(node==null) return 0;
        return Math.max(getHeight(node.left),getHeight(node.right))+1;
    }
    private void preOrder(TreeNode node, int i, List&lt;List&lt;Integer&gt;&gt; result) {
        if (node==null) return;
        result.get(i).add(node.val);
        preOrder(node.left, i+1, result);
        preOrder(node.right, i+1, result);
    }
}
</code></pre>
<h5 id="复杂度-31"><a href="#复杂度-31" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(logN)</li>
</ul>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历*"></a>层次遍历*</h4><h5 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h5><p>每次进入队后先得到队的长度, 用这个数字来for循环访问每一层的元素,但是是入的同一个队.</p>
<h5 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
        queue.add(root);
        while(queue.size()!=0) {
            int queueSize = queue.size();
            LinkedList&lt;Integer&gt; levelResult = new LinkedList&lt;&gt;();
            for (int i = 0; i &lt; queueSize; i++) {
                TreeNode cur = queue.poll();
                if (cur!=null) {
                    levelResult.add(cur.val);
                    queue.add(cur.left);
                    queue.add(cur.right);
                }
            }
            result.add(levelResult);
        }
        result.remove(result.size()-1);			
        //因为根节点为空, 再加上不加左右孩子判断空的话, 会多一个末尾的空list, 也可以在进入while循环前判断根节点不为空, 在在里面判断左右孩子不为空再入队, 这样就不用加cur!=null了, 我的是将空节点也入队了
        return result;
    }
}
/*
class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        if (root == null) {						//思想, 判空
            return ret;
        }

        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;();
            int currentLevelSize = queue.size();
            for (int i = 1; i &lt;= currentLevelSize; ++i) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {		//思想, 不空的孩子才入
                    queue.offer(node.left);
                }
                if (node.right != null) {		//思想, 不空的孩子才入
                    queue.offer(node.right);
                }
            }
            ret.add(level);
        }
        
        return ret;
    }
}


作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/
</code></pre>
<h5 id="复杂度-32"><a href="#复杂度-32" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(N)</li>
</ul>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<h4 id="递归-self-2"><a href="#递归-self-2" class="headerlink" title="递归(self"></a>递归(self</h4><h5 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h5><p>深度 = Max(左孩子深度, 右孩子深度) +1;</p>
<p>返回条件 = if (note==null) return 0;</p>
<h5 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h5><pre><code>class Solution {
    public int maxDepth(TreeNode root) {
        if (root==null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
    }
}
</code></pre>
<h5 id="复杂度-33"><a href="#复杂度-33" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(logN)</li>
</ul>
<h4 id="一行代码"><a href="#一行代码" class="headerlink" title="一行代码"></a>一行代码</h4><h5 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h5><p>用了三元符</p>
<h5 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxDepth(TreeNode root) {
        return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
</code></pre>
<h5 id="复杂度-34"><a href="#复杂度-34" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(N)</li>
</ul>
<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<h4 id="遍历法-self-做不出来"><a href="#遍历法-self-做不出来" class="headerlink" title="遍历法(self, 做不出来"></a>遍历法(self, 做不出来</h4><h5 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h5><p>先访问左孩子的后序遍历和先访问右孩子的后序遍历.</p>
<p>有些样例跑不过去, 所以应该不是等价条件.</p>
<h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代*"></a>迭代*</h4><h5 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root==null) return true;
        else return isSymmetricHelp(root.left, root.right);
    }
    private boolean isSymmetricHelp(TreeNode left, TreeNode right) {
        if(left==null &amp;&amp;right==null) {
            return true;
        }else if(left==null &amp;&amp; right!=null) {		//思想, 重要的停止条件
            return false;
        }else if(left!=null&amp;&amp;right==null) {			//思想, 重要的停止条件
            return false;
        }
        return left.val==right.val&amp;&amp;isSymmetricHelp(left.left,right.right)&amp;&amp;(isSymmetricHelp(left.right, right.left));
    }
}
/*
class Solution {
    public boolean isSymmetric(TreeNode root) {		
        return check(root, root);					//用了这么一个判断条件.
    }

    public boolean check(TreeNode p, TreeNode q) {
        if (p == null &amp;&amp; q == null) {
            return true;
        }
        if (p == null || q == null) {				//语法, 这里简化了我上面的判断
            return false;
        }
        return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);
    }
}
*/
</code></pre>
<h5 id="复杂度-35"><a href="#复杂度-35" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(N)</li>
</ul>
<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<pre><code>     4
    /   \
  2     7
 / \   / \
1   3 6   9
</code></pre>
<p>输出：</p>
<pre><code>       4
     /   \
  7     2
 / \   / \
9   6 3   1
</code></pre>
<h4 id="递归-self-3"><a href="#递归-self-3" class="headerlink" title="递归(self"></a>递归(self</h4><h5 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h5><p>要注意原树左右孩子为空时, 将新树也赋值为空, 而不是新建节点, 官方的好简洁啊, 并且很清晰.</p>
<p>invertTree函数:</p>
<ul>
<li>功能: 反转一个树并返回新树.</li>
<li>结束条件: 如果原树为空返回空.</li>
<li>其他: 原树不为空, 反转原树的左子树为新树的右子树(孩子), 反转原树的右子树为新树的左子树(孩子).</li>
<li>返回新树根节点.</li>
</ul>
<h5 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">/*
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    }
}


作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/invert-binary-tree/solution/fan-zhuan-er-cha-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/

class Solution {
    public TreeNode invertTree(TreeNode root) {
        TreeNode result = new TreeNode();
        if (root==null) return root;
        setSymmetrix(root, result);
        return result;

    }
    private void setSymmetrix(TreeNode left, TreeNode right) {
        if (left==null) return;
        right.val = left.val;
        if (left.right==null) {
            right.left = null;			//思想
        }
        else  {
            right.left = new TreeNode();     
            setSymmetrix(left.right, right.left); //思想
        }
        if (left.left == null){
            right.right = null;			//思想
        }
        else{
            right.right = new TreeNode();
            setSymmetrix(left.left, right.right); //思想
        }        
    }
}
</code></pre>
<h5 id="复杂度-36"><a href="#复杂度-36" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(N)</li>
</ul>
<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<h4 id="改变原树使得节点的值为路径和-self"><a href="#改变原树使得节点的值为路径和-self" class="headerlink" title="改变原树使得节点的值为路径和(self"></a>改变原树使得节点的值为路径和(self</h4><h5 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h5><p>先用改造的前序遍历使得节点的值为路径和.</p>
<p>然后再用前序遍历检查叶子节点的值是否为targetSum.</p>
<p>一开始想的时复制一条树, 使得树的节点既存储原节点的值, 也存储路径和, 但是发现需要修改<code>TreeNode</code>本身的结构, 所以再想着直接复制一条树, 但是这棵新树的节点值都是路径之和, 但是发现其实直接在原树上修改即可.</p>
<p>甚至可以不需要二次遍历, 在第一次构造的时候, 加判断叶子节点的话判断targetSum和已经构造出来的值是否相等, 相等的话就<a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/c45ad29cf51378051753e200.html">直接退出递归</a>(这时候递归条件需要增加一个全局变量, 当满足条件时候改变全局变量之后一层一层直接退出递归).</p>
<h5 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        boolean []result = new boolean[1];		//语法, 因为直接传单个的boolean是值传递.
        preOrderSum(root);						//先修改树的节点为路径之和.
        preOrder(root, targetSum, result);		//前序遍历检查叶子节点的值是否等于targetSum
        return result[0];
    }
    private void preOrderSum(TreeNode root) {
        if(root==null) {
            return;
        }
        if (root.left!=null) {
            root.left.val += root.val;
        }
        if (root.right!=null) {
            root.right.val+=root.val;
        }
        preOrderSum(root.left);
        preOrderSum(root.right);
    }
    private void preOrder(TreeNode root, int targetSum, boolean[] result) {
        if(root==null) {
            return;
        }
        if (root.left==null&amp;&amp;root.right==null&amp;&amp;root.val == targetSum) result[0] = true;//前面的条件是为了判断叶子节点
        preOrder(root.left, targetSum, result);
        preOrder(root.right, targetSum, result);
    }
}
/*复制一棵树, 我发现在复制一棵树的同时再修改节点的值需要多传递一个父节点的参数, 不能直接修改
    private TreeNode copyTree(TreeNode root) {
        if (root==null) return null;
        else {
            TreeNode result = new TreeNode(root.val);
            result.left = copyTree(root.left);
            result.right = copyTree(root.right);
            return result;
        }
    }
*/
</code></pre>
<h5 id="复杂度-37"><a href="#复杂度-37" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(H)</li>
</ul>
<h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归*"></a>递归*</h4><h5 id="思路-41"><a href="#思路-41" class="headerlink" title="思路"></a>思路</h5><p>观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。</p>
<p>假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p>
<p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</p>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/">https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h5 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null &amp;&amp; root.right == null) {
            return sum == root.val;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);		//思想,//记忆,太妙了
    }
}
</code></pre>
<h5 id="复杂度-38"><a href="#复杂度-38" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(H)</li>
</ul>
<h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h3><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<h4 id="递归-self-4"><a href="#递归-self-4" class="headerlink" title="递归(self"></a>递归(self</h4><h5 id="思路-42"><a href="#思路-42" class="headerlink" title="思路"></a>思路</h5><p>二分查找和遍历结构类似, 但是思想是极为不同的, 遍历因为要走所有一遍, 所以没有返回值. 而二分查找是找到了就不用往下找了, 所以在找到正确答案的时候直接返回即可.</p>
<h5 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">//记忆
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root==null) return null;		//思想, 不要想太多, 这条语句只考虑空树的结果即可.
        if (root.val==val) return root;		//思想, 注意返回值
        else if (root.val &lt; val) return searchBST(root.right, val);	//思想, 二分查找.
        else return searchBST(root.left, val);
    }
}
</code></pre>
<h5 id="复杂度-39"><a href="#复杂度-39" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(H)</li>
<li>空间: O(H)</li>
</ul>
<h4 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代*"></a>迭代*</h4><h5 id="思路-43"><a href="#思路-43" class="headerlink" title="思路"></a>思路</h5><p>迭代的思想太优美了, 当节点不为空(放在第一个条件)并且节点的值不等于目标值的时候, 根据二分查找将子树赋值给该节点继续判断.</p>
<h5 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">//记忆
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while(root!=null&amp;&amp;root.val!=val){				//思想,妙啊
            root = root.val&lt;val?root.right:root.left;
        }
        return root;
    }
}
</code></pre>
<h5 id="复杂度-40"><a href="#复杂度-40" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(H)</li>
<li>空间: O(1)</li>
</ul>
<h4 id="错误反思"><a href="#错误反思" class="headerlink" title="错误反思*"></a>错误反思*</h4><h5 id="思路-44"><a href="#思路-44" class="headerlink" title="思路"></a>思路</h5><p>用递归, 但是不是返回正确答案, 而是用返回参数,错在以下几个地方</p>
<ul>
<li>空树的返回TreeNode(0)(不是重点)</li>
<li><code>result = root;</code>这条语句不能改变在<code>searchBST(TreeNode root, int val)</code>中创建的result变量, 因为java中是值传递, 在<code>preOrder</code>中, 形参<code>result</code>是<code>实参result</code>的拷贝, 指向了root是拷贝的形参指向了root, 而不是实参result指向了result, 如果要这样使用, 那么必须改变<code>TreeNode</code>的结构, 增加一个<code>setVal(val){this.val=val}</code>方法, 然后调用该方法, 而不是赋值.</li>
</ul>
<h5 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        TreeNode result = new TreeNode();
        preOder(root, val, result);
        return result;
    }
    private void preOrder(TreeNode root, int val, TreeNode result) {
        if (root==null) return;
        if (root.val == val) {
            result = root;		//错误, 这样不能改变实参的指向, 必须要用result.setVal(val)才可以
        }else{
            preOrder(root.left, val, result);
            preOrder(root.right, val, result);
        }   
    }
}
</code></pre>
<h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h3><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<h4 id="迭代-self"><a href="#迭代-self" class="headerlink" title="迭代(self"></a>迭代(self</h4><h5 id="思路-45"><a href="#思路-45" class="headerlink" title="思路"></a>思路</h5><p>要注意还得保存父节点, 另外要初始就判断是否为空, 因为根节点为空的话和后面的迭代操作不一样(直接赋值而不是将孩子赋值给父亲).</p>
<h5 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root==null) {
            return new TreeNode(val);					//思想
        }
        TreeNode node = root;
        TreeNode father = root;
        while(node!=null) {
            father = node;								//思想, 注意保存父节点
            node = node.val&lt;val?node.right:node.left;
        }
        node = new TreeNode(val);
        if (father.val &gt; node.val) father.left = node;	//思想, 父节点大于子节点时, 左孩子为节点
        else father.right = node;
        return root; 
    }
}
</code></pre>
<h5 id="复杂度-41"><a href="#复杂度-41" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(H)</li>
<li>空间: O(1)</li>
</ul>
<h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归*"></a>递归*</h4><h5 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        //函数功能, 给以root节点为根节点的树插入val并返回插入后的新树
        if (root==null) {
            return new TreeNode(val);
        }
        if (root.val &lt; val) {
            root.right = insertIntoBST(root.right, val);	//思想
        }else{
            root.left = insertIntoBST(root.left, val);
        }
        return root; 
    }
}
</code></pre>
<h5 id="复杂度-42"><a href="#复杂度-42" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(H)</li>
<li>空间: O(H)</li>
</ul>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<pre><code>节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树
</code></pre>
<h4 id="错误的递归思想-self"><a href="#错误的递归思想-self" class="headerlink" title="错误的递归思想(self"></a>错误的递归思想(self</h4><h5 id="思路-46"><a href="#思路-46" class="headerlink" title="思路"></a>思路</h5><ul>
<li>函数返回检验这颗树是否是二叉搜索树</li>
<li>如果根节点为空返回真</li>
<li>其他情况<ul>
<li>如果左子树为空或者不为空的时候左子树小于根节点并且左子树为二叉搜索树标记为真.</li>
<li>如果右子树为空或者不为空的时候右子树大于根节点并且右子树为二叉搜索树标记为真.</li>
<li>当上面两者都为真时返回真</li>
</ul>
</li>
</ul>
<p>错误之处在于:</p>
<p>“二叉搜索树”的左节点小于根节点&amp;&amp;右节点大于根节点&amp;&amp;左右两棵子树都是”二叉搜素树”是 二叉搜素树 的<strong>必要条件</strong>而非<strong>充分条件</strong>. 也就是不等价, 例如</p>
<pre><code>    5
  4   6
 N N 3 7
</code></pre>
<p>上面的递归判断不能保证3也大于5.</p>
<h5 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean isValidBST(TreeNode root) {
        boolean is_left = true;
        boolean is_right = true;
        if(root==null) return true;
        if (root.left!=null){
            is_left = root.left.val&lt;root.val&amp;&amp;isValidBST(root.left);
        }
        if(root.right!=null) {
            is_right = root.right.val&gt;root.val&amp;&amp;isValidBST(root.right);
        }
        return is_left&amp;&amp;is_right;
    }
}
</code></pre>
<h5 id="复杂度-43"><a href="#复杂度-43" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: </li>
<li>空间:</li>
</ul>
<h4 id="正确的递归"><a href="#正确的递归" class="headerlink" title="正确的递归*"></a>正确的递归*</h4><h5 id="思路-47"><a href="#思路-47" class="headerlink" title="思路"></a>思路</h5><p>传入该节点的最大值和最小值</p>
<h5 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBSTHelp(root, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY); //语法, 要注意无穷大常量全都是大写字母, 不能用Integer的无穷大, 因为会卡边界值
    }
    boolean isValidBSTHelp(TreeNode node, double max, double min) {
        if (node==null) return true;
        return node.val&lt;max&amp;&amp;node.val&gt;min&amp;&amp;isValidBSTHelp(node.left, node.val, min)&amp;&amp;isValidBSTHelp(node.right, max, node.val);//思想
    }
}
</code></pre>
<h5 id="复杂度-44"><a href="#复杂度-44" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(H)</li>
</ul>
<h4 id="中序遍历的结果为递增"><a href="#中序遍历的结果为递增" class="headerlink" title="中序遍历的结果为递增*"></a>中序遍历的结果为递增*</h4><h5 id="思路-48"><a href="#思路-48" class="headerlink" title="思路"></a>思路</h5><p>中序遍历存储进数组, 必然为递增序列, 此时用Integer足以</p>
<h5 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean isValidBST(TreeNode root) {
        List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;();
        midOrder(root, l);
        boolean flag = true;
        for(int i = 0; i &lt; l.size()-1; i++){
            if(l.get(i) &gt;= l.get(i+1)) {
                flag = false;
                return flag;
            }
        }
        return flag;
    }
    void midOrder(TreeNode root, List&lt;Integer&gt; l) {
        if(root==null) return;
        midOrder(root.left, l);
        l.add(root.val);
        midOrder(root.right, l);
    }
}
</code></pre>
<h5 id="复杂度-45"><a href="#复杂度-45" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(H)(迭代中序的话可以为O(1))</li>
</ul>
<h3 id="653-两数之和-IV-输入-BST"><a href="#653-两数之和-IV-输入-BST" class="headerlink" title="653. 两数之和 IV - 输入 BST"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></h3><p>给定一个二叉搜索树 <code>root</code> 和一个目标结果 <code>k</code>，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 <code>true</code>。</p>
<h4 id="层次遍历进集合-进之前先判断-self"><a href="#层次遍历进集合-进之前先判断-self" class="headerlink" title="层次遍历进集合,进之前先判断(self"></a>层次遍历进集合,进之前先判断(self</h4><h5 id="思路-49"><a href="#思路-49" class="headerlink" title="思路"></a>思路</h5><p>层次遍历(队列方式)元素进集合,进之前先判断集合前有没有<code>target-该元素</code>, 有的话则找到(可以一般情况和分辨taregt-该元素=该元素值), 没有话则入set, 这个技巧我觉得挺好的.</p>
<p>另外遍历前中后序都可以, 核心思想是在加入set前判断是否存在<code>target-val</code></p>
<h5 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean findTarget(TreeNode root, int k) {
        boolean result = false;
        Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
        Set&lt;Integer&gt; s = new HashSet();
        TreeNode cur = root;
        q.offer(root);
        while(q.size()!=0) {
            int size = q.size();
            for(int i = 0; i &lt; size; i++) {
                cur = q.poll();
                if (cur==null) continue;		//思想,左右孩子前一定要判断cur是否为空
                q.offer(cur.left);
                q.offer(cur.right);
                if(s.contains(k-cur.val)){		//思想(核心), trick
                    result = true;
                    return result;				
                }
                s.add(cur.val);
            }
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-46"><a href="#复杂度-46" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(N)</li>
<li>空间: O(N)</li>
</ul>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针*"></a>双指针*</h4><h5 id="思路-50"><a href="#思路-50" class="headerlink" title="思路"></a>思路</h5><blockquote>
<p>方法二：叉搜索树的中序遍历为递增序列，所以我们可以利用这个升序的序列寻找k。 使用双指针，分别指向头、尾。如果两数之和大于target，尾指针前移，如果两数之和小于target，首指针后移。</p>
<p>leetcode题目评论</p>
</blockquote>
<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<h4 id="递归-self-5"><a href="#递归-self-5" class="headerlink" title="递归(self"></a>递归(self</h4><h5 id="思路-51"><a href="#思路-51" class="headerlink" title="思路"></a>思路</h5><p>明确以下事情:</p>
<ul>
<li>函数是干什么的: 传递根节点<code>root</code>, 需要搜寻的节点<code>p</code>,<code>q</code>, 返回在以根节点<code>root</code>为树的最近公共祖先</li>
<li>最简单返回条件: 如果root为空的话直接返回root</li>
<li>其他情况下<ul>
<li>如果p和q的值都比root的大的话, 那调用该方法, 在root.right上继续寻找</li>
<li>其他如果p和q的值都比root的小的话, 那调用该方法, 在root.left上继续寻找.</li>
<li>其他情况下(p的值有一个与root相等或者其中有一个比root大并且另一个比root小的话)都返回root</li>
</ul>
</li>
</ul>
<p>可以看到, 其实, 我们做一道题就是在找问题的能用数据结构表示的等价说明(一句有用的废话)</p>
<h5 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return null;
        if(p.val&gt;root.val&amp;&amp;q.val&gt;root.val) {
            return lowestCommonAncestor(root.right, p, q);
        }else if(p.val&lt;root.val&amp;&amp;q.val&lt;root.val) {
            return lowestCommonAncestor(root.left, p, q);
        }else {
            return root;
        }
    }
}
</code></pre>
<h5 id="复杂度-47"><a href="#复杂度-47" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: O(H)</li>
<li>空间: O(H)</li>
</ul>
<h4 id="思想2名称-1"><a href="#思想2名称-1" class="headerlink" title="思想2名称*"></a>思想2名称*</h4><h5 id="思路-52"><a href="#思路-52" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-48"><a href="#复杂度-48" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: </li>
<li>空间:</li>
</ul>
<h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h3><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p>
<pre><code>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
</code></pre>
<h4 id="拓扑排序-self"><a href="#拓扑排序-self" class="headerlink" title="拓扑排序(self"></a>拓扑排序(self</h4><h5 id="思路-53"><a href="#思路-53" class="headerlink" title="思路"></a>思路</h5><p>拓扑排序算法:</p>
<ul>
<li>计算所有节点的入度, 将入度为0的节点加入队列</li>
<li>遍历队列, 将队列的节点出队列并且将出的节点所指向的节点的入度减1,</li>
<li>入度为0的队列遍历完之后, 还存在入度不为0的节点, 则说明存在环.</li>
</ul>
<h5 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        Queue&lt;Integer&gt; s = new LinkedList&lt;Integer&gt;();
        List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;();
        int[] inDegree = new int[numCourses];
        //初始图
        for(int i = 0; i &lt; numCourses; i++) {
            List&lt;Integer&gt; graph_item = new ArrayList&lt;&gt;();
            graph.add(graph_item);
        }
        //计算入度和建图
        for(int i = 0; i &lt; prerequisites.length; i++) {
            inDegree[prerequisites[i][1]]+=1;
            graph.get(prerequisites[i][0]).add(prerequisites[i][1]);
        }
        //将入度为0的节点加入队列
        for(int i = 0; i &lt; numCourses; i++) {
            if(inDegree[i] == 0) s.add(i);
        }
        
        while(s.size() != 0) {
            int head = s.remove();
            for(int i = 0; i &lt; graph.get(head).size(); i++) {
                inDegree[graph.get(head).get(i)]--;
                if(inDegree[graph.get(head).get(i)]==0) {
                    s.add(graph.get(head).get(i));
                }
            }
        }
        //如果删除入度后还有入度不为0, 也就时存在环
        for(int i = 0; i &lt; numCourses; i++) {
            if (inDegree[i] != 0) return false;
        }
        return true;
    }
}
</code></pre>
<h5 id="复杂度-49"><a href="#复杂度-49" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(n+e)$</li>
<li>空间: $O(n)$</li>
</ul>
<h2 id="LeetCode热题Hot100"><a href="#LeetCode热题Hot100" class="headerlink" title="LeetCode热题Hot100"></a>LeetCode热题Hot100</h2><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h4 id="模拟人工加法-self"><a href="#模拟人工加法-self" class="headerlink" title="模拟人工加法(self"></a>模拟人工加法(self</h4><h5 id="思路-54"><a href="#思路-54" class="headerlink" title="思路"></a>思路</h5><p>这道题其实就是链表逆向存储了十进制数, 也就是头存储的是<strong>个位</strong>, 模拟人工进行加法. 算法实际实现有点归并的思想.但是没有结合成统一的代码, 如果想结合成统一的代码. 就是在节点为空时, 相当于此节点的值为0即可.</p>
<h5 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = new ListNode();
        ListNode cur = head;
        int carry = 0;
        int num = 0;
        while(l1!=null&amp;&amp;l2!=null){
            num = (l1.val+l2.val+carry)%10;         //思想, 先计算num, 两数之和加进位再对10取余
            carry = (l1.val+l2.val+carry)&gt;=10?1:0;  //思想, 如果这次相加大于等于10的话下一个进位是1否则为0
            ListNode node = new ListNode(num);
            cur.next = node;
            cur = cur.next;                         //思想, 下面移动
            l1 = l1.next;
            l2 = l2.next;
        }
        while(l1!=null){
            num = (l1.val+carry)%10;
            carry = (l1.val+carry)&gt;=10?1:0;
            ListNode node = new ListNode(num);
            cur.next = node;
            cur = cur.next;
            l1 = l1.next;
        }
        while(l2!=null){
            num = (l2.val+carry)%10;
            carry = (l2.val+carry)&gt;=10?1:0;
            ListNode node = new ListNode(num);
            cur.next = node;
            cur = cur.next;
            l2 = l2.next;
        }
        if (carry==1) {                             //思想, 如果最后一位还有进位的话需要构造
            ListNode node = new ListNode(carry);
            cur.next = node;
        }
        return head.next;
    }
}
</code></pre>
<h5 id="复杂度-50"><a href="#复杂度-50" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(max{M,N})$</li>
<li>空间: $O(max{M,N})$, 其实可以为O(1), 也就是直接在原节点修改.</li>
</ul>
<h4 id="迭代-self-1"><a href="#迭代-self-1" class="headerlink" title="迭代(self"></a>迭代(self</h4><h5 id="思路-55"><a href="#思路-55" class="headerlink" title="思路"></a>思路</h5><p>确定以下:</p>
<ul>
<li>函数干什么: 返回两个数字十进制相加后的新的节点</li>
<li>传递参数: 两个数字以及上次的进位, 第一次进位为0</li>
<li>终止条件:<ul>
<li>两个数字都为空</li>
<li>其中一个数字为空</li>
<li>两个数字都不为空</li>
</ul>
</li>
</ul>
<h5 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        return addTwoNumbersHelp(l1, l2, 0);
    }
    private ListNode addTwoNumbersHelp(ListNode l1, ListNode l2, int carry){
        if (l1==null &amp;&amp; l2==null) {
            if(carry==1) return new ListNode(1);
            return null;
        }
        else if(l1==null&amp;&amp;l2!=null) {
            int num = (l2.val+carry)%10;
            carry = l2.val+carry&gt;=10?1:0;
            l2.val = num;
            l2.next = addTwoNumbersHelp(l1, l2.next, carry);
            return l2;
        }else if(l1!=null&amp;&amp;l2==null) {
            int num = (l1.val+carry)%10;
            carry = l1.val+carry&gt;=10?1:0;
            l1.val = num;
            l1.next = addTwoNumbersHelp(l1.next, l2, carry);
            return l1;
        }else{
            int num = (l1.val+l2.val+carry)%10;
            carry = (l1.val+l2.val+carry)&gt;=10?1:0;
            l1.val = num;
            l1.next = addTwoNumbersHelp(l1.next, l2.next, carry);
            return l1;
        }
    }
}
</code></pre>
<h5 id="复杂度-51"><a href="#复杂度-51" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(max{N,M})$(N和M为两个节点存储十进制数的位数的长度)</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<pre><code class="java">示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
</code></pre>
<h4 id="动态规划-self-想错方向"><a href="#动态规划-self-想错方向" class="headerlink" title="动态规划(self, 想错方向"></a>动态规划(self, 想错方向</h4><h5 id="思路-56"><a href="#思路-56" class="headerlink" title="思路"></a>思路</h5><p>本来我的思路是用动态规划的思路, 源自于<code>53题最大子序和</code>, 也就是令<br>$$<br>f(i)表示以第i个字母结尾的字符串的长度 \<br>f(i) = f(i-1)+1 \ \ \ \ \ \ 当i和i-1的字母不相同时 \<br>max = Math.max(f(1), f(2), …,f(n))<br>$$<br>但是我发现这样很难计算当$i$个字母在之前出现过的时候,所以会出现各种问题.</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口*"></a>滑动窗口*</h4><h5 id="思路-57"><a href="#思路-57" class="headerlink" title="思路"></a>思路</h5><p>两个指针, 一个指针指向窗口的左端, 表示第i个字母时, 不含重复字符子串的左端, 一个指针为i, 表示滑动窗口的右端.</p>
<p>i从0开始, 一次加1,</p>
<p>left默认为0, 当第i个字母没出现时不变, 出现时, 指向这个出现字母最后一次出现的位置+1和left之中最大的那个.</p>
<h5 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map&lt;Character, Integer&gt; m = new HashMap&lt;&gt;();
        int max = 0;
        int left = 0;
        for(int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            if (m.containsKey(c)) {
                left = Math.max(m.get(c)+1, left);  //思想
            }
            m.put(c,i);                             //思想
            max = Math.max(max, i-left+1);
        }
        return max;
    }
}
</code></pre>
<h5 id="复杂度-52"><a href="#复杂度-52" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) 。</p>
<pre><code class="java">示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
</code></pre>
<h4 id="思想1名称-self-1"><a href="#思想1名称-self-1" class="headerlink" title="思想1名称(self"></a>思想1名称(self</h4><h5 id="思路-58"><a href="#思路-58" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h5><pre><code>\\语法, 以后搜索\\语法可以学习语法
\\思想, 学习思想
</code></pre>
<h5 id="复杂度-53"><a href="#复杂度-53" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="合并排序取中位数"><a href="#合并排序取中位数" class="headerlink" title="合并排序取中位数*"></a>合并排序取中位数*</h4><h5 id="思路-59"><a href="#思路-59" class="headerlink" title="思路"></a>思路</h5><p>合并两个数组然后取中位数</p>
<p>但是这个的时间是借sort算法快排的$O(log(M+N))$来实现的, 而不是真正自己实现了所需要的算法复杂度.</p>
<h5 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n1 = nums1.length;
        int n2 = nums2.length;
        int[] nums = new int[n1 + n2];
        System.arraycopy(nums1, 0, nums, 0, n1);		//语法
        System.arraycopy(nums2, 0, nums, n1, n2);		//语法
        Arrays.sort(nums);								//语法
        int n = nums.length;
        if (n % 2 == 0) {
            return (nums[(n/2)-1] + nums[n/2])/2.0;
        } else {
            return nums[n/2];
        }
    }
}
</code></pre>
<h5 id="复杂度-54"><a href="#复杂度-54" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<pre><code>示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

示例 2：

输入：s = "cbbd"
输出："bb"
</code></pre>
<h4 id="对折比较相等-self"><a href="#对折比较相等-self" class="headerlink" title="对折比较相等(self"></a>对折比较相等(self</h4><h5 id="思路-60"><a href="#思路-60" class="headerlink" title="思路"></a>思路</h5><p>移动一个指针, 再让这个指针往左走和往右走如果一直想等的话就是回文串, 记录最大长度和这个指针的位置, 要注意, 分为奇对称和偶对称</p>
<ul>
<li>奇对称: abacd, 这个aba以b为对称轴</li>
<li>偶对称: abbac, abba以”空”为对称轴</li>
</ul>
<h5 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public String longestPalindrome(String s) {
        char []str = s.toCharArray();
        int max_length = 1;			//记录整个回文串的最大长度
        int flag = 1;               //记录是哪种情况, 1是奇对称(aba), 0是偶对称(aa)
        int index = 0;				//如果是奇对称, 记录对称轴的位置, 如果是偶对称, 记录空的下一个字符的位置, 这里记录后面那个字符的话就要使得`length&gt;=max_length`
        String result = s.substring(0,1);
        for(int i =1; i &lt; str.length; i++) {
            //奇对称
            int length = 1;				//奇对称初始长度为1
            for(int j = i-1, k = i+1; j &gt;=0&amp;&amp;k&lt;str.length;j--,k++){
                if(str[j]==str[k]) {
                    length+=2;
                    if(length&gt;=max_length) {
                        index = i;
                        flag = 1;
                        max_length = length;
                    }
                }else{
                    break;
                }
            }
            //偶对称
            length = 0;					//偶对成初始长度为0
            for(int j = i-1,k = i; j &gt;=0 &amp;&amp; k &lt; str.length; j--, k++) {
                if(str[j]==str[k]) {
                    length+=2;
                    if(length&gt;=max_length) {
                        index = i;
                        flag = 0;
                        max_length = length;
                    }
                }else{
                    break;
                }
            }
        }
        if (flag == 0) {
            //abbacd的话, index就是第二个b, max_length是4
            result = s.substring(index-max_length/2,index+max_length/2);
        }else{
            //abcbad, index是c, max_length是5.
            result = s.substring(index-max_length/2, index+max_length/2+1);
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-55"><a href="#复杂度-55" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(N)$, 浪费这么多空间主要是为了直接用[]取字符, 使用s.charAt也可以做到$O(1)$.</li>
</ul>
<h3 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<pre><code>'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
</code></pre>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串</p>
<pre><code>示例 1：

输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。

示例 2:

输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3：

输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4：

输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

示例 5：

输入：s = "mississippi" p = "mis*is*p*."
输出：false
</code></pre>
<h4 id="递归-self-只过了一半样例-没做出来"><a href="#递归-self-只过了一半样例-没做出来" class="headerlink" title="递归(self, 只过了一半样例, 没做出来"></a>递归(self, 只过了一半样例, 没做出来</h4><h5 id="思路-61"><a href="#思路-61" class="headerlink" title="思路"></a>思路</h5><p>慢慢的确定终止条件再到一半情况</p>
<h5 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean isMatch(String s, String p) {
        if (s.length()==0&amp;&amp;p.length()==0) {
            return true;
        }else if(s.length()==0&amp;&amp;p.length()==1){          //s是空串, p不为空的情况          
            return false;
        }else if(s.length()==0&amp;&amp;p.length()&gt;1){
            char c1 = p.charAt(0);
            char c2 = p.charAt(1);
            if (c2=='*') {                      //如果是"p*"或者".*"这种情况
                return isMatch(s, p.substring(2,p.length()));
            }else{                              //如果是"a"这种情况
                return false;
            }
        }else if(s.length() &gt; 0 &amp;&amp; p.length() ==0) {      //s不是空串,但是p是空串
            return false;
        }else if(s.length() &gt;0 &amp;&amp; p.length() ==1) {
            char c = s.charAt(0);
            char c1 = p.charAt(0);
            if ((c==c1||c1=='.')&amp;&amp;s.length()==1) return true;
            else return false;
        }else{
            char c = s.charAt(0);
            char c1 = p.charAt(0);
            char c2 = p.charAt(1);
            if(c==c1||c1=='.') {
                if(c2=='*'){
                    return isMatch(s.substring(1,s.length()), p);
                }else{
                    return isMatch(s.substring(1,s.length()), p.substring(1,p.length()));
                }
            }else{
                if(c2=='*'){
                    return isMatch(s, p.substring(2,p.length()));
                }else{
                    return false;
                }
            }
        }
    }
}
</code></pre>
<h5 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因:"></a>错误原因:</h5><p>通过测试用例：298 / 353</p>
<pre><code>输入：
"aaa"
"a*a"
</code></pre>
<pre><code>输出：
false
</code></pre>
<pre><code>预期结果：
true
</code></pre>
<p>我只是从前匹配, 但是a*到底要匹配多少次这是从前匹配做不到的.</p>
<h4 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划*"></a>动态规划*</h4><h5 id="思路-62"><a href="#思路-62" class="headerlink" title="思路"></a>思路</h5><p>还没学习呢</p>
<h5 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-56"><a href="#复杂度-56" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<p><img src="D:\pic-bed\img\image-20220123100131768.png" alt="image-20220123100131768"></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><h5 id="思路-63"><a href="#思路-63" class="headerlink" title="思路"></a>思路</h5><p>这题一看数据量, $10^5$表明$n^2$的暴力群举就会超时, 所以要想其他办法, 先写出动态规划方程:<br>$$<br>max_area = max( min(height[i],height[j])*(j-i))<br>$$<br>问题就出现在宽和高上, 宽虽然一次移动1个单位, 但是面积的增加与否还要看移动后的高是否会减小, 我的想法就这么中断了, 因为我不知道如何判断移动后的高是不是正确的高, 但其实不用管是不是正确的高, 我们只需要记录最大的面积就好了, 尽管它不是正确的高, 只要我们遍历所有情况, 记录最大的面积就可以了.</p>
<p>接下来就写循环, 如果都从一端开始, 一个是循环终止不好写, 另一个是i和j都从一端开始的话必然$N^2$, 所以技巧就在于用双指针刚开始指向首尾, 然后移动这两个指针中的一个, 移动哪一个呢?<strong>移动那个高比较短的那个的下标</strong>.</p>
<h5 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxArea(int[] height) {
        int area = 0;
        int i = 0;
        int j = height.length-1;					//思想, 双指针指向首尾
        area = Math.min(height[i],height[j])*(j-i);
        while(i!=j) {
            if(height[i]&lt;=height[j]) i++;
            else j--;
            int new_area = Math.min(height[i],height[j])*(j-i);//思想,动态规划方程
            if (new_area&gt;area) {
                area = new_area;
            }
        }
        return area;
    }
}
</code></pre>
<h5 id="复杂度-57"><a href="#复杂度-57" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<pre><code>示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
</code></pre>
<pre><code>示例 2：

输入：nums = [-1,3,2,-1,0,0]
输出：[[-1,-1,2],[2,3,-1],[3,0,0]]
注意: 这里的数字可以用多次, 只是最后的结果不能重复而已.
</code></pre>
<pre><code>示例 3：

输入：nums = [-1,0,-1,0]
输出：[[-1,0,1]]
注意: 没有[0,0,0]这个答案
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="双循环-map计数-set存储-self"><a href="#双循环-map计数-set存储-self" class="headerlink" title="双循环+map计数+set存储(self"></a>双循环+map计数+set存储(self</h4><h5 id="思路-64"><a href="#思路-64" class="headerlink" title="思路"></a>思路</h5><p>一看数据量, 说明$n^2$算法可以解决, 所以是两个循环, 第三个数用map来直接查找.</p>
<p>首先要明确的是这里面的数字可以用多次, 只是结果里面的不能重复而已, 所以结果需要用一个<code>set&lt;&gt;</code>先存储, 另外, 里面的小结果不能用<code>set&lt;Integer&gt;</code>存储, 因为可能出现<code>[1, 1, -2]</code>这种答案, 所以, 最后答案的存储要用<code>set&lt;List&lt;Integer&gt;&gt;</code>来存储, 并且在将<code>list&lt;Integer&gt;</code>放入<code>set</code>前要进行排序, 否则发挥不了set的作用.</p>
<h5 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for(int i = 0; i &lt;nums.length; i++) {
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
        }
        Set&lt;List&lt;Integer&gt;&gt; answer = new HashSet&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if(nums.length &lt; 3) return result;		//思想, 小于3的答案为空直接返回.
        
        for(int i = 0; i &lt; nums.length; i++) {
            for (int j = i+1; j &lt; nums.length; j++) {
                int last_num = 0-nums[i]-nums[j];
                if(nums[i]==last_num&amp;&amp;map.get(nums[i])&gt;=2&amp;&amp;last_num!=nums[j]&amp;&amp;map.get(nums[j])&gt;=1) {
                    //[-1,-1,2,0]这种情况,两个相同
                }
                else if(nums[j]==last_num&amp;&amp;map.get(nums[j])&gt;=2&amp;&amp;last_num!=nums[i]&amp;&amp;map.get(nums[i])&gt;=1) {
                    //[-1,-1,2,0]这种情况
                }else if(nums[i]!=last_num&amp;&amp;nums[j]!=last_num&amp;&amp;map.get(nums[i])&gt;=1&amp;&amp;map.get(nums[j])&gt;=1&amp;&amp;map.getOrDefault(last_num,0)&gt;=1) {
                    //[1,2,-3]这种情况,都不相同(一个相同)
                }else if(nums[i]==last_num&amp;&amp;nums[j]==last_num&amp;&amp;map.get(nums[i])&gt;=3){
                    //[0,0,0]这种情况, 三个相同
                }
                else{
                    continue;
                }
                List&lt;Integer&gt; new_answer = new ArrayList&lt;&gt;();
                new_answer.add(nums[i]);
                new_answer.add(nums[j]);
                new_answer.add(last_num);
                Collections.sort(new_answer);		//思想, //语法,在进set前进行排序
                answer.add(new_answer);
            }
        }
        for(List&lt;Integer&gt; new_set:answer) {
            List&lt;Integer&gt; new_result = new ArrayList&lt;&gt;(new_set);
            result.add(new_result);
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-58"><a href="#复杂度-58" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序+双指针*"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/">排序+双指针*</a></h4><h5 id="思路-65"><a href="#思路-65" class="headerlink" title="思路"></a>思路</h5><blockquote>
<p>本题的难点在于如何去除重复解。</p>
<ol>
<li>特判，对于数组长度 nnn，如果数组为 nullnullnull 或者数组长度小于 333，返回 [][][]。</li>
<li>对数组进行排序。</li>
<li>遍历排序后数组：<ol>
<li>若 nums[i]&gt;0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。</li>
<li>如果nums[i]与nums[i-1]相同, 继续(排除重复解)</li>
<li>令左指针 L=i+1，右指针 R=n−1，当 L&lt;R时，执行循环：<ul>
<li>nums[i]+nums[L]+nums[R]==0时, 执行循环, 如果左指针和下一个位置相同, 则前进(排除相同解)或者右指针的前一个位置相同,则前进</li>
<li><strong>若和大于0, 说明nums[R]太大, R左移</strong></li>
<li><strong>若和小于0, 说明nums[L]太小, L右移</strong></li>
</ul>
</li>
</ol>
</li>
</ol>
</blockquote>
<p>最后两句话是精髓!</p>
<h5 id="代码-62"><a href="#代码-62" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();
        //排序
        Arrays.sort(nums);
        //双指针
        int len = nums.length;
        for(int i = 0;i &lt; len;++i) {
            if(nums[i] &gt; 0) return lists;

            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;

            int curr = nums[i];
            int L = i+1, R = len-1;
            while (L &lt; R) {
                int tmp = curr + nums[L] + nums[R];
                if(tmp == 0) {
                    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
                    list.add(curr);
                    list.add(nums[L]);
                    list.add(nums[R]);
                    lists.add(list);
                    while(L &lt; R &amp;&amp; nums[L+1] == nums[L]) ++L;
                    while (L &lt; R &amp;&amp; nums[R-1] == nums[R]) --R;
                    ++L;
                    --R;
                } else if(tmp &lt; 0) {
                    ++L;
                } else {
                    --R;
                }
            }
        }
        return lists;
    }
</code></pre>
<h5 id="复杂度-59"><a href="#复杂度-59" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2$)</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<pre><code>示例 1：

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
</code></pre>
<h4 id="递归-循环-self"><a href="#递归-循环-self" class="headerlink" title="递归+循环(self"></a>递归+循环(self</h4><h5 id="思路-66"><a href="#思路-66" class="headerlink" title="思路"></a>思路</h5><p>递归的终止条件是当传递的字符串为0.</p>
<p>递归的传递参数是字符串.</p>
<p>递归的返回类型是List<string>, 是传递的字符串形成的电话号码的字符串.</string></p>
<p>因为数字和字母的对应关系不是规则的, 所以为了解决这个问题写了很多没有算法思想的语句.</p>
<p>但从这个思想上, 我们已经看到了本题应该使用回溯算法思想.</p>
<h5 id="代码-63"><a href="#代码-63" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;String&gt; letterCombinations(String digits) {
        if(digits.length()==0) return new ArrayList&lt;String&gt;();
        return letterCombinationsHelp(digits);
    }
    private List&lt;String&gt; letterCombinationsHelp(String digits) {
        List&lt;String&gt; result = new ArrayList&lt;&gt;();
        if(digits.length()==0) {
            result.add("");
            return result;
        }
        List&lt;String&gt; lastList = new ArrayList&lt;&gt;();
        lastList = letterCombinationsHelp(digits.substring(1,digits.length()));
        if(digits.charAt(0)&gt;='2'&amp;&amp;digits.charAt(0)&lt;='6') {//0-6可以
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'2')*3+'a'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'2')*3+'b'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'2')*3+'c'))+item);
            }
        }else if(digits.charAt(0)=='7'){
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'7')+'p'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'7')+'q'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'7')+'r'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'7')+'s'))+item);
            }
        }else if(digits.charAt(0)=='8'){
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'8')+'t'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'8')+'u'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'8')+'v'))+item);
            }
        }else if(digits.charAt(0)=='9') {
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'9')+'w'))+item);
            }
            for(String item:lastList) {
               result.add((char)(((digits.charAt(0)-'9')+'x'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'9')+'y'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'9')+'z'))+item);
            }
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-60"><a href="#复杂度-60" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$, N层递归, 每层递归最多10次操作左右, 好像不是很准确</li>
<li>空间: $O(N)$, N层递归</li>
</ul>
<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯*"></a>回溯*</h4><h5 id="思路-67"><a href="#思路-67" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-64"><a href="#代码-64" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;String&gt; letterCombinations(String digits) {
        List&lt;String&gt; combinations = new ArrayList&lt;&gt;();
        if(digits.length()==0) return combinations;
        Map&lt;Character, String&gt; phoneMap = new HashMap&lt;&gt;(){{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};
        backtrack(combinations, phoneMap, digits, 0, new StringBuffer());
        return combinations;
    }
    private void backtrack(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, int index, StringBuffer combination) {
        if (index == digits.length()) {
            combinations.add(combination.toString());
        }else {
            char digit = digits.charAt(index);
            String letters = phoneMap.get(digit);
            for(int i = 0; i &lt; letters.length(); i++) {
                combination.append(letters.charAt(i));
                backtrack(combinations, phoneMap, digits, index+1, combination);
                combination.deleteCharAt(index);
            }
        }
    }
}
</code></pre>
<h5 id="复杂度-61"><a href="#复杂度-61" class="headerlink" title="复杂度"></a>复杂度</h5><p><img src="D:\pic-bed\img\image-20220125122049206.png" alt="image-20220125122049206"></p>
<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<h4 id="快慢指针-self-1"><a href="#快慢指针-self-1" class="headerlink" title="快慢指针(self"></a>快慢指针(self</h4><h5 id="思路-68"><a href="#思路-68" class="headerlink" title="思路"></a>思路</h5><p>双指针, 先移动第二个指针到倒数第n个位置,然后两个指针一起移动, 第二个指针移动到末尾的时候第一个指针指向倒数第n个位置.</p>
<p>具体还用了一个技巧, 就是p指向倒数第n+1个位置, 这样好删除.</p>
<h5 id="代码-65"><a href="#代码-65" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fakeHead = new ListNode();
        fakeHead.next = head;
        ListNode result = fakeHead;
        ListNode p = fakeHead;
        ListNode q = fakeHead;
        int i = 0;
        while(i&lt;=n) {
            i++;
            q = q.next;
        }
        while(q!=null) {
            p = p.next;
            q = q.next;
        }
        p.next = p.next.next;
        return result.next;
    }
}
</code></pre>
<h5 id="复杂度-62"><a href="#复杂度-62" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<pre><code>示例 1：

输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
</code></pre>
<pre><code>示例 2：

输入：n = 2
输出：["()()", "(())" ]
</code></pre>
<pre><code>示例 3：

输入：n = 1
输出：["()"]
</code></pre>
<h4 id="递归-迭代加括号-self"><a href="#递归-迭代加括号-self" class="headerlink" title="递归+迭代加括号(self"></a>递归+迭代加括号(self</h4><h5 id="思路-69"><a href="#思路-69" class="headerlink" title="思路"></a>思路</h5><p>从n=1到n=3我得出规律, 每个n都是n-1的字符串的前, 外, 后上面加括号, 比如</p>
<pre><code>n = 1 ()
n = 2 ()()  (()) ()()[这个去重]
</code></pre>
<p>但是写好代码发现, n=4由n=3前外后加括号会遗漏一个答案, 就是这个<code>(())(())</code>, 显然这个答案无法从n=3的答案中前外后加括号所得到, 也就是我的刚开始想的递归方程是错误的, 代码如下:</p>
<pre><code class="java">private Set&lt;String&gt; generateParenthesisHelp(int n) {
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        if(n == 0) {
            set.add("");
            return set;
        }else {
            Set&lt;String&gt; lastSet = generateParenthesisHelp(n-1);
            for(String item:lastSet) {
                String new_item1 = "()"+item;
                String new_item2 = "("+item+")";
                String new_item3 = item+"()";
                set.add(new_item1);
                set.add(new_item2);
                set.add(new_item3);
            } 
            return set;
        }
    }
</code></pre>
<p>其实递归方程应该是对于n-1的串, 遍历他们, 然后增加<code>item.substring(0,i)+"()"+item.substring(i,item.length())</code>这样.</p>
<h5 id="代码-66"><a href="#代码-66" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; result = new ArrayList&lt;&gt;(generateParenthesisHelp(n));
        return result;
    }
    private Set&lt;String&gt; generateParenthesisHelp(int n) {
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        if(n == 1) {
            set.add("()");
            return set;
        }else {
            Set&lt;String&gt; lastSet = generateParenthesisHelp(n-1);
            for(String item:lastSet) {
                for(int i = 0; i &lt; item.length(); i++) {
                    set.add(item.substring(0,i)+"()"+item.substring(i,item.length()));
                }
            } 
            return set;
        }
    }
}
</code></pre>
<h5 id="复杂度-63"><a href="#复杂度-63" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N*2^{N-1})$</li>
<li>空间: $O(2^{N-1})$</li>
</ul>
<h4 id="思想2名称-2"><a href="#思想2名称-2" class="headerlink" title="思想2名称*"></a>思想2名称*</h4><h5 id="思路-70"><a href="#思路-70" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-67"><a href="#代码-67" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-64"><a href="#复杂度-64" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<h4 id="存放数组排序后形成链表-self"><a href="#存放数组排序后形成链表-self" class="headerlink" title="存放数组排序后形成链表(self"></a>存放数组排序后形成链表(self</h4><h5 id="思路-71"><a href="#思路-71" class="headerlink" title="思路"></a>思路</h5><p>存放数组排序后形成链表返答案</p>
<h5 id="代码-68"><a href="#代码-68" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        for(int i = 0; i &lt; lists.length; i++) {
            ListNode p = lists[i];
            while(p!=null) {
                result.add(p.val);
                p = p.next;
            }
        }
        Collections.sort(result);
        ListNode fakeHead = new ListNode();
        ListNode p = fakeHead;
        for(int i = 0; i &lt; result.size(); i++) {
            ListNode node = new ListNode(result.get(i));
            p.next = node;
            p = p.next;
        }
        return fakeHead.next;
    }
}
</code></pre>
<h5 id="复杂度-65"><a href="#复杂度-65" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$(算返回的时间)</li>
</ul>
<h4 id="分治-self"><a href="#分治-self" class="headerlink" title="分治*(self"></a>分治*(self</h4><h5 id="思路-72"><a href="#思路-72" class="headerlink" title="思路"></a>思路</h5><p>这其实就是多路归并, 但是因为多路归并的比较不如二路归并那么快, 所以要把多路归并转化为二路归并, 也就是分治算法, 但是我的这个分治写的不是标准的分治, 标准的分治不会复制形成新的节点, 而是在原有的节点的基础上, 用左右两个指针指代需要分治的位置.</p>
<h5 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h5><pre><code class="java">class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return divideAndConquer(lists);
    }
    ListNode divideAndConquer(ListNode[] lists) {
        //分治
        if(lists.length == 0) return null;
        if(lists.length == 1) {
            return lists[0];
        }
        ListNode fakeHead = new ListNode();
        ListNode p = fakeHead;
        ListNode[] lists1 = new ListNode[lists.length/2];
        ListNode[] lists2 = new ListNode[lists.length-lists.length/2];
        System.arraycopy(lists, 0, lists1, 0, lists.length/2);
        System.arraycopy(lists, lists.length/2, lists2, 0, lists.length-lists.length/2);
        ListNode node1= divideAndConquer(lists1);
        ListNode node2 = divideAndConquer(lists2);
        
        //合并
        while(node1!=null&amp;&amp;node2!=null) {
            if(node1.val&lt;=node2.val) {
                p.next = node1;
                node1 = node1.next;
            }else{
                p.next = node2;
                node2 = node2.next;
            }
            p = p.next;
        }
        if(node1!=null) p.next = node1;
        if(node2!=null) p.next = node2;
        return fakeHead.next;
    }
}
</code></pre>
<h5 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h5><p>对代码1的分治进行了改进, 节省了空间, 比较标准化写了分治</p>
<pre><code class="java">class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return divideAndConquer(lists,0,lists.length);
    }
    ListNode divideAndConquer(ListNode[] lists, int left, int right) {
        if(left==right) return null;
        if(right-left == 1) {
            return lists[left];
        }
        ListNode fakeHead = new ListNode();
        ListNode p = fakeHead;
        ListNode node1= divideAndConquer(lists, left, left+(right-left)/2);
        ListNode node2 = divideAndConquer(lists, left+(right-left)/2, right);
        while(node1!=null&amp;&amp;node2!=null) {
            if(node1.val&lt;=node2.val) {
                p.next = node1;
                node1 = node1.next;
            }else{
                p.next = node2;
                node2 = node2.next;
            }
            p = p.next;
        }
        if(node1!=null) p.next = node1;
        if(node2!=null) p.next = node2;
        return fakeHead.next;
    }
}
</code></pre>
<h5 id="复杂度-66"><a href="#复杂度-66" class="headerlink" title="复杂度"></a>复杂度</h5><p><img src="D:\pic-bed\img\image-20220126111829459.png" alt="image-20220126111829459"></p>
<h4 id="优先队列-self"><a href="#优先队列-self" class="headerlink" title="优先队列(self"></a>优先队列(self</h4><h5 id="思路-73"><a href="#思路-73" class="headerlink" title="思路"></a>思路</h5><p>官方题解用优先队列来取代二路归并的比较进行多路归并的比较, 但是我想着都用优先队列了, 直接遍历数据存入优先队列(自然排序)再形成链表自然就是答案了.</p>
<h5 id="代码-69"><a href="#代码-69" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;();
        for(int i = 0; i &lt; lists.length; i++) {
            ListNode node = lists[i];
            while(node!=null) {
                queue.add(node.val);
                node = node.next;
            }
        }
        ListNode fakeHead = new ListNode();
        ListNode p = fakeHead;
        int len = queue.size();						//语法, 优先队列的按自然排序取出只能这样取,因为是堆排序, 每出来一个大小会变化.
        for(int i = 0; i &lt; len; i++) {
            p.next = new ListNode(queue.poll());
            p = p.next;
        }
        return fakeHead.next;
    }
}
</code></pre>
<h5 id="复杂度-67"><a href="#复杂度-67" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N<em>N</em>log^N)$遍历N遍, 每遍进行一次堆排序</li>
</ul>
<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h3><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<pre><code>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
</code></pre>
<p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<pre><code>示例 1：

输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：

输入：nums = [3,2,1]
输出：[1,2,3]
</code></pre>
<h4 id="下一个排列算法"><a href="#下一个排列算法" class="headerlink" title="下一个排列算法"></a>下一个排列算法</h4><h5 id="思路-74"><a href="#思路-74" class="headerlink" title="思路"></a>思路</h5><p>从后往前一直顺序, 顺序被打断的位置记作$little_small_index$, 然后在$(little_small_index, length-1)$中找比little_small_index位置的最小的稍大数(因为little_small_index,length-1)是顺序, 所以从后往前或者从前往后遍历一遍就找到了, 位置记作little_big_index), 交换little_small_index和little_big_index, 然后再对little_small_index后的进行一遍排序(也就是转置, 因为交换后的(little_small_index, length-1)依然是顺序.</p>
<h5 id="代码-70"><a href="#代码-70" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void nextPermutation(int[] nums) {
        if(nums.length==1) return;
        int flag = 0;									//标志,0表示从后往前顺序,-1表示被打断
        int little_small_index = 0;
        int little_big_index = 0;
        for(int i = nums.length-1; i &gt; 0; --i) {				//思想, 找到稍微小一点的index
            if(nums[i]&lt;=nums[i-1]) {
                //从后往前顺序
                continue;
            }else{
                flag = 1;
                little_small_index = i-1;
                break;
            }
        }
        for (int i = nums.length-1; i &gt; little_small_index; --i) {//思想,找到稍微大一点的index
            if(nums[i] &lt;= nums[little_small_index]) continue;
            else {
                little_big_index = i;
                break;
            }
        }
        if(flag == 0) {
            //从后往前一直顺序
            inverse(nums, 0, nums.length-1);
        }else {
            swap(nums, little_small_index, little_big_index);
            inverse(nums, little_small_index+1, nums.length-1);
        }
        return;
    }
    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
        return;
    }
    private void inverse(int[] nums, int s, int e) {		//语法, 原地转置
        for(int i = 0; i &lt;= (e-s)/2;i++) {
            swap(nums, s+i,e-i);
        }
    }
}
</code></pre>
<h5 id="复杂度-68"><a href="#复杂度-68" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h3><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<pre><code>示例 1：
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"

示例 2：
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"

示例 3：
输入：s = ""
输出：0

示例 4：
输入：s = "()(()"
输出：2

示例 3：
输入：s = ")()())"
输出：4
</code></pre>
<p>动态规划</p>
<h5 id="思路-75"><a href="#思路-75" class="headerlink" title="思路"></a>思路</h5><p>见题解</p>
<h5 id="代码-71"><a href="#代码-71" class="headerlink" title="代码"></a>代码</h5><pre><code>class Solution {
    public int longestValidParentheses(String s) {
        int [] dp = new int[s.length()];
        int max_length = 0;
        for (int i = 1; i &lt; s.length(); i++) {
            if (s.charAt(i)==')'){
                if(s.charAt(i-1)=='(') {
                    dp[i] = (i&gt;=2?dp[i-2]:0)+2;		//语法, //思想, 这里的三目运算符是为了解决dp初始化问题和边界问题.
                }else if(i-dp[i-1]&gt;0 &amp;&amp; s.charAt(i-dp[i-1]-1)=='(') {
                    dp[i] = dp[i-1]+ (i-dp[i-1]&gt;=2 ? dp[i-dp[i-1]-2]:0)+2;	//语法, //思想, 这里的三目运算符是为了解决dp初始化问题和边界问题.
                }
                max_length = max_length &lt; dp[i]?dp[i]:max_length;
            }
        }
        return max_length;
    }
}
</code></pre>
<h5 id="复杂度-69"><a href="#复杂度-69" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h3><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<pre><code>示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
</code></pre>
<p>提示：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 5000</li>
<li>-10^4 &lt;= nums[i] &lt;= 10^4</li>
<li>nums 中的每个值都 独一无二</li>
<li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li>
<li>-10^4 &lt;= target &lt;= 10^4</li>
</ul>
<h4 id="顺序遍历-self"><a href="#顺序遍历-self" class="headerlink" title="顺序遍历(self"></a>顺序遍历(self</h4><h5 id="思路-76"><a href="#思路-76" class="headerlink" title="思路"></a>思路</h5><p>这个题数据量O(N)能解决, 所以先直接顺序遍历找AC后再思考考点.</p>
<p>考点应该是如果数据量超大的话必须降为$O(logN)$, 如果是对数时间复杂度, 寻找的复杂度用二分即可实现, 但是要找到那个旋转点 k 才能进行二分, 所以找k的算法应该也是对数复杂度.可以这样找k</p>
<ul>
<li>将nums对半分, 这样一个必定为顺序, 一个必定为旋转数组</li>
<li>回到上步</li>
</ul>
<h5 id="代码-72"><a href="#代码-72" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int search(int[] nums, int target) {
        int result = -1;
        for(int i = 0; i &lt; nums.length; i++) {
            if(target == nums[i]) {
                result = i;
                break;
            }
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-70"><a href="#复杂度-70" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="二分查找变体-self"><a href="#二分查找变体-self" class="headerlink" title="二分查找变体(self"></a>二分查找变体(self</h4><h5 id="思路-77"><a href="#思路-77" class="headerlink" title="思路"></a>思路</h5><p>二分寻找的变体.</p>
<ul>
<li>先分为两半, 必定一个顺序一个旋转</li>
<li>如果target在顺序之中, 则继续寻找, 否则在旋转中寻找</li>
<li>寻找的终止条件是e-s&lt;=1 , 也就是一个数或者两个数(一般来说为一个数, 但是有点数组越界, 我就改造了一下)</li>
</ul>
<h5 id="代码-73"><a href="#代码-73" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int search(int[] nums, int target) {
        return binarySearch(nums, 0, nums.length-1, target);
    }
    private int binarySearch(int[] nums, int s, int e, int target) {
        int m = s + (e-s)/2;
        if (e-s&lt;=1) {
            if (nums[s]==target) return s;
            else if(nums[e]==target) return e;
            else return -1;
        }
        if (nums[s] &lt; nums[m]) {
            if (nums[s]&lt;=target &amp;&amp;nums[m]&gt;=target) return binarySearch(nums, s, m, target);
            else{
                return binarySearch(nums, m, e, target);
            }
        }else{
            if (nums[m]&lt;=target &amp;&amp;nums[e]&gt;=target) return binarySearch(nums, m, e, target);
            else{
                return binarySearch(nums, s, m, target);
            }
        }
    }
}
</code></pre>
<h5 id="复杂度-71"><a href="#复杂度-71" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(logN)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<h4 id="二分查找变体-self-1"><a href="#二分查找变体-self-1" class="headerlink" title="二分查找变体(self"></a>二分查找变体(self</h4><h5 id="思路-78"><a href="#思路-78" class="headerlink" title="思路"></a>思路</h5><p>两个二分查找, 只不过一个从前找start, 一个从后找end.</p>
<h5 id="代码-74"><a href="#代码-74" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] searchRange(int[] nums, int target) {
        int [] result = new int[2];
        result[0] = -1;
        result[1] = -1;
        if (nums.length==0) return result;
        result[0] = binarySearchStart(nums, 0, nums.length-1, target);
        result[1] = binarySearchEnd(nums, 0, nums.length-1, target);
        return result;
    }
    // 找start
    public int binarySearchStart(int[] nums, int s, int e, int target) {
        if(e-s&lt;=1) {
            if(nums[s] == target) return s;
            else if(nums[e] == target) return e;
            else return -1;
        }
        int m = s+(e-s)/2;
        if(nums[s]&lt;=target &amp;&amp; target &lt;= nums[m]) return binarySearchStart(nums, s, m, target);
        else return binarySearchStart(nums, m+1, e, target);
    }
    public int binarySearchEnd(int[] nums, int s, int e, int target) {
        if(e-s&lt;=1) {
            if(nums[e] == target) return e;
            else if(nums[s] == target) return s;
            else return -1;
        }
        int m = s+(e-s)/2;
        if(nums[m]&lt;=target &amp;&amp; target &lt;= nums[e]) return binarySearchEnd(nums, m, e, target);
        else return binarySearchEnd(nums, s, m-1, target);
    }

}
</code></pre>
<h5 id="代码2-1"><a href="#代码2-1" class="headerlink" title="代码2"></a>代码2</h5><pre><code class="java">class Solution {
    public int[] searchRange(int[] nums, int target) {
        int [] result = new int[2];
        result[0] = -1;
        result[1] = -1;
        if (nums.length==0) return result;
        result[0] = binarySearchStart(nums, 0, nums.length-1, target);
        result[1] = binarySearchEnd(nums, 0, nums.length-1, target);
        return result;
    }
    public int binarySearchStart(int[] nums, int s, int e, int target) {
        if(e-s==0) {
            if(nums[s] == target) return s;
            else return -1;
        }
        int m = s+(e-s)/2;
        if(nums[s]&lt;=target &amp;&amp; target &lt;= nums[m]) return binarySearchStart(nums, s, m, target);
        else return binarySearchStart(nums, m+1, e, target);
    }
    public int binarySearchEnd(int[] nums, int s, int e, int target) {
        if(e-s==0) {
            if(nums[e] == target) return e;
            else return -1;
        }
        int m = s+(e-s)/2+1;		//注意这里要+1.
        if(nums[m]&lt;=target &amp;&amp; target &lt;= nums[e]) return binarySearchEnd(nums, m, e, target);
        else return binarySearchEnd(nums, s, m-1, target);
    }

}
</code></pre>
<h5 id="复杂度-72"><a href="#复杂度-72" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(logN)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<pre><code>示例 1：

输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
</code></pre>
<h4 id="回溯-self-没做出来"><a href="#回溯-self-没做出来" class="headerlink" title="回溯(self, 没做出来"></a>回溯(self, 没做出来</h4><h5 id="思路-79"><a href="#思路-79" class="headerlink" title="思路"></a>思路</h5><p>就一看就是回溯的题, 但对回溯的方法不太熟, 只能写个大概.</p>
<h5 id="代码-75"><a href="#代码-75" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; last = new ArrayList&lt;&gt;();
        combinationSumHelp(candidates, target, 0, last, 0, result);
        return result;
    }
    public void combinationSumHelp(int[] candidates, int target, int index, List&lt;Integer&gt; last, int sum, List&lt;List&lt;Integer&gt;&gt; result) {
      if(index &gt;= candidates.length) return;
        if(candidates[index]+sum==target) {
            last.add(candidates[index]);
            sum+=candidates[index];
            List&lt;Integer&gt; result_item = new ArrayList&lt;&gt;(last);
            result.add(result_item);
            return;
        }else if(candidates[index]+sum &gt; target) {
            return;
        }
        else if(candidates[index]+sum &lt; target){
            last.add(candidates[index]);
            List&lt;Integer&gt; temp_last = new ArrayList&lt;&gt;(last);
            combinationSumHelp(candidates, target, index, temp_last, sum+=candidates[index], result);
            last.remove(last.size()-1);
            sum-=candidates[index];
            combinationSumHelp(candidates, target, index+1, last, sum, result);
        }
    }
}
</code></pre>
<h4 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯*"></a>回溯*</h4><h5 id="思路-80"><a href="#思路-80" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-76"><a href="#代码-76" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; combination = new ArrayList&lt;&gt;();
        combinationSumHelp(candidates, target, 0, combination, result);
        return result;
    }
    public void combinationSumHelp(int[] candidates, int target, int begin, List&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; result) {
      if (target &lt; 0) return;
      if  (target == 0) {
          result.add(new ArrayList&lt;&gt;(combination));
          return;
      }
      for (int i = begin; i &lt; candidates.length; i++) {
          combination.add(candidates[i]);
          combinationSumHelp(candidates, target-candidates[i], i, combination, result);
          combination.remove(combination.size()-1);
      }
    }
}
</code></pre>
<h5 id="复杂度-73"><a href="#复杂度-73" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(S)$，其中 S为所有可行解的长度之和(树的深度之和, 可以通过剪枝来降低)</li>
<li>空间: $O(target)$, 最差为target深(都是1).</li>
</ul>
<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<pre><code>示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]

示例 3：

输入：nums = [1]
输出：[[1]]
</code></pre>
<h4 id="填空-self没做出来"><a href="#填空-self没做出来" class="headerlink" title="填空(self没做出来"></a>填空(self没做出来</h4><h5 id="思路-81"><a href="#思路-81" class="headerlink" title="思路"></a>思路</h5><p>我想的是[1, 2, 3, 4], 然后把1取出来, 然后放入剩下的[2, 3, 4]的四个空中, 这样遍历所有数据来一次.</p>
<p>这么做不能得到全排列, 比如[4, 3, 2, 1]这个数据出不来, 只能出来<code>[4, 1, 2, 3], [1, 4, 2, 3], [1, 2, 4, 3], [1, 2, 3, 4]</code>这些数据</p>
<h4 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯*"></a>回溯*</h4><h5 id="思路-82"><a href="#思路-82" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-77"><a href="#代码-77" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; collections = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; collection = new ArrayList&lt;&gt;();
        int [] flags = new int[nums.length];				//用一个flag数组来标志是否使用过
        int depth = nums.length;
        dfs(collections, collection, nums, flags, depth, 0);
        return collections;
    }

    //思想
    void dfs(List&lt;List&lt;Integer&gt;&gt; collections, List&lt;Integer&gt; collection, int[]nums, int [] flags, int depth, int index){
        if (index == depth) {
            collections.add(new ArrayList&lt;Integer&gt;(collection));
            return;
        }

        for (int i = 0; i &lt; depth; i++) {
            if (flags[i] == 0) {
                flags[i] = 1;
                collection.add(nums[i]);
                dfs(collections, collection, nums, flags, depth, index+1);
                flags[i] = 0;
                collection.remove(collection.size()-1);
            }
        }
    }
}
</code></pre>
<h5 id="复杂度-74"><a href="#复杂度-74" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N*N!)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<h4 id="利用矩阵的转置加镜像"><a href="#利用矩阵的转置加镜像" class="headerlink" title="利用矩阵的转置加镜像*"></a>利用矩阵的转置加镜像*</h4><h5 id="思路-83"><a href="#思路-83" class="headerlink" title="思路"></a>思路</h5><p>转置和镜像可以原地进行.</p>
<p>向右旋转90°=&gt;先转置再左右镜像.</p>
<p>向右旋转180°=&gt;先左右镜像, 再上下镜像.</p>
<p>向右旋转270°=&gt;先转置再上下镜像(也就是向左旋转90°)</p>
<h5 id="代码-78"><a href="#代码-78" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void rotate(int[][] matrix) {
        transpose(matrix);
        leftRightMirror(matrix);
        return;
    }
    void transpose(int[][] matrix) {
        for (int i = 0; i &lt; matrix.length; i++) {
            for (int j = i; j &lt; matrix.length;j++) {
                int t = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = t;
            }
        }
        return;
    }
    void leftRightMirror(int [][]matrix) {
        for (int j= 0; j&lt; matrix.length/2; j++) {
            for (int i = 0; i &lt; matrix.length; i++) {
                int t = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.length-1-j];
                matrix[i][matrix.length-1-j] = t;
            }
        }
    }
    void upDownMirror(int [][] matrix) {
        for (int i = 0; i &lt; matrix.length/2; i++) {
            for (int j = 0 ;j &lt; matrix.length; j++) {
                int t = matrix[i][j];
                matrix[i][j] = matrix[matrix.length-1-i][j];
                matrix[matrix.length-1-i][j] = t;
            }
        }
    }
}
</code></pre>
<h5 id="复杂度-75"><a href="#复杂度-75" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<pre><code>示例 1:

输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

示例 2:

输入: strs = [""]
输出: [[""]]
</code></pre>
<h4 id="Map-self"><a href="#Map-self" class="headerlink" title="Map(self"></a>Map(self</h4><h5 id="思路-84"><a href="#思路-84" class="headerlink" title="思路"></a>思路</h5><p>先得到每个字符串对应的字典序字符串, 然后创建该字典序字符串的<code>map&lt;string, List&lt;String&gt;&gt;</code>, 遍历一遍放进去之后再遍历一遍得到列表.</p>
<h5 id="代码-79"><a href="#代码-79" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        List&lt;String&gt; lexicographicOrderStrs = new ArrayList&lt;&gt;();//对应strs的字典序列表
        List&lt;List&lt;String&gt;&gt; result;
        for(int i = 0; i &lt; strs.length; i++) {
            lexicographicOrderStrs.add(i, getLexicographicOrder(strs[i]));
        }
        //System.out.println(lexicographicOrderStrs);
        Map&lt;String, List&lt;String&gt;&gt; stringMap = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; strs.length; i++) {
            List&lt;String&gt; item = stringMap.getOrDefault(lexicographicOrderStrs.get(i), new ArrayList&lt;String&gt;());
            item.add(strs[i]);
            stringMap.put(lexicographicOrderStrs.get(i), item);
        }
        result =  new ArrayList&lt;&gt;(stringMap.values());
        return result;
    }
    String getLexicographicOrder(String str) {
        char[] ar = str.toCharArray();
        Arrays.sort(ar);
        String sortedStr = String.valueOf(ar);
        return sortedStr;
    }
}
</code></pre>
<h5 id="复杂度-76"><a href="#复杂度-76" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(NKlog^K)$ K为字符串最长长度</li>
<li>空间: $O(N)$</li>
</ul>
<h5 id="代码-80"><a href="#代码-80" class="headerlink" title="代码"></a>代码</h5><p>官方题解简化版</p>
<pre><code class="java">class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();
        for (String str : strs) {
            char[] array = str.toCharArray();
            Arrays.sort(array);
            String key = new String(array);
            List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;());
            list.add(str);
            map.put(key, list);
        }
        return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());
    }
}


作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h3><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<pre><code>示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
</code></pre>
<h4 id="动态规划-self"><a href="#动态规划-self" class="headerlink" title="动态规划?(self"></a>动态规划?(self</h4><h5 id="思路-85"><a href="#思路-85" class="headerlink" title="思路"></a>思路</h5><p>用一个max来记录该位置之前可以到达最远的位置, 然后比较该位置和最远位置, 如果该位置可以到达, 重新计算最远位置, 直至最后一个位置.</p>
<h5 id="代码-81"><a href="#代码-81" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean canJump(int[] nums) {
        int max = 0+nums[0];        //之前的步数可以到达的最大坐标.
        boolean flag = true;       //是否可以到达最后下标.
        for (int i = 1; i &lt; nums.length; i++) {
            if(i &lt;= max) {
                //可以到达
                max = max &gt; i+nums[i]?max:i+nums[i];
            }else {
                flag = false;   //不可以到达
                break;
            }
        }
        return flag;
    }
}
</code></pre>
<h5 id="复杂度-77"><a href="#复杂度-77" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<pre><code>示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。


示例 3：

输入：intervals = [[1,4],[5,6]]
输出：[[1,4],[5,6]]
解释：区间 [1,4] 和 [5,6] 不可被视为重叠区间。
</code></pre>
<h4 id="模拟-self-没做出来"><a href="#模拟-self-没做出来" class="headerlink" title="模拟(self, 没做出来"></a>模拟(self, 没做出来</h4><h5 id="思路-86"><a href="#思路-86" class="headerlink" title="思路"></a>思路</h5><p>把各个区间遍历一遍在数轴上进行标记, 然后再遍历一遍数轴得到这些区间.</p>
<p>这个思想是错误的, 这个只能得到合并后的区间, 但是不能得到重叠的区间, 比如示例3, 示例3就会被这样的算法得到一个区间, 没有体现重叠.</p>
<h5 id="代码-82"><a href="#代码-82" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[][] merge(int[][] intervals) {
        int [] flags = new int[10001];
        for (int i = 0; i &lt; intervals.length; i++) {
            for(int j = intervals[i][0]; j &lt;=intervals[i][1]; j++) {
                flags[j] = 1;
            }
        }
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        int flag = 0;           //是否已经选取左端点的标志
        for(int i = 0; i &lt; 10001; i++) {
            if(flags[i] == 1 &amp;&amp; flag == 0) {
                List&lt;Integer&gt; item = new ArrayList&lt;&gt;();
                item.add(i);
                result.add(item);
                flag = 1;
            }else if(flags[i] == 1 &amp;&amp; flag == 1) {
                if (i==10000||flags[i+1]==0) {
                    //右端
                    result.get(result.size()-1).add(i);
                    flag = 0;
                }else{
                    //非右端, 中间
                    continue;
                }
            }else {
                //flags[i] == 0
                continue;
            }
        }
        int[][] realResult = new int[result.size()][2];
        for(int i = 0; i &lt; result.size(); i++) {
            realResult[i][0] = result.get(i).get(0);
            realResult[i][1] = result.get(i).get(1);
        }
        return realResult;
    }
}
</code></pre>
<h4 id="排序后找规律"><a href="#排序后找规律" class="headerlink" title="排序后找规律*"></a>排序后找规律*</h4><h5 id="思路-87"><a href="#思路-87" class="headerlink" title="思路"></a>思路</h5><p>对这些区间进行左端的排序保证左端一定最小, 然后的话合并这些区间:</p>
<ul>
<li>如果下一个区间的左端比上一个区间的右端大, 一定不重叠, 直接形成新区间.</li>
<li>如果下一个区间的左端比上一个区间的右端小, 然后将上一个区间的右端置为这两个区间最大的右端.</li>
</ul>
<h5 id="代码-83"><a href="#代码-83" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[][] merge(int[][] intervals) {
        
        Arrays.sort(intervals, new Comparator&lt;int[]&gt;(){//语法
            public int compare(int [] intervals1, int [] intervals2) {
                return intervals1[0] - intervals2[0];
            }
        });
        List&lt;int[]&gt; merge = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; intervals.length; i++) {
            int L = intervals[i][0];
            int R = intervals[i][1];
            if (merge.size()==0||merge.get(merge.size()-1)[1] &lt; L) {//语法, //思想
                merge.add(new int[]{L,R});
            }else{
                //如果存在重叠
                merge.get(merge.size()-1)[1] = Math.max(merge.get(merge.size()-1)[1], R);//思想
            }
        }
        return merge.toArray(new int[merge.size()][]);//语法
    }
}
</code></pre>
<h5 id="复杂度-78"><a href="#复杂度-78" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<h4 id="动态规划-self-1"><a href="#动态规划-self-1" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-88"><a href="#思路-88" class="headerlink" title="思路"></a>思路</h5><p>把最后一行和最后一列初始化为1, 然后从右下角往左上角计算,动态规划方程如下:<br>$$<br>squar[i][j] = 1; (i=m-2, j=1,2…n-1)\<br>squar[i][j] = 1; (j=n-2, j=1,2…m-1)\<br>squar[i][j] = square[i][j+1]+square[i+1][j];<br>$$</p>
<h5 id="代码-84"><a href="#代码-84" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int uniquePaths(int m, int n) {
        int [][] square = new int[m][n];
        square[m-1][n-1] = 1;
        for(int i = 0; i &lt; m; i++) {
            square[i][n-1] = 1;
        }
        for(int j = 0; j &lt; n; j++) {
            square[m-1][j] = 1;
        }
        for (int i = m-2; i &gt;= 0; i--) {
            for (int j = n-2; j &gt;= 0; j--) {
                square[i][j] = square[i][j+1]+square[i+1][j];
            }
        }
        return square[0][0];
    }
}
</code></pre>
<h5 id="复杂度-79"><a href="#复杂度-79" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(M*N)$</li>
</ul>
<h4 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划*"></a>动态规划*</h4><h5 id="思路-89"><a href="#思路-89" class="headerlink" title="思路"></a>思路</h5><p>从左上往右下计算</p>
<h5 id="代码-85"><a href="#代码-85" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int uniquePaths(int m, int n) {
        int [][] square = new int[m][n];
        square[m-1][n-1] = 1;
        for(int i = 0; i &lt; m; i++) {
            square[i][n-1] = 1;
        }
        for(int j = 0; j &lt; n; j++) {
            square[m-1][j] = 1;
        }
        for (int i = m-2; i &gt;= 0; i--) {
            for (int j = n-2; j &gt;= 0; j--) {
                square[i][j] = square[i][j+1]+square[i+1][j];
            }
        }
        return square[0][0];
    }
}
</code></pre>
<h5 id="复杂度-80"><a href="#复杂度-80" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(M*N)$</li>
</ul>
<h4 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h4><h5 id="思路-90"><a href="#思路-90" class="headerlink" title="思路"></a>思路</h5><p>一共需要走$m+n-2$步, 需要从中挑选$m-1$次向下移动.</p>
<h5 id="代码-86"><a href="#代码-86" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y &lt; m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
}
</code></pre>
<h5 id="复杂度-81"><a href="#复杂度-81" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li><p>时间复杂度：O(m)。由于我们交换行列的值并不会对答案产生影响，因此我们总可以通过交换 m和 n 使得 m&lt;=n，这样空间复杂度降低至 O(min(m,n))。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h3><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<pre><code>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
</code></pre>
<h4 id="动态规划-self-2"><a href="#动态规划-self-2" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-91"><a href="#思路-91" class="headerlink" title="思路"></a>思路</h5><p>动态规划, 和63题思路差不多, 只不过算和而且正向算</p>
<h5 id="代码-87"><a href="#代码-87" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int [][] square = new int[m][n];
        square[0][0] = grid[0][0];                      //思想
        for(int i = 1; i &lt; m; i++) {
            square[i][0] = square[i-1][0]+grid[i][0];   //思想, 注意第一个是square
        }
        for(int j = 1; j &lt; n; j++) {
            square[0][j] = square[0][j-1]+grid[0][j];
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                square[i][j] = Math.min(square[i-1][j],square[i][j-1])+grid[i][j];
            }
        }
        return square[m-1][n-1];
    }
}
</code></pre>
<h5 id="复杂度-82"><a href="#复杂度-82" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(m*n)$</li>
<li>空间: $O(m*n)$</li>
</ul>
<h4 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划*"></a>动态规划*</h4><h5 id="思路-92"><a href="#思路-92" class="headerlink" title="思路"></a>思路</h5><p>可以不建新数组, 直接在原数组修改</p>
<h5 id="复杂度-83"><a href="#复杂度-83" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h3><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。</p>
<pre><code>示例 1：

输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]

示例 2：

输入：nums = [2,0,1]
输出：[0,1,2]

</code></pre>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以不使用代码库中的排序函数来解决这道题吗？</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<h4 id="桶排序思想-self"><a href="#桶排序思想-self" class="headerlink" title="桶排序思想(self"></a>桶排序思想(self</h4><h5 id="思路-93"><a href="#思路-93" class="headerlink" title="思路"></a>思路</h5><p>扫描第一遍记录各个数字数目, 第二遍置数</p>
<h5 id="复杂度-84"><a href="#复杂度-84" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $o(1)$</li>
</ul>
<h4 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针*"></a>双指针*</h4><h5 id="思路-94"><a href="#思路-94" class="headerlink" title="思路"></a>思路</h5><p>官方题解方法三.</p>
<p>用两个指针p1,p2来指代0和2要替换的位置, 扫描, 如果发现0的话与p1位置交换, 如果发现2的话与p2位置交换, 但是要注意, 无论是交换0还是2, 交换后的结果都有可能是三种(0和2), 这时候不能前进, 而是要将再进行交换直到不是自己.这两个做1个就行了.</p>
<h5 id="代码-88"><a href="#代码-88" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void sortColors(int[] nums) {
        int p1 = 0;                     //用来指示1的下次交换
        int p2 = nums.length-1;         //用来指示2的下次交换
        for (int i = 0; i &lt;= p2; ++i) {	//思想, 注意终止条件.
            if(nums[i] == 0) {
                int t = nums[i];
                nums[i] = nums[p1];
                nums[p1] = t;
                p1++;              
            }else if (nums[i] == 2){
                int t = nums[i];
                nums[i] = nums[p2];
                nums[p2] = t;
                p2--;
                i--;                    //思想,如果是2的话替换之后可能是0, 可能是1, 也可能是2 所以要转变为这个位置不是2为止, 也就是其他两种情况
            }else{
                continue;
            }
        }
        return;
    }
}
</code></pre>
<h5 id="复杂度-85"><a href="#复杂度-85" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<pre><code>示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

示例 2：

输入：nums = [0]
输出：[[],[0]]
</code></pre>
<h4 id="回溯-self"><a href="#回溯-self" class="headerlink" title="回溯(self"></a>回溯(self</h4><h5 id="思路-95"><a href="#思路-95" class="headerlink" title="思路"></a>思路</h5><p>回溯模板, 不用标记数组</p>
<h5 id="代码-89"><a href="#代码-89" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; collections = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; collection = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();
        collections.add(item);           //空集
        dfs(collections, collection, nums.length, 0, nums);
        return collections;
    }
    void dfs(List&lt;List&lt;Integer&gt;&gt; collections, List&lt;Integer&gt; collection, int depth, int index, int []nums) {
        if (index == depth) {
            return;
        }
        for(int i = index; i &lt; depth; i++){
            collection.add(nums[i]);
            collections.add(new ArrayList&lt;Integer&gt;(collection));		//思想
            dfs(collections, collection, depth, i+1, nums);
            collection.remove(collection.size()-1);
        }
    }
}
</code></pre>
<h5 id="复杂度-86"><a href="#复杂度-86" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="动态规划-self-3"><a href="#动态规划-self-3" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-96"><a href="#思路-96" class="headerlink" title="思路"></a>思路</h5><p>[1,2,3]的子集可以由[1,2]的子集得到</p>
<h5 id="代码-90"><a href="#代码-90" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; collections = new ArrayList&lt;&gt;();
        collections.add(new ArrayList&lt;&gt;());           //空集
        List&lt;Integer&gt; temp_item = new ArrayList&lt;&gt;();
        temp_item.add(nums[0]);
        collections.add(temp_item);
        for (int i = 1; i &lt; nums.length; i++) {
            int length = collections.size();
            for(int j = 0; j &lt; length; j++) {
                List&lt;Integer&gt; new_item = new ArrayList&lt;&gt;(collections.get(j));
                new_item.add(nums[i]);
                collections.add(new_item);
            }
        }
        return collections;
    }
    
}
</code></pre>
<h5 id="复杂度-87"><a href="#复杂度-87" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(2^N)$</li>
<li>空间: $O(2^N)$结果的空间</li>
</ul>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h3><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<h4 id="回溯-3"><a href="#回溯-3" class="headerlink" title="回溯"></a>回溯</h4><h5 id="思路-97"><a href="#思路-97" class="headerlink" title="思路"></a>思路</h5><p>我觉得很重要的一点是, 主函数要干什么,  辅助函数要干什么.</p>
<p>主函数: 遍历棋盘, 使用辅助函数判断是否该位置可以得到正确答案.</p>
<p>辅助函数:</p>
<ul>
<li><p>如果是倒数第一位, 则直接返回最后一位与当前棋盘的判别, 这样是必要的, 一个是剪掉枝, 另一个最重要的是, 我们的辅助函数默认(i,j)是合法的, 如果判断最后一位与字符串的长度的话, (i, j)必然不合法.就会出现</p>
<pre><code>[[a]]
a
</code></pre>
<p>这样的样例是false的结果</p>
</li>
<li><p>如果当前棋盘子和字符相同的话, 继续试探<strong>合法的棋子</strong>与下一个字符.</p>
</li>
<li><p>如果周围4个都不正常的话, 回退本棋子, 并且返回假.</p>
</li>
</ul>
<h5 id="代码-91"><a href="#代码-91" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean exist(char[][] board, String word) {
        List&lt;Boolean&gt; result = new ArrayList&lt;&gt;();
        boolean[][] board_flag = new boolean[board.length][board[0].length];
        boolean flag = false;
        for (int i = 0 ; i &lt; board.length; i ++) {
            for (int j = 0; j &lt; board[0].length; j++) {
                flag = exist_help(i, j, 0, board, board_flag, word);
                if (flag == true) return true;
            }
        }
        return false;
    }
    boolean exist_help(int i, int j, int k, char[][] board, boolean [][] board_flag, String word) {
        
        if(k==word.length()-1) {			//思想, 不能用k==word.length() return true;
            return board[i][j] == word.charAt(k);
        }
        if (board[i][j]==word.charAt(k)) {
            board_flag[i][j] = true;
            if(inArea(i, j+1, board)&amp;&amp;!board_flag[i][j+1]) {
                if (exist_help(i, j+1, k+1, board, board_flag, word)) return true;
            }
            if(inArea(i, j-1, board)&amp;&amp;!board_flag[i][j-1]) {
                if( exist_help(i, j-1, k+1, board, board_flag, word)) return true;
            }
            if(inArea(i-1, j, board)&amp;&amp;!board_flag[i-1][j]) {
                if( exist_help(i-1, j, k+1, board, board_flag, word)) return true;
            }
            if(inArea(i+1, j, board)&amp;&amp;!board_flag[i+1][j]) {
                if( exist_help(i+1, j, k+1, board, board_flag, word)) return true;
            }
            board_flag[i][j] = false;
        }
        return false;
        
    }
    boolean inArea(int i, int j, char[][]board) {
        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; board.length &amp;&amp; j &lt; board[0].length) {
            return true;
        }else {
            return false;
        }
    }
}
</code></pre>
<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<h4 id="动态规划-self-4"><a href="#动态规划-self-4" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-98"><a href="#思路-98" class="headerlink" title="思路"></a>思路</h5><p>可以分解为子问题, 1节点为1, 2节点为2, 3为5个节点, 然后</p>
<pre><code>4可以求解:
以1为中心, 左0右3
以2为中心, 左1右2
以3为中心, 左2右1
以4为中心, 左1右3
</code></pre>
<p>然后左边和右边数量<strong>是相乘的关系(组合)</strong>, 我第一次写为了相加.</p>
<blockquote>
<p>结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，…，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0)<em>G(n-1)+G(1)</em>(n-2)+…+G(n-1)*G(0)</p>
<p>-评论</p>
</blockquote>
<h5 id="代码-92"><a href="#代码-92" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int numTrees(int n) {
        int[] tree_num = new int[20];
        tree_num[0] = 1;
        tree_num[1] = 1;
        tree_num[2] = 2;
        tree_num[3] = 5;
        for (int i = 4; i &lt;= n; i++) {
            for (int j = 1; j &lt;= i; j++) {
                tree_num[i]+=tree_num[j-1]*tree_num[i-j];
            }
        }
        return tree_num[n];
    }
}
</code></pre>
<h5 id="复杂度-88"><a href="#复杂度-88" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<h4 id="递归构造-self"><a href="#递归构造-self" class="headerlink" title="递归构造(self"></a>递归构造(self</h4><h5 id="思路-99"><a href="#思路-99" class="headerlink" title="思路"></a>思路</h5><p>前序的第一个节点可以将中序划分为两部分, 有一个细节是, 我刚开始划分为两部分, 然后分别在递归函数里面传递两部分的首位位置<code>s1, e1, s2, e2</code>, 但是这样数据比较多, 而且边界不容易界定, 所以改成了传递每个部分的首位置和元素的个数, 这样少了一个计算的参数, 不容易出错.</p>
<h5 id="代码-93"><a href="#代码-93" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildTreeHelp(preorder,0,inorder,0,preorder.length);
    }
    public TreeNode buildTreeHelp(int [] preorder, int s1, int[] inorder, int s2, int count) {
        if(count==0) {			//思想,  一定要注意终止条件
            return null;
        }

        TreeNode new_node = new TreeNode(preorder[s1]);
        int index = 0;
        int left_num = 0;               //左侧元素的个数
        int right_num = 0;              //右侧元素的个数, 用于确定
        for (int i = s2; i &lt; s2+count; i++) {
            if(inorder[i] == preorder[s1]) {
                index = i;
                left_num = i - s2;
                right_num = count-1-left_num;
            }

        }
        new_node.left = buildTreeHelp(preorder, s1+1, inorder, s2, left_num);
        new_node.right = buildTreeHelp(preorder, s1+left_num+1, inorder, index+1, right_num);
        return new_node;
    }
}
</code></pre>
<h5 id="复杂度-89"><a href="#复杂度-89" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<pre><code>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
</code></pre>
<h4 id="递归原地算法-self"><a href="#递归原地算法-self" class="headerlink" title="递归原地算法(self"></a>递归原地算法(self</h4><h5 id="思路-100"><a href="#思路-100" class="headerlink" title="思路"></a>思路</h5><p>分各种情况讨论而已.</p>
<h5 id="代码-94"><a href="#代码-94" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }
        else if (root.left == null &amp;&amp; root.right == null) {
            return;
        }else if (root.left == null &amp;&amp; root.right != null) {
            flatten(root.right);
            return;
        }else if (root.left!=null &amp;&amp; root.right == null) {
            flatten(root.left);
            root.right = root.left;
            root.left = null;
            return;
        }else {
            flatten(root.right);
            flatten(root.left);
            TreeNode temp_left = root.left;
            TreeNode temp_node = root.left;
            while(temp_node.right!=null) {
                temp_node = temp_node.right;
            }
            temp_node.right = root.right;
            root.right= temp_left;
            root.left = null;
            return;
        }
    }
}
</code></pre>
<h5 id="代码-95"><a href="#代码-95" class="headerlink" title="代码"></a>代码</h5><p>我的递归写复杂了</p>
<pre><code class="java">class Solution {
    public void flatten(TreeNode root) {
        if(root == null)
            return;
        // 拉直左子树
        flatten(root.left);
        // 拉直右子树
        flatten(root.right);

        // 将左子树末端连接右子树根
        if(root.left !=null){
            TreeNode p = root.left;
            while (p.right != null)
                p = p.right;
            p.right = root.right;
            root.right = root.left; // 右子树接到左子树
        }
        // 左子树置为null
        root.left = null;
    }
}


作者：zhy-20
链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/di-gui-er-cha-shu-zhan-kai-wei-lian-biao-jg0j/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h5 id="复杂度-90"><a href="#复杂度-90" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="前序遍历再构造"><a href="#前序遍历再构造" class="headerlink" title="前序遍历再构造*"></a>前序遍历再构造*</h4><h5 id="思路-101"><a href="#思路-101" class="headerlink" title="思路"></a>思路</h5><p>用List存储前序遍历结果, 再根据前序遍历结果, 但是这种方法不是原地方法</p>
<h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<h4 id="去重排序计数-self"><a href="#去重排序计数-self" class="headerlink" title="去重排序计数(self"></a>去重排序计数(self</h4><h5 id="思路-102"><a href="#思路-102" class="headerlink" title="思路"></a>思路</h5><p>去重排序计数</p>
<p>但是排序就是O(NlogN)了</p>
<h5 id="代码-96"><a href="#代码-96" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int longestConsecutive(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for(int item:nums){
            set.add(item);
        }
        int size = set.size();
        int count = 0;
        int[] new_nums = new int[size];
        for(Integer item:set) {
            new_nums[count++] = item;
        }
        
        Arrays.sort(new_nums);
        
        if(new_nums.length==0) return 0;
        int max_length = 1;
        int length = 1;
        for (int i = 0; i &lt; new_nums.length-1; i++) {
            if(new_nums[i+1] == new_nums[i]+1) {
                length++;
                max_length = Math.max(max_length, length);
            }else {
                length = 1;
            }
        }
        return max_length;
    }
}
</code></pre>
<h5 id="复杂度-91"><a href="#复杂度-91" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(NLogN)$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash*"></a>Hash*</h4><h5 id="思路-103"><a href="#思路-103" class="headerlink" title="思路"></a>思路</h5><p>将数据存储到哈希表中, 再遍历, 如果某个数是开头(没有它的前一个数), 则进内循环得到以它为首的序列的长度, 否则不进内循环.</p>
<h5 id="代码-97"><a href="#代码-97" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int longestConsecutive(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for(int item:nums){
            set.add(item);
        }
        int max_length = 0;
        int length = 1;
        for(int item:set) {
            if (!set.contains(item-1)) {
                int next_item = item+1;
                while(set.contains(next_item)) {
                    next_item++;
                    length++;
                }
                max_length = Math.max(length, max_length);
            }
            length = 1;
        }
        return max_length;
    }
}
</code></pre>
<h5 id="复杂度-92"><a href="#复杂度-92" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h4 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算*"></a>位运算*</h4><h5 id="思路-104"><a href="#思路-104" class="headerlink" title="思路"></a>思路</h5><p>位运算, 异或: 相异为1, 相同为0.</p>
<blockquote>
<p>Java提供的位运算符有：左移( &lt;&lt; )、右移( &gt;&gt; ) 、无符号右移( &gt;&gt;&gt; )  、位与( &amp; ) 、位或( | )、位非( ~ )、位异或( ^ )，除了位非( ~ )是一元操作符外，其它的都是二元操作符。</p>
</blockquote>
<h5 id="代码-98"><a href="#代码-98" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            result = result ^ nums[i];
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-93"><a href="#复杂度-93" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="139-单词拆分-alarm-clock"><a href="#139-单词拆分-alarm-clock" class="headerlink" title="139. 单词拆分:alarm_clock:"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a><span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<pre><code>示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。

示例 3：

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false

 

提示：

    1 &lt;= s.length &lt;= 300
    1 &lt;= wordDict.length &lt;= 1000
    1 &lt;= wordDict[i].length &lt;= 20
    s 和 wordDict[i] 仅有小写英文字母组成
    wordDict 中的所有字符串 互不相同
</code></pre>
<h4 id="用set存储后递归-self-没解决"><a href="#用set存储后递归-self-没解决" class="headerlink" title="用set存储后递归(self, 没解决"></a>用set存储后递归(self, 没解决</h4><h5 id="思路-105"><a href="#思路-105" class="headerlink" title="思路"></a>思路</h5><p>用set存储字典, 然后递归判断, 为了加快速度, 使用字典中字词的最短长度和最长长度.</p>
<p>但是下面的样例会超出时间限制.</p>
<pre><code>"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"
["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]
</code></pre>
<p>因为是递归遍历, 而且<code>aaaaaaa</code>与<code>[a, aa, aaa]</code>有太多次匹配和递归了.</p>
<p>如果有优化的话, 就是将字典中的词典,只存储最小的”字”, 比如[a, aa]只存储[a], 纸样的话下面的代码可以改造为</p>
<pre><code>return wordBreakHelp(s.substring(i), wordDictSet, shortest, longest);
</code></pre>
<h5 id="代码-99"><a href="#代码-99" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        int shortest = 21;
        int longest = 0;
        Set&lt;String&gt; wordDictSet = new HashSet&lt;String&gt;();
        for (int i = 0; i &lt; wordDict.size(); i++) {
            wordDictSet.add(wordDict.get(i));
            shortest = Math.min(wordDict.get(i).length(), shortest);
            longest = Math.max(wordDict.get(i).length(), longest);
        }
        return wordBreakHelp(s, wordDictSet, shortest, longest);
    }
    public boolean wordBreakHelp(String s, Set&lt;String&gt; wordDictSet, int shortest, int longest) {
        boolean flag = false;
        if(s.length() == 0) return true;
        for(int i = shortest; i &lt;= longest; i++) {
            if (s.length() &lt; i) return false;
            if (wordDictSet.contains(s.substring(0,i))) {
                flag = wordBreakHelp(s.substring(i), wordDictSet, shortest, longest);
                if(flag) return true;
            }
        }
        return false;
    }
}
</code></pre>
<h5 id="复杂度-94"><a href="#复杂度-94" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="思想2名称-3"><a href="#思想2名称-3" class="headerlink" title="思想2名称*"></a>思想2名称*</h4><h5 id="思路-106"><a href="#思路-106" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-100"><a href="#代码-100" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-95"><a href="#复杂度-95" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<h4 id="快慢指针-一二两次相遇"><a href="#快慢指针-一二两次相遇" class="headerlink" title="快慢指针+一二两次相遇"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/">快慢指针+一二两次相遇</a></h4><h5 id="思路-107"><a href="#思路-107" class="headerlink" title="思路"></a>思路</h5><blockquote>
<p>总结关键点(注意a是除环外的长度,b是环的长度, n是未知数)</p>
<ul>
<li>1.第一次相遇，slow = nb(是由fast=2slow, fast = slow+nb推出的)</li>
<li>2.a+nb = 入口点</li>
<li>3.slow再走a = 入口 = head走到入口 = a</li>
<li>4.由3得出，起始距离入口 = 第一次相遇位置 + a</li>
</ul>
<p>感觉就是数学公式推导+逻辑结合的一道题</p>
</blockquote>
<h5 id="代码-101"><a href="#代码-101" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public class Solution {
    public ListNode detectCycle(ListNode head) {
        
        ListNode s = head;
        ListNode f = head; 
        while(true) {
            if (s==null || f == null || f.next==null) return null;
            s = s.next;
            f = f.next.next;
            if(s == f) break;
        }
        // f = 2s
        // f = s+nb 快慢指针相遇时走的步数为s的步数+n圈环的步数
        // s = nb   快慢指针相遇时s的步数由前两式子得到为nb
        // 将f置为0, s=nb, 快慢指针再次向前移动, 两者相遇时节点为环的入口.
        f = head;
        while(f!=s) {
            f = f.next;
            s = s.next;
        }
        return s;
    }
}
</code></pre>
<h5 id="复杂度-96"><a href="#复杂度-96" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="修改链表"><a href="#修改链表" class="headerlink" title="修改链表"></a>修改链表</h4><h5 id="思路-108"><a href="#思路-108" class="headerlink" title="思路"></a>思路</h5><p>遍历链表, 将链表的每个节点.next都赋值为temp, 这样就把节点一个一个拆开了(不符合题意), 遇到环的时候就是.next==temp的时候.</p>
<h3 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></h3><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：</p>
<ul>
<li>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</li>
<li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</li>
</ul>
<p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<h4 id="自制双向链表-self"><a href="#自制双向链表-self" class="headerlink" title="自制双向链表(self"></a>自制双向链表(self</h4><h5 id="思路-109"><a href="#思路-109" class="headerlink" title="思路"></a>思路</h5><h5 id="代码-102"><a href="#代码-102" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class BiLinkedNode{
    public BiLinkedNode previous;
    public BiLinkedNode next;
    public int key;
    public int val;
    BiLinkedNode(){
        previous = null;
        next = null;
        val = -1;
    }
    BiLinkedNode(int key, int val){
        previous = null;
        next = null;
        this.key = key;
        this.val = val;
    }
}

class LRUCache {

    private int capacity;
    private int count;
    private BiLinkedNode head;
    private BiLinkedNode tail;
    private Map&lt;Integer, BiLinkedNode&gt; m;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.count = 0;
        this.m = new HashMap&lt;&gt;();
        this.head = new BiLinkedNode();
        this.tail = new BiLinkedNode();
        head.next = tail;				//思想,头节点是假节点.
        tail.previous = head;       	//思想,注意tail是单独的tail
    }
    
    public int get(int key) {
        if(m.containsKey(key)) {
            BiLinkedNode temp = new BiLinkedNode(key, m.get(key).val);
            deleteNode(m.get(key));
            insertLast(temp);
            m.remove(key);
            m.put(key, temp);
            return m.get(key).val;
        }
        else return -1;
    }
    
    public void put(int key, int value) {

        if (m.containsKey(key)==true) {
            deleteNode(m.get(key));
            m.remove(key);
            BiLinkedNode temp = new BiLinkedNode(key, value);
            m.put(key, temp);
            insertLast(temp);
            
        }
        else {
            if (count==capacity) {
                BiLinkedNode temp = new BiLinkedNode(key, value);
                System.out.println("key:"+key+" remove"+head.next.val);
                m.remove(head.next.key);        //这里应该是移除head.next.val对应的key
                deleteFirst();
                m.put(key, temp);
                insertLast(temp);
            }else {
                BiLinkedNode temp = new BiLinkedNode(key, value);
                insertLast(temp);
                m.put(key, temp);
                count+=1;
            }
        }
    }
    public void deleteFirst() {			//语法, 其实可以与下面的合并
        head.next = head.next.next;
        head.next.previous = head;
        return;
    }
    public void deleteNode(BiLinkedNode temp) {
        temp.previous.next = temp.next;
        temp.next.previous = temp.previous;
        return;
    }
    public void insertLast(BiLinkedNode temp) {
        tail.previous.next = temp;
        temp.previous = tail.previous;
        temp.next = tail;
        tail.previous = temp;
        return;
    }
    public void printList() {
        BiLinkedNode node= head.next;
        while(node !=null) {
            System.out.print(node.val+" ");
            node = node.next;
        }
        System.out.println();
        return;
    }
}
</code></pre>
<p>我构造了太多的节点了, 没有弄好数据结构和面向对象化数据结构,导致代码重用性不高, 开销大, 但至少AC了</p>
<h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h3><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<pre><code>输入：head = [4,2,1,3](以链表形式存在)
输出：[1,2,3,4]
</code></pre>
<p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<h4 id="list存储快排后再赋值-self"><a href="#list存储快排后再赋值-self" class="headerlink" title="list存储快排后再赋值(self"></a>list存储快排后再赋值(self</h4><h5 id="思路-110"><a href="#思路-110" class="headerlink" title="思路"></a>思路</h5><p>list存储快排后再赋值给链表</p>
<h5 id="代码-103"><a href="#代码-103" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode sortList(ListNode head) {
        List&lt;Integer&gt; data = new ArrayList&lt;&gt;();
        ListNode p = head;
        while(p != null) {
            data.add(p.val);
            p = p.next;
        }
        Collections.sort(data);
        p = head;
        for(int i = 0; i &lt; data.size(); i++) {
            p.val = data.get(i);
            p = p.next;
        }
        return head;
    }
}
</code></pre>
<h5 id="复杂度-97"><a href="#复杂度-97" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(NLogN)$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="归并-slef"><a href="#归并-slef" class="headerlink" title="归并(slef*"></a>归并(slef*</h4><h5 id="思路-111"><a href="#思路-111" class="headerlink" title="思路"></a>思路</h5><p><img src="D:\pic-bed\img\image-20220310142915943.png" alt="image-20220310142915943"></p>
<p>平均时间为O(NlogN)并且辅助空间为O(1)的只能是归并(对链表排序的最佳方案).</p>
<h5 id="代码-104"><a href="#代码-104" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode sortList(ListNode head) {
        int length = 0;
        ListNode point = head;
        while(point != null) {
            length++;
            point = point.next;
        }
        return sortListHelp(head, length);
    }
    public ListNode sortListHelp(ListNode head, int length) {
        if (length == 1||length == 0) {
            return head;
        } 
        ListNode first_point = head;
        ListNode another_head = head;
        for(int i = 0; i &lt; length - length/2; i++) {
            
            if (i == length-length/2-1) {
                another_head = first_point.next;
                first_point.next = null;
            }else{
                first_point = first_point.next;
            }
            
        }
        ListNode first_head = sortListHelp(head, length - length/2);
        ListNode second_head = sortListHelp(another_head, length/2);
        ListNode new_head = new ListNode();
        ListNode point = new_head;
        while(first_head != null &amp;&amp; second_head != null) {
            if (first_head.val &lt; second_head.val) {
                point.next = first_head;
                first_head = first_head.next;
                point = point.next;
            }else {
                point.next = second_head;
                second_head = second_head.next;
                point = point.next;
            }
        }
        while(first_head!=null) {
            point.next = first_head;
            first_head = first_head.next;
            point = point.next;
            //以上可以简写为point.next = first_head即可.
        }
        while(second_head!=null){
             point.next = second_head;
            second_head = second_head.next;
            point = point.next;
            //以上可以简写为point.next = second_head即可.
        }
        point.next = null;
        return new_head.next;
    }
}
</code></pre>
<h5 id="复杂度-98"><a href="#复杂度-98" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(NlogN)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h3><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<p>子数组 是数组的连续子序列。</p>
<h4 id="以0分割后双向遍历遇到负数个数为奇数时最后一个奇数停止"><a href="#以0分割后双向遍历遇到负数个数为奇数时最后一个奇数停止" class="headerlink" title="以0分割后双向遍历遇到负数个数为奇数时最后一个奇数停止"></a>以0分割后双向遍历遇到负数个数为奇数时最后一个奇数停止</h4><h5 id="思路-112"><a href="#思路-112" class="headerlink" title="思路"></a>思路</h5><p>[1, 2, -3, -4, -5] 的最大值是[1, 2, -3, -4]和[-4, -5]中的一个.</p>
<p>[1, 2, 0, 3, 4]的最大值是[1, 2]和[3, 4]中的一个.</p>
<h5 id="代码-105"><a href="#代码-105" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxProduct(int[] nums) {
        int max = -11;              //结果,-11因为最小是-10
        int s = 0;                  //开始下标预赋值
        int e = nums.length-1;      //结束下标预赋值
        List&lt;List&lt;Integer&gt;&gt; zero_index = new ArrayList&lt;&gt;();
        int zero_count = 0;

        // 求得以0为分割的区间下标起始点和终止点
        for (int i = 0; i &lt; nums.length; i++) {
            List&lt;Integer&gt; pair = new ArrayList&lt;&gt;();
            if(nums[i] == 0) {
                pair.add(s);
                pair.add(i-1);
                zero_index.add(pair);
                s = i+1;
                zero_count++;
            }
            if(i == nums.length-1){
                if(nums[i] == 0){
                    break;
                }else{
                    pair.add(s);
                    pair.add(i);
                    zero_index.add(pair);
                }
            }
        }

        //以0左分割
        for (int i = 0; i &lt; zero_index.size(); i++) {
            int product = maxProductHelp(nums, zero_index.get(i).get(0), zero_index.get(i).get(1));
            max = Math.max(max, product);

        }
        
        //因为0也是子序列, 所以以防[-2, 0]这种样例
        if (zero_count &gt; 0) {
            return Math.max(max, 0);
        }
        return max;
    }
    public int maxProductHelp(int [] nums, int s, int e) {
        int count = 0;      //负数的个数
        
        //统计负数的个数
        for (int i = s; i &lt;= e; i++) {
            if (nums[i] &lt; 0) {
                count++;
            }
        }

        if(e &lt;= s) return nums[s];      //如果是一个数则直接返回

        if(count%2 == 0) {              //如果负数时偶数则直接乘积返回
            int result = 1;
            for(int i = s; i &lt;= e; i++) {
                result = result * nums[i];
            }
            return result;
        }

        //要么是从左往右相乘遇到最后一个负数停止的积
        //要么是从右往左相乘遇到最后一个负数停止的积
        int count1 = 0;
        int product1 = 1;

        int count2 = 0;
        int product2 = 1;
        for(int i = s; i &lt;= e; i++) {  
            if(nums[i] &lt; 0) count1++;
            if(count1 == count) {
                break;
            }
            product1 = product1 * nums[i];
        }

        for(int i = e; i &gt;= s; i--) {
            if(nums[i] &lt; 0) count2++;
            if(count2 == count){
                break;
            }
            product2 = product2 * nums[i];
        }
        return Math.max(product1, product2);
    }
}
</code></pre>
<h5 id="复杂度-99"><a href="#复杂度-99" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="动态规划-alarm-clock"><a href="#动态规划-alarm-clock" class="headerlink" title="动态规划:alarm_clock:"></a>动态规划<span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><h5 id="思路-113"><a href="#思路-113" class="headerlink" title="思路"></a>思路</h5><p>动态规划方程</p>
<pre><code>maxF[i] = Math.max(Math.max(maxF[i-1]*nums[i], minF[i-1]*nums[i]), nums[i]);
minF[i] = Math.min(Math.min(maxF[i-1]*nums[i], minF[i-1]*nums[i]), nums[i]);
</code></pre>
<h5 id="代码-106"><a href="#代码-106" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxProduct(int[] nums) {
        int length = nums.length;
        int max = nums[0];
        int[] maxF = new int[length];
        int[] minF = new int[length];
        if(length == 1) return nums[0];
        System.arraycopy(nums, 0, maxF, 0, length);
        System.arraycopy(nums, 0, minF, 0, length);
        for(int i = 1; i &lt; length; i++) {
            maxF[i] = Math.max(Math.max(maxF[i-1]*nums[i], minF[i-1]*nums[i]), nums[i]);
            minF[i] = Math.min(Math.min(maxF[i-1]*nums[i], minF[i-1]*nums[i]), nums[i]);
        }
        for(int i = 0; i &lt; length; i++) {
            max = Math.max(maxF[i], max);
        }
        return max;
    }
}
</code></pre>
<h5 id="复杂度-100"><a href="#复杂度-100" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h3><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 MinStack 类:</p>
<pre><code>MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。
</code></pre>
<h4 id="一个数字栈一个最小数字栈-self"><a href="#一个数字栈一个最小数字栈-self" class="headerlink" title="一个数字栈一个最小数字栈(self"></a>一个数字栈一个最小数字栈(self</h4><h5 id="思路-114"><a href="#思路-114" class="headerlink" title="思路"></a>思路</h5><p>本来想用优先队列存储最小元素的, 但是发现无法以O(1)在pop的时候也删除最小元素, 所以想到了两个栈, 以前数据结构时作过.</p>
<h5 id="代码-107"><a href="#代码-107" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class MinStack {
    private List&lt;Integer&gt; minStack;
    private int count;
    private List&lt;Integer&gt; numStack;
    public MinStack() {
        numStack = new ArrayList&lt;&gt;();
        minStack = new ArrayList&lt;&gt;();
        count = 0;
    }
    
    public void push(int val) {
        numStack.add(val);
        if (count == 0) {
            minStack.add(val);
        }else {
            int min = this.getMin();
            if(min &lt; val) {
                minStack.add(min);
            }else{
                minStack.add(val);
            }
        }
        count++;
    }
    
    public void pop() {
        numStack.remove(count-1);
        minStack.remove(count-1);
        count--;
    }
    
    public int top() {
        return numStack.get(count-1);

    }
    
    public int getMin() {
        return minStack.get(count-1);
    }
}
</code></pre>
<h5 id="复杂度-101"><a href="#复杂度-101" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="自定义pair链表存储"><a href="#自定义pair链表存储" class="headerlink" title="自定义pair链表存储*"></a>自定义pair链表存储*</h4><h5 id="思路-115"><a href="#思路-115" class="headerlink" title="思路"></a>思路</h5><p>pair存储数字和对应的最小数字</p>
<h5 id="代码-108"><a href="#代码-108" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class MinStack {
    private Node head;
    
    public void push(int x) {
        if(head == null) 
            head = new Node(x, x);
        else 
            head = new Node(x, Math.min(x, head.min), head);
    }

    public void pop() {
        head = head.next;
    }

    public int top() {
        return head.val;
    }

    public int getMin() {
        return head.min;
    }
    
    private class Node {
        int val;
        int min;
        Node next;
        
        private Node(int val, int min) {
            this(val, min, null);
        }
        
        private Node(int val, int min, Node next) {
            this.val = val;
            this.min = min;
            this.next = next;
        }
    }
}
</code></pre>
<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<h4 id="指针法-self"><a href="#指针法-self" class="headerlink" title="指针法(self"></a>指针法(self</h4><h5 id="思路-116"><a href="#思路-116" class="headerlink" title="思路"></a>思路</h5><p>让长的链表先移动Math.abs(LengthA-LengB), 然后两个一起移动, 移动到末尾时还没有相等则为null, 否则返回相同的节点.</p>
<h5 id="代码-109"><a href="#代码-109" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        int lengthA = getLength(headA);
        int lengthB = getLength(headB);
        ListNode longHead = lengthA &gt; lengthB ? headA:headB;
        ListNode shortHead = lengthA &gt; lengthB ? headB:headA;
        ListNode newLongHead = move(longHead, Math.abs(lengthA-lengthB));
        for (int i = 0; i &lt; Math.min(lengthA, lengthB); i++) {
            if(newLongHead == null || shortHead ==null) return null;
            else if (newLongHead == shortHead) return newLongHead;
            newLongHead = move(newLongHead, 1);
            shortHead = move(shortHead, 1);
        }
        return null;
    }
    public ListNode move(ListNode head, int step){
        ListNode node = head;
        for(int i = 0; i &lt; step; i++) {
            node = node.next;
        }
        return node;
    }
    public int getLength(ListNode head){
        int length = 0;
        ListNode node = head;
        while(node != null){
            length++;
            node = node.next;
        }
        return length;
    }
    public void printHead(ListNode head) {
        ListNode node = head;
        while(node != null) {
            System.out.print(node.val);
            node = node.next;
        }
        System.out.println();
    }
}
</code></pre>
<h5 id="复杂度-102"><a href="#复杂度-102" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M+N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="双指针优雅永不过时"><a href="#双指针优雅永不过时" class="headerlink" title="双指针优雅永不过时*"></a>双指针优雅永不过时*</h4><h5 id="思路-117"><a href="#思路-117" class="headerlink" title="思路"></a>思路</h5><p>让两个指针移动, 谁移动到末尾就指向另一个链表的头部, 这样的话等两个指针各移动一次到末尾之后就长度相等了, 抹平了不相等的那一部分.</p>
<h5 id="代码-110"><a href="#代码-110" class="headerlink" title="代码"></a>代码</h5><pre><code>public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode pA = headA, pB = headB;
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}


作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h5 id="复杂度-103"><a href="#复杂度-103" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M+N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></h3><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h4 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h4><h5 id="思路-118"><a href="#思路-118" class="headerlink" title="思路"></a>思路</h5><p>遇到相同的计数+1, 否则计数-1, 如果计数为0则换个数字.</p>
<h5 id="代码-111"><a href="#代码-111" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        int num = nums[0];
        for(int i = 0; i &lt; nums.length; i++){
            if(count == 0) {
                num = nums[i];
                count++;
            }else {
                if (nums[i] != num) {
                    count--;
                }else{
                    count++;
                }
            }
        }
        return num;
    }
}
</code></pre>
<h5 id="复杂度-104"><a href="#复杂度-104" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h4 id="深度遍历-self"><a href="#深度遍历-self" class="headerlink" title="深度遍历(self"></a>深度遍历(self</h4><h5 id="思路-119"><a href="#思路-119" class="headerlink" title="思路"></a>思路</h5><p>用标记数组先标记海洋为访问过, 然后遍历每一个陆地, 将陆地的连片岛屿进行标记为访问过.</p>
<p>遍历每一个陆地, 如果没有访问过就数字+1</p>
<h5 id="代码-112"><a href="#代码-112" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    private int[][] bias = new int[][]{{-1,0},{+1,0},{0,-1},{0,+1}};
    public int numIslands(char[][] grid) {
        boolean flag = false;
        int[][] visited = new int[grid.length][grid[0].length];
        int num = 0;
        for(int i = 0; i &lt; grid.length; i++) {
            for (int j = 0; j &lt; grid[0].length; j++) {
                if(grid[i][j] == '0') {
                    visited[i][j] = 1;
                }
            }
        }
        for(int i = 0; i &lt; grid.length; i++) {
            for (int j = 0; j &lt; grid[0].length; j++) {
                if (visited[i][j] == 0) {
                    num++;
                    numIslandsHelp(grid, visited, i, j);
                }
            }
        }
        return num;
    }
    public void numIslandsHelp(char[][] grid, int[][]visited, int m, int n){
    
        if(m &lt; 0 || m &gt;= grid.length || n &lt; 0 || n &gt;= grid[0].length) {
            return;
        }
        if(visited[m][n] == 1) {
            return; 
        }
        visited[m][n] = 1;
        for(int i = 0;i &lt; 4; i++) {
            int x = m+bias[i][0];
            int y = n+bias[i][1];
            numIslandsHelp(grid, visited, x, y);  
        }
        return;
    }
}
</code></pre>
<h5 id="复杂度-105"><a href="#复杂度-105" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(M*N)$</li>
</ul>
<h3 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h3><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<pre><code>Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。
</code></pre>
<h4 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h4><h5 id="思路-120"><a href="#思路-120" class="headerlink" title="思路"></a>思路</h5><p>前缀树的节点是这样的:</p>
<pre><code class="java">private class TrieNode {                //语法
    boolean isKey;
    TrieNode[] children;
    TrieNode(){
        isKey = false;
        children = new TrieNode[26];         //思想
    }
}
</code></pre>
<p>如果一个孩子不存在, 是这样判断的(也就是TrieNode[]的默认值是null):</p>
<pre><code> if(node.children[pos]==null)
</code></pre>
<h5 id="代码-113"><a href="#代码-113" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Trie {
    private class TrieNode {                //语法
    boolean isKey;
    TrieNode[] children;
    TrieNode(){
        isKey = false;
        children = new TrieNode[26];         //思想
    }
    }
    private TrieNode root;
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode node = root;
        for (int i = 0; i &lt; word.length(); i++) {
            int pos = word.charAt(i)-'a';
            if(node.children[pos]==null){       //思想
                TrieNode new_children = new TrieNode();
                node.children[pos] = new_children;
                node = node.children[pos];      //思想,
            }
            else{
                node = node.children[pos];
            }
        }
        node.isKey = true;
        return;
    }
    
    public boolean search(String word) {
        TrieNode node = root;
        for (int i = 0; i &lt; word.length(); i++) {
            int pos = word.charAt(i)-'a';
            if(node.children[pos]==null){
                return false;
            }else{
                node = node.children[pos];
            }
        }
        return node.isKey;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (int i = 0; i &lt; prefix.length(); i++) {
            int pos = prefix.charAt(i)-'a';
            if(node.children[pos]==null){
                return false;
            }else{
                node = node.children[pos];
            }
        }
        return true;
    }
}
</code></pre>
<h3 id="215-数组中的第K个最大元素-alarm-clock"><a href="#215-数组中的第K个最大元素-alarm-clock" class="headerlink" title="215. 数组中的第K个最大元素:alarm_clock:"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a><span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<h4 id="调用库函数-self"><a href="#调用库函数-self" class="headerlink" title="调用库函数(self"></a>调用库函数(self</h4><h5 id="代码-114"><a href="#代码-114" class="headerlink" title="代码"></a>代码</h5><pre><code>class Solution {
    public int findKthLargest(int[] nums, int k) {
       Arrays.sort(nums);				//语法
       return nums[nums.length-k]; 
    }
}
</code></pre>
<h5 id="复杂度-106"><a href="#复杂度-106" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="思想2名称-4"><a href="#思想2名称-4" class="headerlink" title="思想2名称*"></a>思想2名称*</h4><h5 id="思路-121"><a href="#思路-121" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-115"><a href="#代码-115" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-107"><a href="#复杂度-107" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></h3><p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。</p>
<h4 id="动态规划-self-5"><a href="#动态规划-self-5" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-122"><a href="#思路-122" class="headerlink" title="思路"></a>思路</h5><p>$dp[i][j]$代表该位置为正方形右下角的最大边长.<br>$$<br>dp[i][j] = 0 if(matrix[i][j] == 0)\<br>dp[i][j] = 1+[1,2,m,..dp[i-1][j-1]]中最大的m使得matrix[i-(1..m)][j]和matrix[i][j-(1..m)]都是1.<br>$$</p>
<h5 id="代码-116"><a href="#代码-116" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maximalSquare(char[][] matrix) {
        int rowNum = matrix.length;
        int colNum = matrix[0].length;
        int[][] flag = new int[rowNum][colNum];
        int max = 0;        //最大边长
        for(int i = 0; i &lt; rowNum; i++) {
            for(int j = 0; j &lt; colNum; j++) {
                flag[i][j] = matrix[i][j]-'0';
            }
        }
        

        for(int i = 1; i &lt; rowNum; i++) {
            for(int j = 1; j &lt; colNum; j++) {
                int last = flag[i-1][j-1];	//以左上角的那个元素为正方形右下角的最大边长
                for(int k = last; k &gt;= 1; k--) {
                    //从高往低刷
                    boolean tag = true;		//i行j列的元素是否都&gt;0(表示可以是边长)
                    for(int m = 1; m &lt;= k; m++) {
                        tag = tag &amp;&amp; flag[i][j-m]&gt;0?true:false;
                        tag = tag &amp;&amp; flag[i-m][j]&gt;0?true:false;
                    }
                    if(tag == true &amp;&amp; flag[i][j] == 1) {
                        flag[i][j] += k;
                        break;				//如果已经组成正方形则break,防止正方形边长缩小
                    }
                }
                
            }
        }
        for(int i = 0; i &lt; rowNum; i++) {
            for (int j = 0; j &lt; colNum; j++) {
                max = Math.max(max, flag[i][j]);
            }
        }
        return max*max;
    }
}
</code></pre>
<h5 id="复杂度-108"><a href="#复杂度-108" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(N^2)$</li>
</ul>
<h4 id="动态规划-5"><a href="#动态规划-5" class="headerlink" title="动态规划*"></a>动态规划*</h4><h5 id="思路-123"><a href="#思路-123" class="headerlink" title="思路"></a>思路</h5><blockquote>
<pre><code class="java">        dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为: 
        dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);
</code></pre>
</blockquote>
<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<h4 id="折半反转对比-self"><a href="#折半反转对比-self" class="headerlink" title="折半反转对比(self"></a>折半反转对比(self</h4><h5 id="思路-124"><a href="#思路-124" class="headerlink" title="思路"></a>思路</h5><p>折半反转对比</p>
<h5 id="代码-117"><a href="#代码-117" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        int length = 0;
        ListNode node = head;
        ListNode head2;
        ListNode new_head = new ListNode();
        //求链表长度
        while(node!=null) {
            length++;
            node = node.next;
        }
        node = head;
        //将链表对半
        for(int i = 0; i &lt; (length+1)/2-1; i++) {
            node = node.next;
        }
        head2 = node.next;
        node.next = null;

        
        //转置链表
        while(head2 != null) {
            ListNode temp = head2.next;
            head2.next = new_head.next;
            new_head.next = head2;
            head2 = temp;
        }
        new_head = new_head.next;

        //判断饭转后的链表的一半是否和另一半相同
        for(int i = 0; i &lt; length/2; i++) {
            if(head.val == new_head.val) {
                head = head.next;
                new_head = new_head.next;
                continue;
            }
            else return false;
        }
        return true;
        
    }
    
}
</code></pre>
<h5 id="复杂度-109"><a href="#复杂度-109" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="快慢指针-alarm-clock"><a href="#快慢指针-alarm-clock" class="headerlink" title="快慢指针*(:alarm_clock:"></a>快慢指针*(<span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><h5 id="思路-125"><a href="#思路-125" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-118"><a href="#代码-118" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-110"><a href="#复杂度-110" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="236-二叉树的最近公共祖先-LCA"><a href="#236-二叉树的最近公共祖先-LCA" class="headerlink" title="236. 二叉树的最近公共祖先(LCA)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>(LCA)</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><h5 id="思路-126"><a href="#思路-126" class="headerlink" title="思路"></a>思路</h5><p>递归函数:</p>
<ul>
<li>返回值: 返回root节点下最近的含有p或者q的节点</li>
<li>终止条件: <ul>
<li>如果root是p或者q返回root, 否则(root==null或者其他情况)返回null</li>
<li>后序遍历子树</li>
<li>如果左孩子和右孩子中都有p或者q的父节点的话, 返回root(因为是后序遍历, 自底向上遍历, 所以第一次返回的必然是最近公共祖先), 否则只返回含有p或者q的节点</li>
</ul>
</li>
</ul>
<h5 id="代码-119"><a href="#代码-119" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //递归函数:如果root是p或q的最近父节点,返回root,否则返回null
        if(root == p || root == q || root == null) return root;

        TreeNode left_father = lowestCommonAncestor(root.left, p, q);
        TreeNode right_father = lowestCommonAncestor(root.right, p, q);

        //想法, 后序遍历
        if (left_father!= null &amp;&amp; right_father != null) {
            //如果左右孩子都有p或者q, 则root是最近父节点
            return root;
        }else if (left_father != null) {
            //如果左孩子下面有节点是p或q的父节点(此时右孩子不是p或者q的父节点),返回该节点
            return left_father;
        }else if (right_father != null) {
            return right_father;
        }else{
            return null;
        }
    }
}
</code></pre>
<h5 id="复杂度-111"><a href="#复杂度-111" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$(每个节点被访问一次)</li>
<li>空间: $O(N)$(最差情况下为一条单链)</li>
</ul>
<h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h3><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p>
<p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p>
<p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<pre><code>示例 1:

输入: nums = [1,2,3,4]
输出: [24,12,8,6]

示例 2:

输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
</code></pre>
<p><strong>进阶：</strong>你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。</p>
<h4 id="左累乘右累乘再相乘"><a href="#左累乘右累乘再相乘" class="headerlink" title="左累乘右累乘再相乘"></a>左累乘右累乘再相乘</h4><h5 id="思路-127"><a href="#思路-127" class="headerlink" title="思路"></a>思路</h5><p>用两个数组存储某位的左累乘和右累乘的结果, 比如</p>
<pre><code>[1,    2,   3,   4]
[1 	  ,1,  1*2, 1*2*3]
[2*3*4,3*4, 4,  1]
</code></pre>
<p>而在计算下面这两个数组的时候是可以优化为O(1)的, 因为是累乘.</p>
<p>注意:</p>
<ul>
<li>O(N)算法可以扫描多遍</li>
<li>O(1)算法用累乘</li>
</ul>
<h5 id="代码-120"><a href="#代码-120" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] result = new int[nums.length];
        int p = 1;      //存储某个数左边的连乘结果
        int q = 1;      //存储某个数右乘的连乘结果

        result[0] = 1;
        for(int i = 1; i &lt; nums.length; i++) {
            p = p*nums[i-1];
            result[i] = p;
        }
        for(int i = nums.length-2; i &gt;= 0; i--) {
            q = q*nums[i+1];
            result[i] = result[i] * q;
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-112"><a href="#复杂度-112" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h3><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<pre><code>每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
</code></pre>
<h4 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h4><h5 id="思路-128"><a href="#思路-128" class="headerlink" title="思路"></a>思路</h5><p>逐个遍历比较</p>
<h5 id="代码-121"><a href="#代码-121" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for (int i = 0; i &lt; matrix.length; i++) {
            for(int j = 0; j &lt; matrix[0].length; j++) {
                if (matrix[i][j] == target) return true;
            }
        }
        return false;
    }

}
</code></pre>
<h5 id="复杂度-113"><a href="#复杂度-113" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="对每行二分查找"><a href="#对每行二分查找" class="headerlink" title="对每行二分查找"></a>对每行二分查找</h4><h5 id="思路-129"><a href="#思路-129" class="headerlink" title="思路"></a>思路</h5><p>对每行使用二分查找</p>
<h5 id="代码-122"><a href="#代码-122" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for (int[]nums:matrix){
            int result = search(nums, target);
            if (result != -1) return true;
        }
        return false;
    }
    public int search(int[] nums, int target){
        int low = 0;
        int high = nums.length-1;
        while(low &lt;= high) {
            int mid = (high-low)/2+low;
            int num = nums[mid];
            if (num == target){
                return mid;
            }else if (num&gt; target){
                high = mid-1;
            }else{
                low = mid + 1;
            }
        }
        return -1;
    }

}
</code></pre>
<h5 id="复杂度-114"><a href="#复杂度-114" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N*log^N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h3><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<h4 id="动态规划-6"><a href="#动态规划-6" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="思路-130"><a href="#思路-130" class="headerlink" title="思路"></a>思路</h5><p>动态规划方程:<br>$$<br>f[i] = 1 + min(f_{j=1}^\sqrt[2]i[i-j*j])<br>$$<br>含义是: </p>
<p>正如i的完全平方数的最少数量等于1+比它小的能组成它的数字的完全平方数的最小数量.</p>
<h5 id="代码-123"><a href="#代码-123" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int numSquares(int n) {
        int []f = new int[n+1];
        f[0] = 0;
        for(int i = 1; i &lt;= n; i++){
            int min = Integer.MAX_VALUE;
            for(int j = 1; j * j &lt;= i; j++){
                min = Math.min(min, f[i-j*j]);		//思想
            }
            f[i] = min+1;
        }
        return f[n];
    }
}
</code></pre>
<h5 id="复杂度-115"><a href="#复杂度-115" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N*\sqrt[2]{N}$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h4><h5 id="思路-131"><a href="#思路-131" class="headerlink" title="思路"></a>思路</h5><p>四平方和定理: 一个数最多能表示为4个平方数之和, 如果恰好为4个平方数之和, 那必然满足$n=4^i+(8j+7)$.</p>
<p>那么一个数的平方数只有以下可能:</p>
<ul>
<li>4 : 满足$n=4^i+(8j+7)$.</li>
<li>1: 满足$n=i*i$</li>
<li>2: 满足$n=i<em>i + j</em>j$</li>
<li>3: 不满足以上条件</li>
</ul>
<h5 id="代码-124"><a href="#代码-124" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int numSquares(int n) {
        if(satisfy4(n)) return 4;
        else if(satisfy1(n)) return 1;
        
        for(int i = 0; i*i&lt;n; i++){
            if(satisfy1(n-i*i)) return 2;
        }
        return 3;
    }
    boolean satisfy4(int n){			//思想
        while(n%4==0){
            n = n/4;
        }
        return n%8==7;
    }
    boolean satisfy1(int n){			//思想
        int r = (int)Math.sqrt(n);
        return r*r == n;
    }

}
</code></pre>
<h5 id="复杂度-116"><a href="#复杂度-116" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(\sqrt[2]{N})$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<h4 id="将非0覆盖到数组前面后面赋值0-self"><a href="#将非0覆盖到数组前面后面赋值0-self" class="headerlink" title="将非0覆盖到数组前面后面赋值0(self"></a>将非0覆盖到数组前面后面赋值0(self</h4><h5 id="思路-132"><a href="#思路-132" class="headerlink" title="思路"></a>思路</h5><p>第一次遍历计算0的个数, 然后第二次遍历将非0元素覆盖到前面, 后面再赋值count个0到数组后面</p>
<blockquote>
<p>覆盖法的优点是每个都要赋值一次，但是原本结果是0的位置全部要写一次。 交换法虽然每次代价是赋值2次（a=b;b=0;），但是后面都是0的位置可以不用再操作了。</p>
</blockquote>
<h5 id="代码-125"><a href="#代码-125" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void moveZeroes(int[] nums) {
        int start = 0;
        int count = 0;
        //计算0元素个数
        for(int i = 0; i &lt; nums.length; i++) {
            if(nums[i] == 0) count++;
        }
        for(int i = 0; i &lt; nums.length; i++) {
            if (nums[i] != 0) nums[start++] = nums[i];
            if (i &gt;= nums.length-count) nums[i] = 0;
        }
        return;
    }
}
</code></pre>
<h5 id="复杂度-117"><a href="#复杂度-117" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="左右指针-alarm-clock"><a href="#左右指针-alarm-clock" class="headerlink" title="左右指针:alarm_clock:"></a>左右指针<span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><h5 id="思路-133"><a href="#思路-133" class="headerlink" title="思路"></a>思路</h5><h5 id="代码-126"><a href="#代码-126" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0;
        int right = 0;
        while(right &lt; nums.length) {
            if (nums[right] != 0) {
                int temp = nums[right];
                nums[right] = nums[left];
                nums[left] = temp;
                left++;
            }
            right++;
        }
        return;
    }
}
</code></pre>
<h5 id="复杂度-118"><a href="#复杂度-118" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h3><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>
<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
<h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4><h5 id="思路-134"><a href="#思路-134" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-127"><a href="#代码-127" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int findDuplicate(int[] nums) {
        int fast = 0;
        int low = 0;
        do{
            fast = nums[fast];
            fast = nums[fast];
            low = nums[low];
        }while(fast!=low);				//思想, 先判断有无环
        
        low = 0;						//思想,将慢指针置为起始点,然后快慢再一起移动, 再相遇时就是环的入口
        while(low!=fast){
            low = nums[low];
            fast = nums[fast];
        }
        return low;
    }
}
</code></pre>
<h5 id="复杂度-119"><a href="#复杂度-119" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$「Floyd 判圈算法」时间复杂度为线性的时间复杂度。</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<h4 id="动态规划-7"><a href="#动态规划-7" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="思路-135"><a href="#思路-135" class="headerlink" title="思路"></a>思路</h5><p>动态规划方程:</p>
<p>f[i]表示以第i个位置结尾的递增子序列的长度, 就等于扫描一遍该位置前面的f[j], 如果nums[i] &gt; nums[j]的话, f[i] = f[j]+1之间的最大值<br>$$<br>f[i] = Math.max(f_{j=1}^{i-1}[j]+1) if(nums[i]&gt;nums[j])<br>$$</p>
<h5 id="代码-128"><a href="#代码-128" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int lengthOfLIS(int[] nums) {
        int []f = new int[nums.length];
        f[0] = 1;
        for(int i = 1; i &lt; nums.length; i++){
            f[i] = 1;
            for(int j = 0; j &lt; i; j++){
                if(nums[i] &gt; nums[j]) {
                    f[i] = Math.max(f[j]+1,f[i]);		//思想, 递归方程
                }
            }
        }
        int result = Integer.MIN_VALUE;
        for(int i = 0; i&lt;nums.length;i++){				//思想, 是所有中最大的那个, 并不一定是最后的那个
            result = Math.max(f[i],result);
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-120"><a href="#复杂度-120" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h3><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<pre><code>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
</code></pre>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h4 id="动态规划-8"><a href="#动态规划-8" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="思路-136"><a href="#思路-136" class="headerlink" title="思路"></a>思路</h5><p>第i天有这么几种可能性f[i], f[i]记为净收益:</p>
<ul>
<li>现在手上持有股票<ul>
<li>这种状态只能由第i-1天持有股票或者第i-1天可以购买股票时净收益减去今天购买股票花费转化而来</li>
<li>$$f[i][0] = max( f[i-1][0], f[i-1][2]-prices[i])$$</li>
</ul>
</li>
<li>现在处于冷冻期<ul>
<li>这种状态只能由第$$i-1$$天持有股票转化而来</li>
<li>$$f[i][1] = f[i-1][1]+prices[i]$$</li>
</ul>
</li>
<li>现在既不持有股票也不处于冷冻期(可以购买股票<ul>
<li>这种情况由第$$i-1$$天为冷冻期或者第$$i-1天$$可以购买股票转换而来</li>
<li>$$f[i][2] = Math.max(f[i-1][1], f[i-1][2])$$</li>
</ul>
</li>
</ul>
<h5 id="代码-129"><a href="#代码-129" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxProfit(int[] prices) {
        int[][] f= new int[prices.length][3];
        f[0][0] = -prices[0];       //持有股票的净收益
        f[0][1] = 0;                //冷冻期的净收益
        f[0][2] = 0;                //可以购买股票的净收益

        for(int i = 1; i &lt; prices.length; i++){
            f[i][0] = Math.max(f[i-1][0], f[i-1][2]-prices[i]);
            f[i][1] = f[i-1][0]+prices[i];
            f[i][2] = Math.max(f[i-1][1], f[i-1][2]);
        }
        return Math.max(f[prices.length-1][1],f[prices.length-1][2]);
    }
}
</code></pre>
<h5 id="复杂度-121"><a href="#复杂度-121" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h3><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
</code></pre>
<h4 id="从上往下记忆化搜索"><a href="#从上往下记忆化搜索" class="headerlink" title="从上往下记忆化搜索"></a>从上往下记忆化搜索</h4><h5 id="思路-137"><a href="#思路-137" class="headerlink" title="思路"></a>思路</h5><p>$$<br>F[n] = \min_{i=0…n-1}(F[n-c_i])+1<br>\<br>F[0] = 0<br>\<br>F[负数] = -1<br>$$</p>
<h5 id="代码-130"><a href="#代码-130" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount &lt; 1) {
            return 0;
        }
        return coinChange(coins, amount, new int[amount]);
    }
    private int coinChange(int[] coins, int rem, int[] f) {    //返回
        if(rem &lt; 0) {
            return -1;      //表示组成不了
        }

        if(rem == 0) {
            return 0;       //表示恰好组成
        }

        if(f[rem-1] != 0) { //记忆化搜索
            return f[rem-1];
        }

        int min = Integer.MAX_VALUE;
        for(int coin:coins) {
            int res = coinChange(coins, rem-coin, f);
            if(res &gt;= 0 &amp;&amp; res &lt; min) {     //能组成并且比其他的方案需要硬币小
                min = res + 1;
            }
            
        }
        f[rem-1] = (min==Integer.MAX_VALUE)?-1:min;
        return f[rem-1];
    }
}
</code></pre>
<h5 id="复杂度-122"><a href="#复杂度-122" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(Sn)$, S为状态数, n为面值数, 每个状态遍历面值计算一遍</li>
<li>空间: $O(S)$, S的数组来存储计算出来的答案</li>
</ul>
<h4 id="动态规划-9"><a href="#动态规划-9" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="思路-138"><a href="#思路-138" class="headerlink" title="思路"></a>思路</h5><p>$$<br>F[0] = 0;<br>f[S] = \min_{i=0,n-1}(f[S-coin_i])+1<br>$$</p>
<h5 id="代码-131"><a href="#代码-131" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount+1;
        int []f = new int[amount+1];
        Arrays.fill(f, max);
        f[0] = 0;
        for(int i = 1 ; i &lt;= amount; i++) {
            int min = max;
            for(int j = 0; j &lt; coins.length; j++){
                int res = (i-coins[j])&lt;0 ?max:f[i-coins[j]]+ 1;
                if(res&lt;min){
                    min = res;
                }
            }
            f[i] = min;
        }
        if(f[amount] &gt;= max) return -1;
        else return f[amount];
    }

}
</code></pre>
<h5 id="复杂度-123"><a href="#复杂度-123" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(Sn)$</li>
<li>空间: $O(S)$</li>
</ul>
<h3 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a></h3><p>给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 2
输出：[0,1,1]
解释：
0 --&gt; 0
1 --&gt; 1
2 --&gt; 10
</code></pre>
<h4 id="动态规划-self-6"><a href="#动态规划-self-6" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-139"><a href="#思路-139" class="headerlink" title="思路"></a>思路</h5><p>动态规划方程:<br>$$<br>ans[i] = ans[i&gt;&gt;1]+(i%2==1)?1:0<br>$$</p>
<h5 id="代码-132"><a href="#代码-132" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] countBits(int n) {
        int[]ans = new int[n+1];
        if(n &lt; 1) return ans;
        ans[0] = 0;
        for(int i = 1; i &lt;= n; i++){
            int num = i;
            if(i % 2 == 0){
                ans[i] = ans[num&gt;&gt;1];				//语法
            }else{
                ans[i] = ans[num&gt;&gt;1]+1;
            }
        }
        return ans;
    }
}
</code></pre>
<h5 id="复杂度-124"><a href="#复杂度-124" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<h4 id="哈希表-优先队列-堆"><a href="#哈希表-优先队列-堆" class="headerlink" title="哈希表+优先队列(堆)"></a>哈希表+优先队列(堆)</h4><h5 id="思路-140"><a href="#思路-140" class="headerlink" title="思路"></a>思路</h5><p>哈希表计数, 优先队列为小顶堆存储计数结果, 如果队列长度小于k, 则直接入队, 队列长度大于k, 出堆顶然后入队.</p>
<h5 id="代码-133"><a href="#代码-133" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;();
        for(int i = 0; i &lt; nums.length; i++){
            m.put(nums[i], m.getOrDefault(nums[i],0)+1);
        }

        //语法
        PriorityQueue&lt;int[]&gt; queue= new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;(){
            public int compare(int[] a, int [] b){
                return a[1] - b[1];
            }
        });

        for(Map.Entry&lt;Integer, Integer&gt; entry : m.entrySet()){  //语法
            int num = entry.getKey();
            int count = entry.getValue();
            if(queue.size() == k) {                 //思想
                if(queue.peek()[1] &lt; count){
                    queue.poll();
                    queue.offer(new int[]{num, count});
                }
            } else {
                queue.offer(new int[]{num, count});
            }
        }
        int []result = new int[k];
        for (int i = 0; i &lt; k; i++) {
            result[i] = queue.poll()[0];
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-125"><a href="#复杂度-125" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(Nlogk)$k为堆的节点数目</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<pre><code>示例 1：

输入：s = "3[a]2[bc]"
输出："aaabcbc"
</code></pre>
<p>提示：</p>
<pre><code>1 &lt;= s.length &lt;= 30
s 由小写英文字母、数字和方括号 '[]' 组成
s 保证是一个 有效 的输入。
s 中所有整数的取值范围为 [1, 300] 
</code></pre>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h5 id="思路-141"><a href="#思路-141" class="headerlink" title="思路"></a>思路</h5><ul>
<li>遇到<code>]</code><ul>
<li>弹出栈内字符直到遇到<code>[</code>, 得到<code>[</code>前面的数字, 然后将重复的字符串再入栈</li>
</ul>
</li>
<li>其他<ul>
<li>入栈</li>
</ul>
</li>
</ul>
<h5 id="代码-134"><a href="#代码-134" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public String decodeString(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for(int i = 0; i &lt; s.length(); i++) {
            if(s.charAt(i) != ']') {
                stack.push(s.charAt(i));
            }else{
                char topChar;
                String str="";
                while(stack.peek() != '[') {
                    topChar = stack.pop();
                    str = topChar+str;
                }
                stack.pop();            //弹出'['
                String numString = "";  //数组为多位数
                while(!stack.empty() &amp;&amp; stack.peek() &gt;= '0' &amp;&amp; stack.peek() &lt;= '9') {
                    topChar = stack.pop();
                    numString = topChar + numString;
                }

                int count = Integer.parseInt(numString);
                for(int j = 0; j &lt; count; j++) {
                    for(int k = 0; k &lt; str.length(); k++) {
                        stack.push(str.charAt(k));
                    }
                }
            }
        }

        List&lt;Character&gt; resultList = new ArrayList&lt;&gt;(stack);
        String result = "";
        for(Character c:resultList) {
            result+=c;
        }
        return result;
    }
    
}
</code></pre>
<h5 id="复杂度-126"><a href="#复杂度-126" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(S)$ S为解码后的字符串长度</li>
<li>空间: $O(S)$</li>
</ul>
<h2 id="动态规划-10"><a href="#动态规划-10" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h3><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p>
<p>给你 n ，请计算 F(n) 。</p>
<h4 id="动态规划-11"><a href="#动态规划-11" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="思路-142"><a href="#思路-142" class="headerlink" title="思路"></a>思路</h5><p>使用状态转移方程计算.</p>
<h5 id="代码-135"><a href="#代码-135" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">    public int fib(int n) {
        return fib1(n);
    }
    int fib1(int n) {
        int []f = new int[n+1];
        for(int i =0;i &lt;= n; i++) {
            if (i==0) f[i] = 0;
            else if(i==1) f[i] = 1;
            else{
                f[i] = f[i-1]+f[i-2];
            }
        }
        return f[n];
    }
</code></pre>
<h5 id="复杂度-127"><a href="#复杂度-127" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="动态规划-滚动数组"><a href="#动态规划-滚动数组" class="headerlink" title="动态规划+滚动数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/">动态规划+滚动数组</a></h4><p>将空间复杂度将为$O(1)$.</p>
<h4 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h4><h5 id="思路-143"><a href="#思路-143" class="headerlink" title="思路"></a>思路</h5><p>根据状态转移方程递归求解</p>
<h5 id="代码-136"><a href="#代码-136" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">    public int fib(int n) {
        return fib2(n);
    }
    int fib2(int n) {
        if(n==0) {
            return 0;
        }else if(n==1) {
            return 1;
        }else{
            return fib2(n-1)+fib2(n-2);
        }
    }
</code></pre>
<h5 id="复杂度-128"><a href="#复杂度-128" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$, 有h层高树, 每层$2^{i-1}$个节点(最后一层2个, 还要分n为奇偶).</li>
<li>空间: $O(H)$</li>
</ul>
<p>递归其实非常的浪费时间, 因为在计算<code>fib(n)</code>时候会计算一遍第二项<code>fib(n-2)</code>,但在计算<code>fib2(n-1)</code>的时候, 会再计算一遍第一项<code>fib2(n-1)</code>.</p>
<pre class="mermaid">graph TD
 1((n))---2((n-1))
 1((n))---3((n-2))
 2((n-1))---4((n-2))
 2((n-1))---5((n-3=1))
 3((n-2))---6((n-3=1))
 3((n-2))---7((n-4=0))
 4((n-2))---8((n-3=1))
 4((n-2))---9((n-4=0))</pre>

<p>递归的时间复杂度为<strong>递归的次数*递归的操作</strong>, 节点是为$O(N^2)$, 操作为加一次.</p>
<p><strong>递归</strong>算法的<strong>空间复杂度</strong>=<strong>递归</strong>深度N*每次<strong>递归</strong>所要的辅助<strong>空间</strong>。 对于单线程来说，<strong>递归</strong>有运行时堆栈，求的是<strong>递归</strong>最深的那一次压栈所耗费的<strong>空间</strong>的个数，因为<strong>递归</strong>最深的那一次所耗费的<strong>空间</strong>足以容纳它所有<strong>递归</strong>过程。</p>
<h4 id="递归-记忆化搜索"><a href="#递归-记忆化搜索" class="headerlink" title="递归+记忆化搜索*"></a>递归+记忆化搜索*</h4><h5 id="思路-144"><a href="#思路-144" class="headerlink" title="思路"></a>思路</h5><p>减少递归多重复算的那几次, 讲$O(N^2)$优化到$O(N)$.</p>
<h5 id="代码-137"><a href="#代码-137" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">    private int[] assistant_f;
    public int fib(int n) {
        assistant_f = new int[n+1];
        return fib3(n);
    }
    int fib3(int n) {
        if(n==0) {
            return assistant_f[n]=0;
        }else if(n==1) {
            return assistant_f[n]=1;
        }else{
            return assistant_f[n] = fib3(n-1)+fib3(n-2);
        }
    }
</code></pre>
<h5 id="复杂度-129"><a href="#复杂度-129" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<pre class="mermaid">graph TD
 1((n))---2((n-1))
 1((n))---3((n-2))
 2((n-1))---3((n-2))
 2((n-1))---8((n-3=1))
 3((n-2))---8((n-3=1))
 3((n-2))---9((n-4=0))
 3((n-2))---8((n-3=1))
 3((n-2))---9((n-4=0))</pre>



<h3 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></h3><p>泰波那契序列 Tn 定义如下： </p>
<p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2</p>
<p>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p>
<h4 id="递归（self"><a href="#递归（self" class="headerlink" title="递归（self"></a>递归（self</h4><h5 id="思路-145"><a href="#思路-145" class="headerlink" title="思路"></a>思路</h5><p>直接用if-elseif写递归，但是是三叉树，太慢了</p>
<h5 id="代码-138"><a href="#代码-138" class="headerlink" title="代码"></a>代码</h5><pre><code>if(n==0)return 0;
else if(n==1) return 1;
else if(n==2) retirm 1;
else return tribonacci(n-3)+trbonacci(n-2)+tribonacci(n-1);
</code></pre>
<h4 id="动态规划存储后随机访问-self"><a href="#动态规划存储后随机访问-self" class="headerlink" title="动态规划存储后随机访问(self"></a>动态规划存储后随机访问(self</h4><h5 id="思路-146"><a href="#思路-146" class="headerlink" title="思路"></a>思路</h5><p>用私有数组存储计算过的斐波那契数列</p>
<h5 id="代码-139"><a href="#代码-139" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    private int[] assistanf_f;
    public int tribonacci(int n) {
        assistanf_f = new int[38];
        assistanf_f[0] = 0;
        assistanf_f[1] = 1;
        assistanf_f[2] = 1;
        for(int i = 3; i &lt;= n; i++) {
            assistanf_f[i] = assistanf_f[i-3]+assistanf_f[i-2]+assistanf_f[i-1];//思想
        }
        return assistanf_f[n];
    }
}
</code></pre>
<h5 id="复杂度-130"><a href="#复杂度-130" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="递归-推导二叉递归-滚动数组"><a href="#递归-推导二叉递归-滚动数组" class="headerlink" title="递归(推导二叉递归+滚动数组)"></a>递归(推导二叉递归+滚动数组)</h4><h5 id="思路-147"><a href="#思路-147" class="headerlink" title="思路"></a>思路</h5><p>直接用递归的话会超时，给定的通项公式可以进一步推导 T(n+3) = T(n+2) + T(n+1) +T(n+0)， T(n+4) = T(n+3) + T(n+2) + T(n+1)， 两者相减 T(n+4) - T(n+3) = T(n+3) - T(n)， 所以T(n) = 2T(n-1) - T(n+4)(n&gt;=4)</p>
<h5 id="代码-140"><a href="#代码-140" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int tribonacci(int n) {
        if (n == 0) {
            return 0;
        }
        if (n &lt;= 2) {
            return 1;
        }
        int p = 0, q = 0, r = 1, s = 1;
        for (int i = 3; i &lt;= n; ++i) {
            p = q;
            q = r;
            r = s;
            s = p + q + r;
        }
        return s;
    }
}
</code></pre>
<h5 id="复杂度-131"><a href="#复杂度-131" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<h4 id="动态规划-辅助数组-self"><a href="#动态规划-辅助数组-self" class="headerlink" title="动态规划+辅助数组(self"></a>动态规划+辅助数组(self</h4><h5 id="思路-148"><a href="#思路-148" class="headerlink" title="思路"></a>思路</h5><p>重要的是写出动态规划的转移方程, 而第n个阶梯只能由n-1走1步或者n-2走2步上来(n-2走1步再走1步不算, 因为已经算到n-1上面了), 也就是转移方程等于<br>$$<br>f(n) = f(n-1)+f(n-2)<br>$$</p>
<h5 id="代码-141"><a href="#代码-141" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    private int [] f;
    public int climbStairs(int n) {
        f = new int[46];
        f[1] = 1;
        f[2] = 2;
        for(int i =3; i &lt;= n; i++) {
            f[i]=f[i-1]+f[i-2];
        }
        return f[n];
    }
}
</code></pre>
<h5 id="复杂度-132"><a href="#复杂度-132" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="动态规划-滚动数组-1"><a href="#动态规划-滚动数组-1" class="headerlink" title="动态规划+滚动数组"></a>动态规划+滚动数组</h4><h5 id="思路-149"><a href="#思路-149" class="headerlink" title="思路"></a>思路</h5><p>利用滚动数组节省辅助数组的空间</p>
<h5 id="代码-142"><a href="#代码-142" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int climbStairs(int n) {
        if(n == 1) return 1;
        else if(n==2)return 2;
        int a = 1, b = 1, c = 2;
        for(int i =3; i &lt;= n; i++) {
            a = b;
            b = c;
            c = a+b;
        }
        return c;
    }
}
</code></pre>
<h5 id="复杂度-133"><a href="#复杂度-133" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h3><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<pre><code>示例 1：

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。

- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
  总花费为 15 。
</code></pre>
<h4 id="动态规划找转移方程-self"><a href="#动态规划找转移方程-self" class="headerlink" title="动态规划找转移方程(self"></a>动态规划找转移方程(self</h4><h5 id="思路-150"><a href="#思路-150" class="headerlink" title="思路"></a>思路</h5><p>用一个<code>sum</code>数组记录到达第i个阶梯所需要的最小的总步数,<br>$$<br>sum[0] = cost[0]	\<br>sum[1] = cost[1]	\<br>sum[n] = min(sum[n-1],sum[n-2])+const[n]<br>$$<br>而最后的结果就是倒数两个阶梯的最小值(因为到达这两个阶梯后可以直接跨1步或者2步到达楼顶,楼顶就是数组的最大长度的那个位置)</p>
<h5 id="代码-143"><a href="#代码-143" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    private int []sum;
    public int minCostClimbingStairs(int[] cost) {
        int length = cost.length;
        sum = new int[1000];
        for(int i = 0; i &lt; length; i++) {
            if(i==0) sum[0] = cost[0];
            else if(i==1) sum[1] = cost[1];
            else sum[i] = Math.min(sum[i-2],sum[i-1])+cost[i];
        }
        return Math.min(sum[length-2],sum[length-1]);
    }
}
</code></pre>
<h5 id="复杂度-134"><a href="#复杂度-134" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="动态规划另外一个转移方程"><a href="#动态规划另外一个转移方程" class="headerlink" title="动态规划另外一个转移方程"></a>动态规划另外一个转移方程</h4><h5 id="思路-151"><a href="#思路-151" class="headerlink" title="思路"></a>思路</h5><p>官方题解另外一个转移方程, 无所谓啦, 我的也正确.<br>$$<br>p[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])<br>$$</p>
<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<pre><code>示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
</code></pre>
<h4 id="递归-self-6"><a href="#递归-self-6" class="headerlink" title="递归(self"></a>递归(self</h4><h5 id="思路-152"><a href="#思路-152" class="headerlink" title="思路"></a>思路</h5><p>找递归终止条件和递归方程, 递归终止条件有</p>
<ul>
<li>e-s==0时, return nums[e];例如<code>[1]</code></li>
<li>e-s==1时, ruturn Math.max(nums[s],nums[e]); 例如<code>[1,3]</code></li>
<li>e-s==2时, return Math.max(nums[s]+nums[s+2], nums[s+1]);例如<code>[1,2,3]</code></li>
<li>else return Math.max(nums[s]+robHelp(s+2,e,nums), nums[s+1]+robHelp(s+3,e,nums)); 例如<code>[1,3,2,4]</code>就相当于<code>1与[2,4]</code>和<code>3与[4]</code>.</li>
</ul>
<p>但是这样太费时间了, 样例正确但是太长的样例时间过不了.</p>
<h5 id="代码-144"><a href="#代码-144" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int rob(int[] nums) {
        return robHelp(0,nums.length-1,nums);
    }
    public int robHelp(int s, int e, int [] nums) {
        if(e-s==0) return nums[s];
        else if(e-s==1) return Math.max(nums[s],nums[e]);
        else if(e-s==2) return Math.max(nums[s]+nums[s+2], nums[s+1]);
        else return Math.max(nums[s]+robHelp(s+2,e,nums), nums[s+1]+robHelp(s+3,e,nums));

    }
}
</code></pre>
<h5 id="复杂度-135"><a href="#复杂度-135" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: 分析不出</li>
</ul>
<h4 id="动态规划找动态方程"><a href="#动态规划找动态方程" class="headerlink" title="动态规划找动态方程*"></a>动态规划找动态方程*</h4><h5 id="思路-153"><a href="#思路-153" class="headerlink" title="思路"></a>思路</h5><p>样例为[0,1,2,3,4,5], 则dp[i]表示到达此屋时能偷到的最大金钱数, 则<br>$$<br>dp[i] = max(dp[i-2]+nums[i],dp[i-1])<br>$$<br>很好理解, dp[i]就是要么是dp[i-2]再加nums[i],要么是dp[i-1]两个中的最大值(第i个不偷了)</p>
<h5 id="代码-145"><a href="#代码-145" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int rob(int[] nums) {
        int [] dp = new int[1001];
        for(int i =0; i &lt; nums.length; i++) {
            if(i==0) dp[i] = nums[i];
            else if(i==1) dp[i] = Math.max(nums[0],nums[1]);
            else dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1]);
        }
        return dp[nums.length-1];
    }
}
</code></pre>
<h5 id="复杂度-136"><a href="#复杂度-136" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="动态规划滑动数组"><a href="#动态规划滑动数组" class="headerlink" title="动态规划滑动数组"></a>动态规划滑动数组</h4><h5 id="代码-146"><a href="#代码-146" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int rob(int[] nums) {
        if(nums.length==1) return nums[0];
        else if(nums.length==2) return Math.max(nums[0], nums[1]);
        int a = 0, b = 0, c=0;
        for(int i =2; i &lt; nums.length; i++) {
            if (i &lt;=2) {
                a = nums[0];
                b = Math.max(nums[0],nums[1]);
            }else{
                a = b;
                b = c;
            }
            c = Math.max(a+nums[i], b);
        }
        return c;
    }
}
</code></pre>
<h5 id="复杂度-137"><a href="#复杂度-137" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<p>执行用时：0 ms, 在所有 Java 提交中击败了100.00% 的用户</p>
<p>内存消耗：35.9 MB, 在所有 Java 提交中击败了34.18% 的用户(不采用滑动数组的话是5%)</p>
<h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，<strong>这意味着第一个房屋和最后一个房屋是紧挨着的</strong>。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<pre><code>示例 1：

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
</code></pre>
<h4 id="动态规划-首尾处理-self"><a href="#动态规划-首尾处理-self" class="headerlink" title="动态规划+首尾处理(self"></a>动态规划+首尾处理(self</h4><h5 id="思路-154"><a href="#思路-154" class="headerlink" title="思路"></a>思路</h5><p>要么不偷第一个,要么不偷最后一个, 要么两个都不偷(肯定比前两者小), 所以只需要比较去除首尾的打家劫舍两个中取最大的即可.</p>
<h5 id="代码-147"><a href="#代码-147" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int rob(int[] nums) {
        int[]nums1 = new int[nums.length-1];
        int[]nums2 = new int[nums.length-1];
        if(nums.length==1) return nums[0];
        else if (nums.length==2) return Math.max(nums[0], nums[1]);
        System.arraycopy(nums, 0, nums1, 0 ,nums.length-1);//语法
        int result1 = robHelp(nums1);
        System.arraycopy(nums, 1, nums2, 0, nums.length-1);
        int result2 = robHelp(nums2);
        return Math.max(result1,result2);

    }
    public int robHelp(int[] nums) {
        int[] dp = new int[nums.length];
        for(int i = 0; i &lt; nums.length; i++) {
            if (i==0) dp[i] = nums[0];
            else if(i==1)dp[i] = Math.max(nums[0], nums[1]);
            else dp[i] = Math.max(dp[i-2]+nums[i], dp[i-1]);
        }
        return dp[nums.length-1];
    }
}
</code></pre>
<h5 id="复杂度-138"><a href="#复杂度-138" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="740-打家劫舍Ⅳ-删除并获得点数"><a href="#740-打家劫舍Ⅳ-删除并获得点数" class="headerlink" title="740. 打家劫舍Ⅳ(删除并获得点数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-and-earn/">740. 打家劫舍Ⅳ(删除并获得点数</a></h3><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p>
<p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p>
<p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
<pre><code>示例 1：

输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
</code></pre>
<pre><code>示例 2：

输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数.
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>1 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<h4 id="观察数据下标计数-self"><a href="#观察数据下标计数-self" class="headerlink" title="观察数据下标计数(self"></a>观察数据下标计数(self</h4><h5 id="思路-155"><a href="#思路-155" class="headerlink" title="思路"></a>思路</h5><p>通过下标计数记录数字的权重, 相当于money, 然后就转化为打家劫舍了</p>
<h5 id="代码-148"><a href="#代码-148" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int deleteAndEarn(int[] nums) {
        int [] money = new int[10001];				//语法, 新申请后默认为0
        for(int i = 0; i &lt; nums.length; i++) {
            money[nums[i]]+=nums[i];
        }
        return robHelp(money);
    }
    public int robHelp(int[] nums) {
        int[] dp = new int[nums.length];
        for(int i = 0; i &lt; nums.length; i++) {
            if (i==0) dp[i] = nums[0];
            else if(i==1)dp[i] = Math.max(nums[0], nums[1]);
            else dp[i] = Math.max(dp[i-2]+nums[i], dp[i-1]);
        }
        return dp[nums.length-1];
    }
}
</code></pre>
<h5 id="复杂度-139"><a href="#复杂度-139" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<h4 id="动态规划找-self"><a href="#动态规划找-self" class="headerlink" title="动态规划找(self"></a>动态规划找(self</h4><h5 id="思路-156"><a href="#思路-156" class="headerlink" title="思路"></a>思路</h5><p>动态方程是某个节点的取值为本节点的值加上四个子孙的值与两个孩子的值的最大值, 但是使用递归会超时, 所以需要记忆化, 记忆化的方法是精髓, 可以用哈希表来记忆化.</p>
<h5 id="代码核心"><a href="#代码核心" class="headerlink" title="代码核心"></a>代码核心</h5><p>动态方程是某个节点的取值为本节点的值加上四个子孙的值与两个孩子的值的最大值.</p>
<pre><code class="java">class Solution {
    public int rob(TreeNode root) {
        return robHelp(root);
    }
    public int robHelp(TreeNode root) {
        if(root==null) return 0;
        else if(root.left==null&amp;&amp;root.right==null){
            return root.val;
        }else if(root.left==null&amp;&amp;root.right!=null) {
            return Math.max(root.val+robHelp(root.right.left)+robHelp(root.right.right), robHelp(root.right));
        }else if(root.left!=null&amp;&amp;root.right==null) {
            return Math.max(robHelp(root.left),root.val+robHelp(root.left.left)+robHelp(root.left.right));
        }else{
            return Math.max(root.val+robHelp(root.left.left)+robHelp(root.left.right)+robHelp(root.right.left)+robHelp(root.right.right), robHelp(root.left)+robHelp(root.right));
        }
    }
}
</code></pre>
<p>因为动态规划递归调用重复计算了很多, 所以需要用一个数据结构持久化, 我刚开始想的是构造一颗相同结构的树, 只不过树的域中多加一个int money的数据域, 然后每次用这个money域而不是递归调用, 但是没构造好, 太麻烦了,经过提示可以用一个哈希表来存储树节点对应的money, 如果有的话就不计算了, 没有的话就再计算, 但是发现代码是一坨屎山.看看得了.</p>
<h5 id="代码-149"><a href="#代码-149" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    Map&lt;TreeNode, Integer&gt; money;
    public int rob(TreeNode root) {
        money = new HashMap&lt;TreeNode, Integer&gt;();	//语法, //思想
        return robHelp(root);
        
    }
    public int robHelp(TreeNode root) {
        if(root==null) return 0;
        else if(root.left==null&amp;&amp;root.right==null){
            money.put(root,root.val);
            return money.get(root);
        }else if(root.left==null&amp;&amp;root.right!=null) { 
            int right_left = money.get(root.right.left)==null?robHelp(root.right.left):money.get(root.right.left);
            int right_right = money.get(root.right.right)==null?robHelp(root.right.right):money.get(root.right.right);
            int root_right = money.get(root.right)==null?robHelp(root.right):money.get(root.right);
            money.put(root, Math.max(root.val+right_left+right_right, root_right));
            return money.get(root);
        }else if(root.left!=null&amp;&amp;root.right==null) {
            int left_left = money.get(root.left.left)==null?robHelp(root.left.left):money.get(root.left.left);
            int left_right = money.get(root.left.right)==null?robHelp(root.left.right):money.get(root.left.right);
            int root_left = money.get(root.left)==null?robHelp(root.left):money.get(root.left);
            money.put(root, Math.max(root.val+left_left+left_right, root_left));
            return money.get(root);
        }else{
            int right_left = money.get(root.right.left)==null?robHelp(root.right.left):money.get(root.right.left);
            int right_right = money.get(root.right.right)==null?robHelp(root.right.right):money.get(root.right.right);
            int root_right = money.get(root.right)==null?robHelp(root.right):money.get(root.right);
            int left_left = money.get(root.left.left)==null?robHelp(root.left.left):money.get(root.left.left);
            int left_right = money.get(root.left.right)==null?robHelp(root.left.right):money.get(root.left.right);
            int root_left = money.get(root.left)==null?robHelp(root.left):money.get(root.left);
            money.put(root, Math.max(root.val+left_left+left_right+right_left+right_right, root_left+root_right));
            return money.get(root);
        }
    }
}
</code></pre>
<h5 id="复杂度-140"><a href="#复杂度-140" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="动态规划另一个转移方程-待"><a href="#动态规划另一个转移方程-待" class="headerlink" title="动态规划另一个转移方程(待"></a>动态规划另一个转移方程(待</h4><h5 id="思路-157"><a href="#思路-157" class="headerlink" title="思路"></a>思路</h5><p>简化一下这个问题：一棵二叉树，树上的每个点都有对应的权值，每个点有两种状态（选中和不选中），问在不能同时选中有父子关系的点的情况下，能选中的点的最大权值和是多少。</p>
<p>我们可以用 f(o) 表示选择 o节点的情况下，o 节点的子树上被选择的节点的最大权值和；g(o)表示不选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和；l 和 r 代表 o的左右孩子。</p>
<p>当 o 被选中时，o的左右孩子都不能被选中，故 ooo 被选中情况下子树上被选中点的最大权值和为 l和 r 不被选中的最大权值和相加，即 $$f(o)=g(l)+g(r)$$<br>当 o不被选中时，o 的左右孩子可以被选中，也可以不被选中。对于 oo的某个具体的孩子 x，它对 o的贡献是 xxx 被选中和不被选中情况下权值和的较大值。故 $$g(o)=max⁡{f(l),g(l)}+max⁡{f(r),g(r)}$$</p>
<h5 id="代码-150"><a href="#代码-150" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    Map&lt;TreeNode, Integer&gt; f = new HashMap&lt;TreeNode, Integer&gt;();
    Map&lt;TreeNode, Integer&gt; g = new HashMap&lt;TreeNode, Integer&gt;();

    public int rob(TreeNode root) {
        dfs(root);
        return Math.max(f.getOrDefault(root, 0), g.getOrDefault(root, 0));
    }

    public void dfs(TreeNode node) {
        if (node == null) {
            return;
            
        }
        dfs(node.left);
        dfs(node.right);
        f.put(node, node.val + g.getOrDefault(node.left, 0) + g.getOrDefault(node.right, 0));
        g.put(node, Math.max(f.getOrDefault(node.left, 0), g.getOrDefault(node.left, 0)) + Math.max(f.getOrDefault(node.right, 0), g.getOrDefault(node.right, 0)));
    }
}


作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/house-robber-iii/solution/da-jia-jie-she-iii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h5 id="复杂度-141"><a href="#复杂度-141" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h2><h3 id="1037-有效的回旋镖-22-06-08"><a href="#1037-有效的回旋镖-22-06-08" class="headerlink" title="1037. 有效的回旋镖 22-06-08"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-boomerang/">1037. 有效的回旋镖</a> 22-06-08</h3><p>给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，如果这些点构成一个 回旋镖 则返回 true 。</p>
<p>回旋镖 定义为一组三个点，这些点 各不相同 且 不在一条直线上 。</p>
<pre><code>示例 1：

输入：points = [[1,1],[2,3],[3,2]]
输出：true
</code></pre>
<h4 id="数学-叉乘的二维应用"><a href="#数学-叉乘的二维应用" class="headerlink" title="数学-叉乘的二维应用"></a>数学-叉乘的二维应用</h4><h5 id="思路-158"><a href="#思路-158" class="headerlink" title="思路"></a>思路</h5><p>向量的叉乘的结果是一个向量, 模长是向量AB组成的平行四边形的面积, 向量方向垂直于AB组成的平面, 三维向量叉乘的计算公式:</p>
<p><img src="D:\pic-bed\img\image-20220609105949502.png" alt="image-20220609105949502"></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94758998">叉乘的扩展</a>:<br>叉乘一般只定义在三维空间中, 但当其扩展到二维空间中, 其结论也很有用(将a3, b3都为0).<br><strong>AXB</strong> = 0, 0, (a1b2-a2b1)k<br>此时(a1b2-a2b1)即为平行四边形的面积, 并且其一半就是AB向量组成的三角形的面积, 另外如果(a1b2-a2b1)&gt;0, A正旋到B的角度&lt;180, (a1b2-a2b1)&lt;0则A正旋到B的角度&gt;180,(a1b2-a2b1)=0则AB共线.</p>
<h5 id="代码-151"><a href="#代码-151" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean isBoomerang(int[][] points) {
        int delt_x12 = points[1][0]-points[0][0];
        int delt_x13 = points[2][0]-points[0][0];
        int delt_y12 = points[1][1]-points[0][1];
        int delt_y13 = points[2][1]-points[0][1];

        return delt_x12*delt_y13-delt_x13*delt_y12 != 0;	//思想
    }
}
</code></pre>
<h5 id="复杂度-142"><a href="#复杂度-142" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(1)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="共点的三点斜率相同为一条直线"><a href="#共点的三点斜率相同为一条直线" class="headerlink" title="共点的三点斜率相同为一条直线"></a>共点的三点斜率相同为一条直线</h4><h5 id="思路-159"><a href="#思路-159" class="headerlink" title="思路"></a>思路</h5><p>只要计算两个点与另外一个点形成的斜率是否相同就好了, 但这里有坑,一个就是斜率的分母可能为0,所以有个技巧,就是$(c2-a2)/(c1-a1) == (b2-a2)/(b1-a1)$要变形为$(c2-a2)<em>(b1-a1)==(b2-a2)</em>(c1-a1)$</p>
<h5 id="代码-152"><a href="#代码-152" class="headerlink" title="代码"></a>代码</h5><pre><code>class Solution {
    public boolean isBoomerang(int[][] points) {
        int delt_x12 = points[1][0]-points[0][0];
        int delt_x13 = points[2][0]-points[0][0];
        int delt_y12 = points[1][1]-points[0][1];
        int delt_y13 = points[2][1]-points[0][1];

        return delt_x12*delt_y13 != delt_x13*delt_y12;
    }
}
</code></pre>
<p>可以看到其实和向量的叉积一摸一样.</p>
<h3 id="497-非重叠矩形中的随机点-22-06-09"><a href="#497-非重叠矩形中的随机点-22-06-09" class="headerlink" title="497. 非重叠矩形中的随机点 22-06-09"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/">497. 非重叠矩形中的随机点</a> 22-06-09</h3><p>给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] = [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点，(xi, yi) 是第 i 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。</p>
<p>在给定的矩形覆盖的空间内的任何整数点都有可能被返回。</p>
<p>请注意 ，整数点是具有整数坐标的点。</p>
<p>实现 Solution 类:</p>
<pre><code>Solution(int[][] rects) 用给定的矩形数组 rects 初始化对象。
int[] pick() 返回一个随机的整数点 [u, v] 在给定的矩形所覆盖的空间内。
</code></pre>
<h4 id="前缀和-二分查找"><a href="#前缀和-二分查找" class="headerlink" title="前缀和+二分查找"></a>前缀和+二分查找</h4><h5 id="思路-160"><a href="#思路-160" class="headerlink" title="思路"></a>思路</h5><p>利用<a target="_blank" rel="noopener" href="https://juejin.cn/post/6944913393627168798">前缀和</a>数组, 将所有可能取到的点的编号填写到前缀和数组中(数组下标作为长方形序号,数组内容作为长方形内点的序号的前缀和).</p>
<p>然后随机抽取一个数作为抽取到的点编号.</p>
<p>根据抽取到的点的编号用<a target="_blank" rel="noopener" href="https://blog.csdn.net/lovesummerforever/article/details/24588989">二分查找</a>查询在哪个长方形中, 并且在长方形可能点的第几行第几列中, 再加上长方形左下角下标, 就知道具体的坐标了.</p>
<p>注意:</p>
<ol>
<li><p>前缀和第0项是0, 接下来每一项存储的是前缀和, 所以是这样的结构</p>
<table>
<thead>
<tr>
<th>0</th>
<th>3</th>
<th>7</th>
<th>10</th>
<th>20</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
</li>
<li><p>二分查找本应该在<code>while</code>循环外返回-1表示没有找到, 但是我们的二分查找找的是右端点, 也就是返回low.</p>
</li>
<li><p>random.nextInt(int n)可以等概率返回0-n之间的数.</p>
</li>
</ol>
<h5 id="代码-153"><a href="#代码-153" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {

    Random random;
    ArrayList&lt;Integer&gt; rectPoints;
    int[][] rects;

    public Solution(int[][] rects) {
        //初始化
        this.random = new Random();
        this.rects = rects;
        this.rectPoints = new ArrayList&lt;Integer&gt;();

        //构造前缀和数组
        rectPoints.add(0);
        for(int[] rect:rects){
            int x_num = rect[2]-rect[0]+1;
            int y_num = rect[3]-rect[1]+1;
            rectPoints.add(rectPoints.get(rectPoints.size()-1)+x_num*y_num);
        }

    }
    
    public int[] pick() {
        int k = random.nextInt(rectPoints.get(rectPoints.size()-1));       //等概率抽取点下标, 点下标从0开始
        int rectIndex = binarySearch(rectPoints, k+1) - 1;        //k+1是因为前缀和存储的下标是从1开始的, -1是因为直接查找得到的是前缀和右端点, 而长方形的下标是左端点的下标.
        int rect_k = k - rectPoints.get(rectIndex);                         //rect_k是对应长方形中点的下标了
        int a = rects[rectIndex][0], b = rects[rectIndex][1], y = rects[rectIndex][3];
        int col = y - b + 1;        //长方形又多少列个可取点;
        int rect_row = rect_k / col;       //表示所抽取的随机点k在对应长方形可取点的哪一行;
        int rect_col = rect_k % col;       //表示所抽取的随机点k在对应长方形可取点的那一列;
        return new int[]{a+rect_row, b+rect_col};
    }
    private int binarySearch(ArrayList&lt;Integer&gt; arr, int target) {  //这里的target是抽取出的点坐标的前缀和对应的不是下标
        int low = 0, hign = arr.size()-1;
        while(low &lt;= hign) {
            int mid = (hign-low) / 2 + low;
            int num = arr.get(mid);
            if(num &lt; target) {
                low = mid + 1;
            }else if(num &gt; target) {
                hign = mid - 1;
            }else{
                return mid;
            }
        }
        //return -1; 原本找不到的话返回-1表示找不到, 但是这里要用右端点前缀和的信息
        return low; //返回找不到的右端点, 恰好比target大
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(rects);
 * int[] param_1 = obj.pick();
 */
</code></pre>
<h5 id="复杂度-143"><a href="#复杂度-143" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $构造函数复杂度为 O(n)，pick函数复杂度为 O(log⁡n)$</li>
<li>空间: $构造函数复杂度O(n), pick函数复杂度O(1)$</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 欢迎在评论区中进行批评指正，转载请注明来源，如涉及侵权，请联系作者删除。 </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments">
    <script src="https://utteranc.es/client.js"
            repo="pengber/pengber.github.io"
            issue-term="pathname"
            theme="github-light"
            label="comment"
            crossorigin="anonymous"
            async>
    </script>
</div>




    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2022-2022 pengber
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
        /* 渲染*/
        function HTMLDecode(text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            temp = null;
            return output;
        }
        if (window.mermaid){
            window.mermaid = null
        }
        $.getScript("//cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js", function () {
            var mermaidOptions = JSON.parse(HTMLDecode("{&#34;theme&#34;:&#34;default&#34;,&#34;startOnLoad&#34;:true,&#34;flowchart&#34;:{&#34;useMaxWidth&#34;:false,&#34;htmlLabels&#34;:true}}"))
            if (window.mermaid) {
                mermaid.initialize(mermaidOptions)
                mermaid.contentLoaded()
            }
        })
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 622px;
    }
    .nav.fullscreen {
        margin-left: -622px;
    }
    .nav-left {
        width: 200px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 552px;
        }
        .nav.fullscreen {
            margin-left: -552px;
        }
        .nav-left {
            width: 160px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 552px;
            margin-left: -552px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
