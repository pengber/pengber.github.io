<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>03Leetcode热题100 | pengber&#39;s site</title>
  <meta name="keywords" content=" Java , python ">
  <meta name="description" content="03Leetcode热题100 | pengber&#39;s site">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="个人简介pengber 本科毕业于北京化工大学, 硕士就读于北京邮电大学. 联系方式邮箱: pengber@126.com">
<meta property="og:type" content="website">
<meta property="og:title" content="pengber&#39;s site">
<meta property="og:url" content="https://pengber.github.io/about/index.html">
<meta property="og:site_name" content="pengber&#39;s site">
<meta property="og:description" content="个人简介pengber 本科毕业于北京化工大学, 硕士就读于北京邮电大学. 联系方式邮箱: pengber@126.com">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-29T14:36:23.999Z">
<meta property="article:modified_time" content="2022-07-15T11:15:22.204Z">
<meta property="article:author" content="pengber">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>pengber</span>
</div>

<div class="icon">
    
        
    
        
            <a title="github"
               href="https://github.com/pengber"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:pengber@126.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(290)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="0开发">
                        <i class="fold iconfont icon-right"></i>
                        
                        0开发
                        <small>(20)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="0开发<--->DSpring套件">
                                        
                                        DSpring套件
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="0开发<--->H参考项目">
                                        
                                        H参考项目
                                        
                                            <small>(5
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="0开发<--->I场景业务">
                                        
                                        I场景业务
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="0开发<--->Z刷题">
                                        
                                        Z刷题
                                        
                                            <small>(8
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="1计算机">
                        <i class="fold iconfont icon-right"></i>
                        
                        1计算机
                        <small>(96)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="1计算机<--->A编程语言">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        A编程语言
                                        
                                            <small>(14
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="1计算机<--->A编程语言其它">
                                                        
                                                        其它
                                                        
                                                            <small>(6)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="1计算机<--->A编程语言C">
                                                        
                                                        C
                                                        
                                                            <small>(3)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="1计算机<--->A编程语言JAVA">
                                                        
                                                        JAVA
                                                        
                                                            <small>(2)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="1计算机<--->A编程语言Python">
                                                        
                                                        Python
                                                        
                                                            <small>(3)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="1计算机<--->B集成开发环境">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        B集成开发环境
                                        
                                            <small>(37
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="1计算机<--->B集成开发环境linux">
                                                        
                                                        linux
                                                        
                                                            <small>(9)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="1计算机<--->B集成开发环境Vs2019">
                                                        
                                                        Vs2019
                                                        
                                                            <small>(1)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="1计算机<--->B集成开发环境VsCode">
                                                        
                                                        VsCode
                                                        
                                                            <small>(9)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="1计算机<--->B集成开发环境WAMP">
                                                        
                                                        WAMP
                                                        
                                                            <small>(6)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                                <li>
                                                    <div data-rel="1计算机<--->B集成开发环境windows">
                                                        
                                                        windows
                                                        
                                                            <small>(7)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="1计算机<--->C算法与数据结构">
                                        
                                        C算法与数据结构
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="1计算机<--->D软件开发项目">
                                        
                                        D软件开发项目
                                        
                                            <small>(4
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="1计算机<--->E人工智能">
                                        
                                        E人工智能
                                        
                                            <small>(8
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="1计算机<--->F计算机网络">
                                        
                                        F计算机网络
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="1计算机<--->G计算机硬件">
                                        
                                        G计算机硬件
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="1计算机<--->I计算机图形学">
                                        
                                        I计算机图形学
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="1计算机<--->J计算机理论与数学">
                                        
                                        J计算机理论与数学
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="1计算机<--->Y实验室">
                                        
                                        Y实验室
                                        
                                            <small>(13
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="1计算机<--->Z其他计算机">
                                        
                                        Z其他计算机
                                        
                                            <small>(6
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="2金融">
                        <i class="fold iconfont icon-right"></i>
                        
                        2金融
                        <small>(32)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="2金融<--->A金融知识">
                                        
                                        A金融知识
                                        
                                            <small>(19
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="2金融<--->C行业个股">
                                        
                                        C行业个股
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="2金融<--->D投资策略">
                                        
                                        D投资策略
                                        
                                            <small>(6
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="2金融<--->E投资记录">
                                        
                                        E投资记录
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="3修身">
                        <i class="fold iconfont icon-right"></i>
                        
                        3修身
                        <small>(95)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="3修身<--->A自修">
                                        
                                        A自修
                                        
                                            <small>(9
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="3修身<--->B生活技能">
                                        
                                        B生活技能
                                        
                                            <small>(9
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="3修身<--->C生活知识">
                                        
                                        C生活知识
                                        
                                            <small>(25
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="3修身<--->D工作">
                                        
                                        D工作
                                        
                                            <small>(10
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="3修身<--->E创业">
                                        
                                        E创业
                                        
                                            <small>(14
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="3修身<--->F定居旅行">
                                        
                                        F定居旅行
                                        
                                            <small>(18
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="3修身<--->G奇思妙想">
                                        
                                        G奇思妙想
                                        
                                            <small>(10
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="4运动">
                        <i class="fold iconfont icon-right"></i>
                        
                        4运动
                        <small>(7)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="4运动<--->A足球">
                                        
                                        A足球
                                        
                                            <small>(7
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="5学科">
                        <i class="fold iconfont icon-right"></i>
                        
                        5学科
                        <small>(29)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="5学科<--->A文学">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        A文学
                                        
                                            <small>(9
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="5学科<--->A文学村上春树">
                                                        
                                                        村上春树
                                                        
                                                            <small>(6)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="5学科<--->B社会科学">
                                        
                                        B社会科学
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="5学科<--->C历史地理">
                                        
                                        C历史地理
                                        
                                            <small>(4
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="5学科<--->D政治">
                                        
                                        D政治
                                        
                                            <small>(6
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="5学科<--->F心理学">
                                        
                                        F心理学
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="5学科<--->G影评">
                                        
                                        G影评
                                        
                                            <small>(5
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="290">
<input type="hidden" id="yelog_site_word_count" value="473.9k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C++</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>PHP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>python</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>pytorch</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>WAMP</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 "
           href="/2023/08/01/20230801/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-08-01 00:00:00">2023/08/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 E人工智能 "
           href="/2023/07/07/1-ji-suan-ji/e-ren-gong-zhi-neng/wenda-he-fess-an-zhuang-shi-yong/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="wenda和fess安装使用">wenda和fess安装使用</span>
            <span class="post-date" title="2023-07-07 10:51:36">2023/07/07</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2023/06/27/3-xiu-shen/c-sheng-huo-zhi-shi/guang-xi-zhi-yuan-bao-ming/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="广西志愿报名">广西志愿报名</span>
            <span class="post-date" title="2023-06-27 01:15:56">2023/06/27</span>
        </a>
        
        
        <a  class="全部文章 2金融 "
           href="/2023/06/23/2-jin-rong/zen-me-xue-jing-ji-xue-he-jin-rong-xue/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="怎么学经济学和金融学">怎么学经济学和金融学</span>
            <span class="post-date" title="2023-06-23 21:41:13">2023/06/23</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2023/06/22/3-xiu-shen/c-sheng-huo-zhi-shi/lu-you-bo-shi-diao-yan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="旅游博士调研">旅游博士调研</span>
            <span class="post-date" title="2023-06-22 12:27:05">2023/06/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/06/22/f-ji-zhu-guan-li-wen-jian-jia/"
           data-tag="C++,python"
           data-author="" >
            <span class="post-title" title="F技术管理-文件夹">F技术管理-文件夹</span>
            <span class="post-date" title="2023-06-22 02:35:51">2023/06/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/06/22/d-shu-ru-guan-li-wen-jian-jia/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="D输入管理-文件夹">D输入管理-文件夹</span>
            <span class="post-date" title="2023-06-22 02:35:28">2023/06/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/06/22/c-ri-cheng-guan-li-ri-li-qing-dan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C日程管理-日历清单">C日程管理-日历清单</span>
            <span class="post-date" title="2023-06-22 02:34:19">2023/06/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/06/22/a-ren-sheng-guan-li-typora/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="A`人生管理-typora">A`人生管理-typora</span>
            <span class="post-date" title="2023-06-22 02:13:39">2023/06/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/06/22/a-san-guan-si-wei-guan-li-typora/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="A三观思维管理-typora">A三观思维管理-typora</span>
            <span class="post-date" title="2023-06-22 02:11:57">2023/06/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/06/22/gong-si-zu-zhi-jia-gou-ji-gui-mo/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="公司组织架构及规模">公司组织架构及规模</span>
            <span class="post-date" title="2023-06-22 00:03:30">2023/06/22</span>
        </a>
        
        
        <a  class="全部文章 0开发 I场景业务 "
           href="/2023/06/18/0-kai-fa/i-chang-jing-ye-wu/ji-jin-ye-wu-xue-xi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基金业务学习">基金业务学习</span>
            <span class="post-date" title="2023-06-18 10:44:15">2023/06/18</span>
        </a>
        
        
        <a  class="全部文章 0开发 I场景业务 "
           href="/2023/06/05/0-kai-fa/i-chang-jing-ye-wu/dian-shang-ye-wu-xue-xi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="电商业务学习">电商业务学习</span>
            <span class="post-date" title="2023-06-05 10:47:37">2023/06/05</span>
        </a>
        
        
        <a  class="全部文章 0开发 I场景业务 "
           href="/2023/06/04/0-kai-fa/i-chang-jing-ye-wu/zhi-fu-ye-wu-xue-xi/"
           data-tag="github,Java"
           data-author="" >
            <span class="post-title" title="支付业务学习">支付业务学习</span>
            <span class="post-date" title="2023-06-04 17:37:11">2023/06/04</span>
        </a>
        
        
        <a  class="全部文章 0开发 Z刷题 "
           href="/2023/06/03/0-kai-fa/z-shua-ti/10sql-cha-xun/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="10SQL查询">10SQL查询</span>
            <span class="post-date" title="2023-06-03 13:51:10">2023/06/03</span>
        </a>
        
        
        <a  class="全部文章 0开发 "
           href="/2023/05/28/0-kai-fa/kai-fa-ba-gu-wen-gao-ji/"
           data-tag="github,Java,C++,python,PHP"
           data-author="" >
            <span class="post-title" title="开发八股文高级">开发八股文高级</span>
            <span class="post-date" title="2023-05-28 10:49:50">2023/05/28</span>
        </a>
        
        
        <a  class="全部文章 0开发 H参考项目 "
           href="/2023/05/22/0-kai-fa/h-can-kao-xiang-mu/piggymetrics/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PiggyMetrics">PiggyMetrics</span>
            <span class="post-date" title="2023-05-22 23:22:17">2023/05/22</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2023/05/22/1-ji-suan-ji/y-shi-yan-shi/wu-ren-ji-xie-tong/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="无人机协同">无人机协同</span>
            <span class="post-date" title="2023-05-22 11:56:41">2023/05/22</span>
        </a>
        
        
        <a  class="全部文章 0开发 H参考项目 "
           href="/2023/05/17/0-kai-fa/h-can-kao-xiang-mu/xue-cheng-zai-xian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="学成在线">学成在线</span>
            <span class="post-date" title="2023-05-17 01:00:49">2023/05/17</span>
        </a>
        
        
        <a  class="全部文章 0开发 H参考项目 "
           href="/2023/05/15/0-kai-fa/h-can-kao-xiang-mu/gu-li-shang-cheng/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="谷粒商城">谷粒商城</span>
            <span class="post-date" title="2023-05-15 11:35:13">2023/05/15</span>
        </a>
        
        
        <a  class="全部文章 0开发 H参考项目 "
           href="/2023/05/11/0-kai-fa/h-can-kao-xiang-mu/wei-fu-wu-ji-zhu-zhan-xue-xi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="微服务技术栈学习">微服务技术栈学习</span>
            <span class="post-date" title="2023-05-11 14:18:00">2023/05/11</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/05/08/3-xiu-shen/f-ding-ju-lu-xing/13-ma-an-shan-nan-jing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="13马鞍山南京">13马鞍山南京</span>
            <span class="post-date" title="2023-05-08 00:08:39">2023/05/08</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/05/07/3-xiu-shen/f-ding-ju-lu-xing/13-tian-jin/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="13天津">13天津</span>
            <span class="post-date" title="2023-05-07 23:59:56">2023/05/07</span>
        </a>
        
        
        <a  class="全部文章 3修身 A自修 "
           href="/2023/05/05/3-xiu-shen/a-zi-xiu/ren-qing-wang-lai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="人情往来">人情往来</span>
            <span class="post-date" title="2023-05-05 10:30:21">2023/05/05</span>
        </a>
        
        
        <a  class="全部文章 0开发 DSpring套件 "
           href="/2023/04/24/0-kai-fa/dspring-tao-jian/java-kai-fa-chang-yong-zhu-jie/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="Java开发常用注解">Java开发常用注解</span>
            <span class="post-date" title="2023-04-24 20:29:08">2023/04/24</span>
        </a>
        
        
        <a  class="全部文章 5学科 C历史地理 "
           href="/2023/04/24/5-xue-ke/c-li-shi-di-li/li-shi-di-li-suo-sui-zhi-shi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="历史地理琐碎知识">历史地理琐碎知识</span>
            <span class="post-date" title="2023-04-24 00:27:58">2023/04/24</span>
        </a>
        
        
        <a  class="全部文章 3修身 D工作 "
           href="/2023/04/22/3-xiu-shen/d-gong-zuo/06-bi-jing-ji-mian-jing/"
           data-tag="github,Java,C++,python"
           data-author="" >
            <span class="post-title" title="06笔经及面经">06笔经及面经</span>
            <span class="post-date" title="2023-04-22 11:15:35">2023/04/22</span>
        </a>
        
        
        <a  class="全部文章 0开发 H参考项目 "
           href="/2023/04/20/0-kai-fa/h-can-kao-xiang-mu/hei-ma-dian-ping/"
           data-tag="github,Java"
           data-author="" >
            <span class="post-title" title="黑马点评">黑马点评</span>
            <span class="post-date" title="2023-04-20 16:47:03">2023/04/20</span>
        </a>
        
        
        <a  class="全部文章 5学科 C历史地理 "
           href="/2023/04/18/5-xue-ke/c-li-shi-di-li/bei-jing-di-li/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="北京地理">北京地理</span>
            <span class="post-date" title="2023-04-18 11:30:10">2023/04/18</span>
        </a>
        
        
        <a  class="全部文章 0开发 "
           href="/2023/04/15/0-kai-fa/chong-kai-fa-ji-zhu-zhan-mu-biao-ji-xue-xi-zi-liao/"
           data-tag="github,Java"
           data-author="" >
            <span class="post-title" title="【重】开发技术栈目标及学习资料">【重】开发技术栈目标及学习资料</span>
            <span class="post-date" title="2023-04-15 01:17:56">2023/04/15</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2023/04/10/1-ji-suan-ji/y-shi-yan-shi/can-shu-gao-xiao-wei-diao-zong-shu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="参数高效微调综述">参数高效微调综述</span>
            <span class="post-date" title="2023-04-10 11:19:51">2023/04/10</span>
        </a>
        
        
        <a  class="全部文章 3修身 A自修 "
           href="/2023/03/30/3-xiu-shen/a-zi-xiu/chi-du-dai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="尺度(待)">尺度(待)</span>
            <span class="post-date" title="2023-03-30 12:44:46">2023/03/30</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/03/25/3-xiu-shen/f-ding-ju-lu-xing/12-ji-nan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="12济南">12济南</span>
            <span class="post-date" title="2023-03-25 23:53:12">2023/03/25</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/03/25/z-kong-bai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Z空白">Z空白</span>
            <span class="post-date" title="2023-03-25 23:52:56">2023/03/25</span>
        </a>
        
        
        <a  class="全部文章 3修身 D工作 "
           href="/2023/03/25/3-xiu-shen/d-gong-zuo/05-bi-shi-ji-mian-shi/"
           data-tag="Java,C++,python"
           data-author="" >
            <span class="post-title" title="05笔试及面试">05笔试及面试</span>
            <span class="post-date" title="2023-03-25 21:38:50">2023/03/25</span>
        </a>
        
        
        <a  class="全部文章 0开发 Z刷题 "
           href="/2023/03/25/0-kai-fa/z-shua-ti/06acm-shu-ru-shu-chu/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="06ACM输入输出">06ACM输入输出</span>
            <span class="post-date" title="2023-03-25 15:45:27">2023/03/25</span>
        </a>
        
        
        <a  class="全部文章 3修身 D工作 "
           href="/2023/03/01/3-xiu-shen/d-gong-zuo/07-ying-pin-jin-cheng-ji-lu/"
           data-tag="Java,C++,python"
           data-author="" >
            <span class="post-title" title="07应聘进程记录">07应聘进程记录</span>
            <span class="post-date" title="2023-03-01 17:28:18">2023/03/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2023/02/26/3-xiu-shen/c-sheng-huo-zhi-shi/guo-nei-dian-xin-zha-pian-dai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="国内电信诈骗(待)">国内电信诈骗(待)</span>
            <span class="post-date" title="2023-02-26 22:09:31">2023/02/26</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2023/02/24/3-xiu-shen/e-chuang-ye/chuang-ye-zhi-shi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创业知识">创业知识</span>
            <span class="post-date" title="2023-02-24 17:34:31">2023/02/24</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/02/21/3-xiu-shen/f-ding-ju-lu-xing/11-guang-zhou-ao-men/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="11广州澳门">11广州澳门</span>
            <span class="post-date" title="2023-02-21 20:46:13">2023/02/21</span>
        </a>
        
        
        <a  class="全部文章 1计算机 "
           href="/2023/02/01/1-ji-suan-ji/yu-ming-fu-wu-qi-bei-an-ji-lu/"
           data-tag="github,Java"
           data-author="" >
            <span class="post-title" title="域名服务器备案记录">域名服务器备案记录</span>
            <span class="post-date" title="2023-02-01 22:07:19">2023/02/01</span>
        </a>
        
        
        <a  class="全部文章 5学科 C历史地理 "
           href="/2023/01/31/5-xue-ke/c-li-shi-di-li/di-yuan-zhi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="地缘志">地缘志</span>
            <span class="post-date" title="2023-01-31 22:39:53">2023/01/31</span>
        </a>
        
        
        <a  class="全部文章 3修身 B生活技能 "
           href="/2023/01/29/3-xiu-shen/b-sheng-huo-ji-neng/pr/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PR">PR</span>
            <span class="post-date" title="2023-01-29 16:55:23">2023/01/29</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/01/15/3-xiu-shen/f-ding-ju-lu-xing/09-cheng-du/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="09成都">09成都</span>
            <span class="post-date" title="2023-01-15 19:25:31">2023/01/15</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2023/01/13/3-xiu-shen/c-sheng-huo-zhi-shi/ji-suan-ji-xuan-gou/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机选购">计算机选购</span>
            <span class="post-date" title="2023-01-13 18:27:20">2023/01/13</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/01/04/3-xiu-shen/f-ding-ju-lu-xing/08-he-xi-zou-lang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="08河西走廊">08河西走廊</span>
            <span class="post-date" title="2023-01-04 14:30:51">2023/01/04</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/01/04/3-xiu-shen/f-ding-ju-lu-xing/07-lan-zhou/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="07兰州">07兰州</span>
            <span class="post-date" title="2023-01-04 14:29:35">2023/01/04</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/01/04/3-xiu-shen/f-ding-ju-lu-xing/06-nan-jing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="06南京">06南京</span>
            <span class="post-date" title="2023-01-04 14:29:18">2023/01/04</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/01/04/3-xiu-shen/f-ding-ju-lu-xing/05-jin-hua/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="05金华">05金华</span>
            <span class="post-date" title="2023-01-04 14:29:07">2023/01/04</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/01/04/3-xiu-shen/f-ding-ju-lu-xing/04-tian-jin/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="04天津">04天津</span>
            <span class="post-date" title="2023-01-04 14:28:59">2023/01/04</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/01/04/3-xiu-shen/f-ding-ju-lu-xing/03-cheng-de/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="03承德">03承德</span>
            <span class="post-date" title="2023-01-04 14:28:54">2023/01/04</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/01/04/3-xiu-shen/f-ding-ju-lu-xing/02-nan-jing-su-zhou-shang-hai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="02南京苏州上海">02南京苏州上海</span>
            <span class="post-date" title="2023-01-04 14:28:37">2023/01/04</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/01/04/3-xiu-shen/f-ding-ju-lu-xing/01-xi-an-bei-jing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="01西安-北京">01西安-北京</span>
            <span class="post-date" title="2023-01-04 14:28:17">2023/01/04</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/01/04/3-xiu-shen/f-ding-ju-lu-xing/zu-che/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="租车">租车</span>
            <span class="post-date" title="2023-01-04 11:26:19">2023/01/04</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2023/01/02/3-xiu-shen/f-ding-ju-lu-xing/10-yun-nan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="10云南">10云南</span>
            <span class="post-date" title="2023-01-02 10:31:03">2023/01/02</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2022/12/29/3-xiu-shen/f-ding-ju-lu-xing/gang-ao-tong-xing-zheng-ban-li-guo-cheng/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="港澳通行证办理过程">港澳通行证办理过程</span>
            <span class="post-date" title="2022-12-29 15:05:58">2022/12/29</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2022/12/12/3-xiu-shen/c-sheng-huo-zhi-shi/xin-guan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="新冠">新冠</span>
            <span class="post-date" title="2022-12-12 22:48:45">2022/12/12</span>
        </a>
        
        
        <a  class="全部文章 3修身 D工作 "
           href="/2022/12/12/3-xiu-shen/d-gong-zuo/00-ge-ren-jian-li/"
           data-tag="Java,python"
           data-author="" >
            <span class="post-title" title="00个人简历">00个人简历</span>
            <span class="post-date" title="2022-12-12 15:26:56">2022/12/12</span>
        </a>
        
        
        <a  class="全部文章 3修身 D工作 "
           href="/2022/12/12/3-xiu-shen/d-gong-zuo/08-zhi-chang-gui-ze/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="08职场规则">08职场规则</span>
            <span class="post-date" title="2022-12-12 09:41:51">2022/12/12</span>
        </a>
        
        
        <a  class="全部文章 3修身 A自修 "
           href="/2022/12/05/3-xiu-shen/a-zi-xiu/dan-shen-ren-shi-yao-zuo-de-100-jian-xiao-shi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="单身人士要做的100件小事">单身人士要做的100件小事</span>
            <span class="post-date" title="2022-12-05 15:30:47">2022/12/05</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2022/11/28/shuo-shi-bi-ye-lun-wen/"
           data-tag="github,Java,python,pytorch"
           data-author="" >
            <span class="post-title" title="硕士毕业论文">硕士毕业论文</span>
            <span class="post-date" title="2022-11-28 10:23:39">2022/11/28</span>
        </a>
        
        
        <a  class="全部文章 5学科 G影评 "
           href="/2022/11/26/5-xue-ke/g-ying-ping/zhi-chao-wu-jiao-shou-gei-zhi-zi-xie-de-shi-me/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="纸钞屋教授给侄子写的什么">纸钞屋教授给侄子写的什么</span>
            <span class="post-date" title="2022-11-26 00:22:19">2022/11/26</span>
        </a>
        
        
        <a  class="全部文章 1计算机 "
           href="/2022/11/22/1-ji-suan-ji/ji-suan-ji-zhi-shi-qa/"
           data-tag="Java,C++,python,pytorch"
           data-author="" >
            <span class="post-title" title="计算机知识QA">计算机知识QA</span>
            <span class="post-date" title="2022-11-22 16:24:57">2022/11/22</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2022/11/22/3-xiu-shen/e-chuang-ye/zhong-ying-chuang-ye-xiang-mu-si-ci-pei-xun/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中英创业项目四次培训">中英创业项目四次培训</span>
            <span class="post-date" title="2022-11-22 16:09:08">2022/11/22</span>
        </a>
        
        
        <a  class="全部文章 1计算机 F计算机网络 "
           href="/2022/11/22/1-ji-suan-ji/f-ji-suan-ji-wang-luo/hu-nan-ke-ji-da-xue-ji-suan-ji-wang-luo-bi-ji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="湖南科技大学计算机网络笔记">湖南科技大学计算机网络笔记</span>
            <span class="post-date" title="2022-11-22 15:26:00">2022/11/22</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 Python "
           href="/2022/11/22/1-ji-suan-ji/a-bian-cheng-yu-yan/python/pytorch/"
           data-tag="python,pytorch"
           data-author="" >
            <span class="post-title" title="Pytorch">Pytorch</span>
            <span class="post-date" title="2022-11-22 15:15:07">2022/11/22</span>
        </a>
        
        
        <a  class="全部文章 4运动 A足球 "
           href="/2022/11/19/4-yun-dong/a-zu-qiu/wu-ren-zhi-cai-pan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="五人制裁判">五人制裁判</span>
            <span class="post-date" title="2022-11-19 08:34:41">2022/11/19</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 "
           href="/2022/11/17/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/ju-chi-yun/"
           data-tag="github,python,pytorch"
           data-author="" >
            <span class="post-title" title="矩池云">矩池云</span>
            <span class="post-date" title="2022-11-17 21:56:15">2022/11/17</span>
        </a>
        
        
        <a  class="全部文章 3修身 A自修 "
           href="/2022/11/14/3-xiu-shen/a-zi-xiu/fang-fa-lun-ru-he-shu-li-mo-sheng-ling-zhang-cen-zi-mu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="方法论-如何梳理陌生领- 张涔子沐">方法论-如何梳理陌生领- 张涔子沐</span>
            <span class="post-date" title="2022-11-14 22:52:59">2022/11/14</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2022/11/12/2-jin-rong/a-jin-rong-zhi-shi/bei-da-jing-ji-xue-fu-he-xiang-mu-ke-biao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="北大经济学复合项目课表">北大经济学复合项目课表</span>
            <span class="post-date" title="2022-11-12 23:57:51">2022/11/12</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 "
           href="/2022/11/12/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/git-an-zhuang-ji-shi-yong/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="Git安装及使用">Git安装及使用</span>
            <span class="post-date" title="2022-11-12 20:11:38">2022/11/12</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 C "
           href="/2022/11/12/1-ji-suan-ji/a-bian-cheng-yu-yan/c/c-yu-yan-te-xing/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C语言特性">C语言特性</span>
            <span class="post-date" title="2022-11-12 19:58:25">2022/11/12</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 C "
           href="/2022/11/12/1-ji-suan-ji/a-bian-cheng-yu-yan/c/c-xue-xi-lu-xian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C学习路线">C学习路线</span>
            <span class="post-date" title="2022-11-12 19:58:04">2022/11/12</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 JAVA "
           href="/2022/11/12/1-ji-suan-ji/a-bian-cheng-yu-yan/java/java-yu-yan-te-xing/"
           data-tag="Java,C++"
           data-author="" >
            <span class="post-title" title="Java语言特性">Java语言特性</span>
            <span class="post-date" title="2022-11-12 19:54:55">2022/11/12</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 Python "
           href="/2022/11/12/1-ji-suan-ji/a-bian-cheng-yu-yan/python/python-yu-yan-te-xing/"
           data-tag="C++,python"
           data-author="" >
            <span class="post-title" title="python语言特性">python语言特性</span>
            <span class="post-date" title="2022-11-12 19:48:42">2022/11/12</span>
        </a>
        
        
        <a  class="全部文章 2金融 "
           href="/2022/11/08/2-jin-rong/11-ju-hua-gao-qing-hui-ji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="11句话搞清会计">11句话搞清会计</span>
            <span class="post-date" title="2022-11-08 00:13:39">2022/11/08</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2022/11/02/1-ji-suan-ji/y-shi-yan-shi/chou-suan-ping-tai-mm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="筹算平台MM">筹算平台MM</span>
            <span class="post-date" title="2022-11-02 21:50:05">2022/11/02</span>
        </a>
        
        
        <a  class="全部文章 0开发 "
           href="/2022/11/01/0-kai-fa/xi-tong-jia-gou-she-ji-shi/"
           data-tag="Java,C++,python"
           data-author="" >
            <span class="post-title" title="系统架构设计师">系统架构设计师</span>
            <span class="post-date" title="2022-11-01 20:27:43">2022/11/01</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2022/10/30/2-jin-rong/a-jin-rong-zhi-shi/jing-ji-xue/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="经济学">经济学</span>
            <span class="post-date" title="2022-10-30 20:42:55">2022/10/30</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2022/10/22/3-xiu-shen/f-ding-ju-lu-xing/00-ding-ju-cheng-shi-fen-xi/"
           data-tag="Java,C++"
           data-author="" >
            <span class="post-title" title="00定居城市分析">00定居城市分析</span>
            <span class="post-date" title="2022-10-22 00:27:25">2022/10/22</span>
        </a>
        
        
        <a  class="全部文章 3修身 A自修 "
           href="/2022/10/16/3-xiu-shen/a-zi-xiu/ba-shi-jian-dang-peng-you/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="把时间当朋友">把时间当朋友</span>
            <span class="post-date" title="2022-10-16 11:10:09">2022/10/16</span>
        </a>
        
        
        <a  class="全部文章 0开发 Z刷题 "
           href="/2022/09/20/0-kai-fa/z-shua-ti/08leetcode-mei-ri-yi-ti/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="08Leetcode每日一题">08Leetcode每日一题</span>
            <span class="post-date" title="2022-09-20 00:25:03">2022/09/20</span>
        </a>
        
        
        <a  class="全部文章 0开发 Z刷题 "
           href="/2022/09/20/0-kai-fa/z-shua-ti/02leetcode-dong-tai-gui-hua/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="02Leetcode动态规划">02Leetcode动态规划</span>
            <span class="post-date" title="2022-09-20 00:22:21">2022/09/20</span>
        </a>
        
        
        <a  class="全部文章 0开发 Z刷题 "
           href="/2022/09/20/0-kai-fa/z-shua-ti/01leetocde-shu-ju-jie-gou/"
           data-tag="github,Java,C++,python"
           data-author="" >
            <span class="post-title" title="01Leetocde数据结构">01Leetocde数据结构</span>
            <span class="post-date" title="2022-09-20 00:16:45">2022/09/20</span>
        </a>
        
        
        <a  class="全部文章 0开发 Z刷题 "
           href="/2022/09/18/0-kai-fa/z-shua-ti/09leetcode-zhou-sai/"
           data-tag="Java,python"
           data-author="" >
            <span class="post-title" title="09Leetcode周赛">09Leetcode周赛</span>
            <span class="post-date" title="2022-09-18 16:23:28">2022/09/18</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2022/09/16/2-jin-rong/a-jin-rong-zhi-shi/hui-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="汇率">汇率</span>
            <span class="post-date" title="2022-09-16 16:33:54">2022/09/16</span>
        </a>
        
        
        <a  class="全部文章 0开发 Z刷题 "
           href="/2022/09/14/0-kai-fa/z-shua-ti/03leetcode-re-ti-100/"
           data-tag="Java,python"
           data-author="" >
            <span class="post-title" title="03Leetcode热题100">03Leetcode热题100</span>
            <span class="post-date" title="2022-09-14 14:18:23">2022/09/14</span>
        </a>
        
        
        <a  class="全部文章 5学科 F心理学 "
           href="/2022/09/12/5-xue-ke/f-xin-li-xue/shi-liu-ren-ge/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="十六人格">十六人格</span>
            <span class="post-date" title="2022-09-12 00:05:27">2022/09/12</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2022/09/11/3-xiu-shen/c-sheng-huo-zhi-shi/pei-yan-jing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="配眼镜">配眼镜</span>
            <span class="post-date" title="2022-09-11 22:47:23">2022/09/11</span>
        </a>
        
        
        <a  class="全部文章 5学科 D政治 "
           href="/2022/09/01/5-xue-ke/d-zheng-zhi/wo-guo-jue-ce-ti-xi-ji-ji-gou/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="我国决策体系及机构">我国决策体系及机构</span>
            <span class="post-date" title="2022-09-01 17:27:48">2022/09/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 E人工智能 "
           href="/2022/09/01/1-ji-suan-ji/e-ren-gong-zhi-neng/speech-language-aprocess/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Speech language aprocess">Speech language aprocess</span>
            <span class="post-date" title="2022-09-01 16:12:26">2022/09/01</span>
        </a>
        
        
        <a  class="全部文章 5学科 C历史地理 "
           href="/2022/08/25/5-xue-ke/c-li-shi-di-li/ming-zhao-zhao-dai-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="明朝朝代总结">明朝朝代总结</span>
            <span class="post-date" title="2022-08-25 23:18:36">2022/08/25</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2022/08/09/2-jin-rong/a-jin-rong-zhi-shi/wen-da/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="问答">问答</span>
            <span class="post-date" title="2022-08-09 09:28:56">2022/08/09</span>
        </a>
        
        
        <a  class="全部文章 3修身 D工作 "
           href="/2022/08/01/3-xiu-shen/d-gong-zuo/02-zhi-ye-gui-hua/"
           data-tag="Java,C++,python,PHP"
           data-author="" >
            <span class="post-title" title="02职业规划">02职业规划</span>
            <span class="post-date" title="2022-08-01 09:12:53">2022/08/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 G奇思妙想 "
           href="/2022/07/30/3-xiu-shen/g-qi-si-miao-xiang/sui-bian-xiang-xiang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="随便想想">随便想想</span>
            <span class="post-date" title="2022-07-30 15:23:54">2022/07/30</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2022/07/29/3-xiu-shen/c-sheng-huo-zhi-shi/a-sheng-huo-chang-shi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="阿生活常识">阿生活常识</span>
            <span class="post-date" title="2022-07-29 22:23:48">2022/07/29</span>
        </a>
        
        
        <a  class="全部文章 1计算机 E人工智能 "
           href="/2022/07/25/1-ji-suan-ji/e-ren-gong-zhi-neng/text-to-table/"
           data-tag="python,pytorch"
           data-author="" >
            <span class="post-title" title="text_to_table">text_to_table</span>
            <span class="post-date" title="2022-07-25 19:49:50">2022/07/25</span>
        </a>
        
        
        <a  class="全部文章 5学科 G影评 "
           href="/2022/07/24/5-xue-ke/g-ying-ping/da-ming-wang-zhao-1566/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="大明王朝1566">大明王朝1566</span>
            <span class="post-date" title="2022-07-24 17:03:10">2022/07/24</span>
        </a>
        
        
        <a  class="全部文章 3修身 G奇思妙想 "
           href="/2022/07/24/3-xiu-shen/g-qi-si-miao-xiang/ni-ke-yi-ti-wo-qu-zuo-mou-jian-shi-ma/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="你可以替我去做某件事吗">你可以替我去做某件事吗</span>
            <span class="post-date" title="2022-07-24 15:59:13">2022/07/24</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2022/07/22/1-ji-suan-ji/y-shi-yan-shi/zhan-chang-ben-ti-gou-jian-1-9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="战场本体构建1-9">战场本体构建1-9</span>
            <span class="post-date" title="2022-07-22 09:23:24">2022/07/22</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2022/07/21/1-ji-suan-ji/y-shi-yan-shi/ooda/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="OODA">OODA</span>
            <span class="post-date" title="2022-07-21 11:32:54">2022/07/21</span>
        </a>
        
        
        <a  class="全部文章 2金融 E投资记录 "
           href="/2022/07/20/2-jin-rong/e-tou-zi-ji-lu/2022-nian-tou-zi-ji-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2022年投资记录">2022年投资记录</span>
            <span class="post-date" title="2022-07-20 14:48:25">2022/07/20</span>
        </a>
        
        
        <a  class="全部文章 2金融 E投资记录 "
           href="/2022/07/20/2-jin-rong/e-tou-zi-ji-lu/2021-nian-tou-zi-ji-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2021年投资记录">2021年投资记录</span>
            <span class="post-date" title="2022-07-20 14:47:52">2022/07/20</span>
        </a>
        
        
        <a  class="全部文章 3修身 D工作 "
           href="/2022/07/18/3-xiu-shen/d-gong-zuo/04-xing-ye-gong-si-gang-wei-hui-zong/"
           data-tag="Java,C++,python,PHP"
           data-author="" >
            <span class="post-title" title="04行业公司岗位汇总">04行业公司岗位汇总</span>
            <span class="post-date" title="2022-07-18 23:17:05">2022/07/18</span>
        </a>
        
        
        <a  class="全部文章 1计算机 D软件开发项目 "
           href="/2022/07/17/1-ji-suan-ji/d-ruan-jian-kai-fa-xiang-mu/da-xue-zui-hou-yi-gong-li/"
           data-tag="WAMP"
           data-author="" >
            <span class="post-title" title="大学最后一公里">大学最后一公里</span>
            <span class="post-date" title="2022-07-17 16:02:41">2022/07/17</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2022/07/15/3-xiu-shen/c-sheng-huo-zhi-shi/index/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="index">index</span>
            <span class="post-date" title="2022-07-15 19:10:05">2022/07/15</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2022/07/15/3-xiu-shen/c-sheng-huo-zhi-shi/indexs/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="indexs">indexs</span>
            <span class="post-date" title="2022-07-15 15:51:06">2022/07/15</span>
        </a>
        
        
        <a  class="全部文章 1计算机 E人工智能 "
           href="/2022/07/08/1-ji-suan-ji/e-ren-gong-zhi-neng/shen-du-xue-xi-li-hong-yi/"
           data-tag="github,python,PHP,pytorch"
           data-author="" >
            <span class="post-title" title="深度学习李宏毅">深度学习李宏毅</span>
            <span class="post-date" title="2022-07-08 19:57:13">2022/07/08</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 windows "
           href="/2022/07/06/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/windows/hexo-github-da-jian-jing-tai-bo-ke/"
           data-tag="github,Java,C++,python,PHP,pytorch,WAMP"
           data-author="" >
            <span class="post-title" title="hexo+github搭建静态博客">hexo+github搭建静态博客</span>
            <span class="post-date" title="2022-07-06 10:09:35">2022/07/06</span>
        </a>
        
        
        <a  class="全部文章 3修身 D工作 "
           href="/2022/07/01/3-xiu-shen/d-gong-zuo/01-mian-shi-jie-shao/"
           data-tag="Java,PHP"
           data-author="" >
            <span class="post-title" title="01面试介绍">01面试介绍</span>
            <span class="post-date" title="2022-07-01 16:56:21">2022/07/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2022/07/01/3-xiu-shen/e-chuang-ye/mi-xue-bing-cheng-diao-yan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="蜜雪冰城调研">蜜雪冰城调研</span>
            <span class="post-date" title="2022-07-01 00:27:36">2022/07/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2022/06/27/3-xiu-shen/c-sheng-huo-zhi-shi/tu-shu-guan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="图书馆">图书馆</span>
            <span class="post-date" title="2022-06-27 17:19:13">2022/06/27</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2022/06/23/3-xiu-shen/c-sheng-huo-zhi-shi/bei-you-2022-zhao-sheng-xuan-chuan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="北邮2022招生宣传">北邮2022招生宣传</span>
            <span class="post-date" title="2022-06-23 17:13:50">2022/06/23</span>
        </a>
        
        
        <a  class="全部文章 1计算机 J计算机理论与数学 "
           href="/2022/06/22/1-ji-suan-ji/j-ji-suan-ji-li-lun-yu-shu-xue/nao-ren-zhi/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="脑认知">脑认知</span>
            <span class="post-date" title="2022-06-22 00:23:58">2022/06/22</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Z其他计算机 "
           href="/2022/06/17/1-ji-suan-ji/z-qi-ta-ji-suan-ji/eeg-shi-yan/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="EEG实验">EEG实验</span>
            <span class="post-date" title="2022-06-17 15:57:34">2022/06/17</span>
        </a>
        
        
        <a  class="全部文章 5学科 F心理学 "
           href="/2022/06/08/5-xue-ke/f-xin-li-xue/xin-li-xue-gai-nian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="心理学概念">心理学概念</span>
            <span class="post-date" title="2022-06-08 00:33:28">2022/06/08</span>
        </a>
        
        
        <a  class="全部文章 3修身 A自修 "
           href="/2022/06/08/3-xiu-shen/a-zi-xiu/xin-li-xue/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="心理学">心理学</span>
            <span class="post-date" title="2022-06-08 00:01:16">2022/06/08</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2022/06/06/3-xiu-shen/c-sheng-huo-zhi-shi/ge-ren-du-ju-zhi-nan/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="个人独居指南">个人独居指南</span>
            <span class="post-date" title="2022-06-06 10:34:31">2022/06/06</span>
        </a>
        
        
        <a  class="全部文章 3修身 A自修 "
           href="/2022/05/24/3-xiu-shen/a-zi-xiu/nan-de/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="男德">男德</span>
            <span class="post-date" title="2022-05-24 22:34:49">2022/05/24</span>
        </a>
        
        
        <a  class="全部文章 4运动 A足球 "
           href="/2022/05/21/4-yun-dong/a-zu-qiu/cai-pan-gui-ze/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="裁判规则">裁判规则</span>
            <span class="post-date" title="2022-05-21 09:21:11">2022/05/21</span>
        </a>
        
        
        <a  class="全部文章 5学科 G影评 "
           href="/2022/05/10/5-xue-ke/g-ying-ping/er-shi-wu-er-shi-yi-dai-2022-05-10/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二十五二十一(待)">二十五二十一(待)</span>
            <span class="post-date" title="2022-05-10 00:00:00">2022/05/10</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2022/04/22/1-ji-suan-ji/y-shi-yan-shi/mo-zi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="墨子">墨子</span>
            <span class="post-date" title="2022-04-22 21:37:54">2022/04/22</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2022/04/11/3-xiu-shen/c-sheng-huo-zhi-shi/liu-xue-yi-min/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="留学移民">留学移民</span>
            <span class="post-date" title="2022-04-11 12:14:10">2022/04/11</span>
        </a>
        
        
        <a  class="全部文章 1计算机 J计算机理论与数学 "
           href="/2022/03/13/1-ji-suan-ji/j-ji-suan-ji-li-lun-yu-shu-xue/yun-ji-suan-an-quan/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="云计算安全">云计算安全</span>
            <span class="post-date" title="2022-03-13 01:31:07">2022/03/13</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2022/03/12/3-xiu-shen/c-sheng-huo-zhi-shi/shen-ti/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="身体">身体</span>
            <span class="post-date" title="2022-03-12 10:51:09">2022/03/12</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2022/03/10/3-xiu-shen/e-chuang-ye/zhu-xiao-gong-si-liu-cheng/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="注销公司流程">注销公司流程</span>
            <span class="post-date" title="2022-03-10 08:34:44">2022/03/10</span>
        </a>
        
        
        <a  class="全部文章 1计算机 D软件开发项目 "
           href="/2022/02/28/1-ji-suan-ji/d-ruan-jian-kai-fa-xiang-mu/an-zhuo-kai-fa/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安卓开发">安卓开发</span>
            <span class="post-date" title="2022-02-28 14:31:46">2022/02/28</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2022/02/24/2-jin-rong/a-jin-rong-zhi-shi/ji-jin/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基金">基金</span>
            <span class="post-date" title="2022-02-24 11:00:05">2022/02/24</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2022/02/24/3-xiu-shen/c-sheng-huo-zhi-shi/shan-zhong-yi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="陕中医">陕中医</span>
            <span class="post-date" title="2022-02-24 00:07:37">2022/02/24</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2022/02/11/2-jin-rong/a-jin-rong-zhi-shi/hong-guan-liang-hua/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="宏观量化">宏观量化</span>
            <span class="post-date" title="2022-02-11 01:11:46">2022/02/11</span>
        </a>
        
        
        <a  class="全部文章 3修身 B生活技能 "
           href="/2022/02/08/3-xiu-shen/b-sheng-huo-ji-neng/ge-ci/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="歌词">歌词</span>
            <span class="post-date" title="2022-02-08 21:18:46">2022/02/08</span>
        </a>
        
        
        <a  class="全部文章 3修身 B生活技能 "
           href="/2022/02/06/3-xiu-shen/b-sheng-huo-ji-neng/ru-he-shi-yong-liu-lan-qi-cha-jian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何使用浏览器插件">如何使用浏览器插件</span>
            <span class="post-date" title="2022-02-06 13:03:56">2022/02/06</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2022/02/05/1-ji-suan-ji/y-shi-yan-shi/shu-zi-luan-sheng/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数字孪生">数字孪生</span>
            <span class="post-date" title="2022-02-05 10:47:14">2022/02/05</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2022/01/27/2-jin-rong/a-jin-rong-zhi-shi/qi-ye-wei-guan-jing-ji-zhi-biao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="企业微观经济指标">企业微观经济指标</span>
            <span class="post-date" title="2022-01-27 23:11:24">2022/01/27</span>
        </a>
        
        
        <a  class="全部文章 3修身 B生活技能 "
           href="/2022/01/21/3-xiu-shen/b-sheng-huo-ji-neng/zhuang-xiu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="装修">装修</span>
            <span class="post-date" title="2022-01-21 18:51:33">2022/01/21</span>
        </a>
        
        
        <a  class="全部文章 3修身 G奇思妙想 "
           href="/2022/01/13/3-xiu-shen/g-qi-si-miao-xiang/guo-ren-quan-qiu-da-jiang-tang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="国任全球大讲堂">国任全球大讲堂</span>
            <span class="post-date" title="2022-01-13 23:09:16">2022/01/13</span>
        </a>
        
        
        <a  class="全部文章 3修身 F定居旅行 "
           href="/2022/01/13/3-xiu-shen/f-ding-ju-lu-xing/lu-you/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="旅游">旅游</span>
            <span class="post-date" title="2022-01-13 20:54:01">2022/01/13</span>
        </a>
        
        
        <a  class="全部文章 1计算机 D软件开发项目 "
           href="/2022/01/12/1-ji-suan-ji/d-ruan-jian-kai-fa-xiang-mu/yu-yin-xiang-mu-ji-lu/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="语音项目记录">语音项目记录</span>
            <span class="post-date" title="2022-01-12 14:23:32">2022/01/12</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2022/01/09/1-ji-suan-ji/y-shi-yan-shi/b4talk-dong-tai-lian-jie-ku/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="b4talk动态链接库">b4talk动态链接库</span>
            <span class="post-date" title="2022-01-09 15:26:31">2022/01/09</span>
        </a>
        
        
        <a  class="全部文章 5学科 B社会科学 "
           href="/2022/01/08/5-xue-ke/b-she-hui-ke-xue/pin-qiong-de-ben-zhi-2022-01-08/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="贫穷的本质">贫穷的本质</span>
            <span class="post-date" title="2022-01-08 00:00:00">2022/01/08</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2022/01/06/2-jin-rong/a-jin-rong-zhi-shi/zheng-fu-yu-suan-xu-yao-guan-zhu-de-shu-ju/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="政府预算需要关注的数据">政府预算需要关注的数据</span>
            <span class="post-date" title="2022-01-06 11:47:23">2022/01/06</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2022/01/05/2-jin-rong/a-jin-rong-zhi-shi/jing-ji-jue-ce-he-hui-yi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="经济决策和会议">经济决策和会议</span>
            <span class="post-date" title="2022-01-05 21:22:01">2022/01/05</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2022/01/05/b-jin-cheng-guan-li-typora/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="B进程管理-typora">B进程管理-typora</span>
            <span class="post-date" title="2022-01-05 00:59:40">2022/01/05</span>
        </a>
        
        
        <a  class="全部文章 3修身 B生活技能 "
           href="/2022/01/01/3-xiu-shen/b-sheng-huo-ji-neng/gan-xing-qu-zheng-shu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="感兴趣证书">感兴趣证书</span>
            <span class="post-date" title="2022-01-01 17:26:31">2022/01/01</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2022/01/01/2-jin-rong/a-jin-rong-zhi-shi/zhong-guo-shi-zheng-fu-yu-suan-de-bei-xi-zhi-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中国式政府预算的悲喜之路">中国式政府预算的悲喜之路</span>
            <span class="post-date" title="2022-01-01 15:28:58">2022/01/01</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2021/12/28/2-jin-rong/a-jin-rong-zhi-shi/fang-di-chan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="房地产">房地产</span>
            <span class="post-date" title="2021-12-28 15:42:43">2021/12/28</span>
        </a>
        
        
        <a  class="全部文章 0开发 Z刷题 "
           href="/2021/12/20/0-kai-fa/z-shua-ti/00leetcode-shua-ti-zong-jie/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="00Leetcode刷题总结">00Leetcode刷题总结</span>
            <span class="post-date" title="2021-12-20 22:28:55">2021/12/20</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2021/12/13/1-ji-suan-ji/y-shi-yan-shi/sheng-li-yin-qing-shi-yong-wen-dang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="生理引擎使用文档">生理引擎使用文档</span>
            <span class="post-date" title="2021-12-13 17:10:29">2021/12/13</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2021/12/13/1-ji-suan-ji/y-shi-yan-shi/sheng-li-yin-qing-an-zhuang-pei-zhi-wen-dang/"
           data-tag="C++,python"
           data-author="" >
            <span class="post-title" title="生理引擎安装配置文档">生理引擎安装配置文档</span>
            <span class="post-date" title="2021-12-13 16:41:41">2021/12/13</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 windows "
           href="/2021/12/08/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/windows/an-zhuang-windows7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安装windows7">安装windows7</span>
            <span class="post-date" title="2021-12-08 20:52:36">2021/12/08</span>
        </a>
        
        
        <a  class="全部文章 3修身 B生活技能 "
           href="/2021/12/07/3-xiu-shen/b-sheng-huo-ji-neng/how-to-give-a-good-presentation/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="How to give a good presentation">How to give a good presentation</span>
            <span class="post-date" title="2021-12-07 17:46:13">2021/12/07</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2021/12/06/2-jin-rong/a-jin-rong-zhi-shi/kk-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="kk总结">kk总结</span>
            <span class="post-date" title="2021-12-06 00:11:57">2021/12/06</span>
        </a>
        
        
        <a  class="全部文章 1计算机 "
           href="/2021/12/03/1-ji-suan-ji/bao-ji-kuang-jia-jie-shao-ji-shi-yong/"
           data-tag="github,Java,C++,python,PHP"
           data-author="" >
            <span class="post-title" title="包及框架介绍及使用">包及框架介绍及使用</span>
            <span class="post-date" title="2021-12-03 11:51:33">2021/12/03</span>
        </a>
        
        
        <a  class="全部文章 1计算机 E人工智能 "
           href="/2021/11/29/1-ji-suan-ji/e-ren-gong-zhi-neng/gao-ji-ji-qi-xue-xi-ke-cheng-zuo-ye-1-he-2/"
           data-tag="python,pytorch"
           data-author="" >
            <span class="post-title" title="高级机器学习课程作业1和2">高级机器学习课程作业1和2</span>
            <span class="post-date" title="2021-11-29 10:31:43">2021/11/29</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2021/11/27/3-xiu-shen/c-sheng-huo-zhi-shi/she-hui-bao-xian-yang-lao-bao-xian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="社会保险养老保险">社会保险养老保险</span>
            <span class="post-date" title="2021-11-27 20:28:50">2021/11/27</span>
        </a>
        
        
        <a  class="全部文章 3修身 A自修 "
           href="/2021/11/26/3-xiu-shen/a-zi-xiu/xin-xi-su-yang/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="信息素养">信息素养</span>
            <span class="post-date" title="2021-11-26 18:46:10">2021/11/26</span>
        </a>
        
        
        <a  class="全部文章 5学科 D政治 "
           href="/2021/11/26/5-xue-ke/d-zheng-zhi/shi-jiu-da-dang-zhang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="十九大党章">十九大党章</span>
            <span class="post-date" title="2021-11-26 16:43:08">2021/11/26</span>
        </a>
        
        
        <a  class="全部文章 5学科 D政治 "
           href="/2021/11/26/5-xue-ke/d-zheng-zhi/ji-ji-fen-zi-dang-ke-xue-xi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="积极分子党课学习">积极分子党课学习</span>
            <span class="post-date" title="2021-11-26 14:46:07">2021/11/26</span>
        </a>
        
        
        <a  class="全部文章 2金融 D投资策略 "
           href="/2021/11/26/2-jin-rong/d-tou-zi-ce-lue/bu-yao-ba-tou-zi-jiao-liu-dang-zuo-tou-zi-xue-xi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="不要把投资交流当作投资学习">不要把投资交流当作投资学习</span>
            <span class="post-date" title="2021-11-26 11:41:11">2021/11/26</span>
        </a>
        
        
        <a  class="全部文章 3修身 G奇思妙想 "
           href="/2021/11/25/3-xiu-shen/g-qi-si-miao-xiang/guan-yu-yi-shi-xing-tai-he-wen-hua-guan-xi-de-si-kao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="关于意识形态和文化关系的思考">关于意识形态和文化关系的思考</span>
            <span class="post-date" title="2021-11-25 23:32:18">2021/11/25</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 VsCode "
           href="/2021/11/22/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/vscode/python-an-zhuang-bao-mu-lu/"
           data-tag="python,pytorch"
           data-author="" >
            <span class="post-title" title="python安装包目录">python安装包目录</span>
            <span class="post-date" title="2021-11-22 11:12:33">2021/11/22</span>
        </a>
        
        
        <a  class="全部文章 5学科 D政治 "
           href="/2021/11/20/5-xue-ke/d-zheng-zhi/gong-chan-dang-xuan-yan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="共产党宣言">共产党宣言</span>
            <span class="post-date" title="2021-11-20 23:32:32">2021/11/20</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2021/11/18/e-shu-chu-guan-li-typora-fierfox-zotero-freemind/"
           data-tag="github,Java,C++,python,PHP"
           data-author="" >
            <span class="post-title" title="E输出管理-typora+fierfox+zotero+freemind">E输出管理-typora+fierfox+zotero+freemind</span>
            <span class="post-date" title="2021-11-18 18:44:23">2021/11/18</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 C "
           href="/2021/11/12/1-ji-suan-ji/a-bian-cheng-yu-yan/c/cmake/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="Cmake">Cmake</span>
            <span class="post-date" title="2021-11-12 21:01:28">2021/11/12</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2021/11/03/3-xiu-shen/e-chuang-ye/qi-ye-jue-ce-mo-ni-bi-sai-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="企业决策模拟比赛总结">企业决策模拟比赛总结</span>
            <span class="post-date" title="2021-11-03 23:50:04">2021/11/03</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2021/10/25/3-xiu-shen/e-chuang-ye/jue-ce-mo-ni/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="决策模拟">决策模拟</span>
            <span class="post-date" title="2021-10-25 23:01:41">2021/10/25</span>
        </a>
        
        
        <a  class="全部文章 2金融 C行业个股 "
           href="/2021/10/25/2-jin-rong/c-xing-ye-ge-gu/zhong-gong-jiao-yu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中公教育">中公教育</span>
            <span class="post-date" title="2021-10-25 20:12:32">2021/10/25</span>
        </a>
        
        
        <a  class="全部文章 4运动 A足球 "
           href="/2021/10/24/4-yun-dong/a-zu-qiu/ti-qiu-jing-yan-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="踢球经验总结">踢球经验总结</span>
            <span class="post-date" title="2021-10-24 23:41:05">2021/10/24</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2021/10/22/3-xiu-shen/e-chuang-ye/qi-ye-jue-ce-mo-ni-bi-sai-gui-ze/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="企业决策模拟比赛规则">企业决策模拟比赛规则</span>
            <span class="post-date" title="2021-10-22 23:07:51">2021/10/22</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2021/10/22/2-jin-rong/a-jin-rong-zhi-shi/gu-xi-gu-li-yu-chu-xi-chu-quan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="股息股利与除息除权">股息股利与除息除权</span>
            <span class="post-date" title="2021-10-22 15:13:04">2021/10/22</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2021/10/22/2-jin-rong/a-jin-rong-zhi-shi/ya-zhou-98-nian-jin-rong-wei-ji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="亚洲98年金融危机">亚洲98年金融危机</span>
            <span class="post-date" title="2021-10-22 01:15:26">2021/10/22</span>
        </a>
        
        
        <a  class="全部文章 4运动 A足球 "
           href="/2021/10/18/4-yun-dong/a-zu-qiu/yue-wei-pan-fa/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="越位判罚">越位判罚</span>
            <span class="post-date" title="2021-10-18 00:01:37">2021/10/18</span>
        </a>
        
        
        <a  class="全部文章 4运动 A足球 "
           href="/2021/10/17/4-yun-dong/a-zu-qiu/zu-qiu-cai-pan-ji-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="足球裁判记录">足球裁判记录</span>
            <span class="post-date" title="2021-10-17 20:50:04">2021/10/17</span>
        </a>
        
        
        <a  class="全部文章 5学科 D政治 "
           href="/2021/10/16/5-xue-ke/d-zheng-zhi/dang-ke-dang-de-guang-hui-li-shi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="党课党的光辉历史">党课党的光辉历史</span>
            <span class="post-date" title="2021-10-16 20:25:18">2021/10/16</span>
        </a>
        
        
        <a  class="全部文章 2金融 D投资策略 "
           href="/2021/10/13/2-jin-rong/d-tou-zi-ce-lue/tou-zi-sui-bi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="投资随笔">投资随笔</span>
            <span class="post-date" title="2021-10-13 16:58:49">2021/10/13</span>
        </a>
        
        
        <a  class="全部文章 2金融 D投资策略 "
           href="/2021/10/13/2-jin-rong/d-tou-zi-ce-lue/jie-zhi-tou-zi-vs-ji-zhu-tou-ji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="价值投资vs技术投机">价值投资vs技术投机</span>
            <span class="post-date" title="2021-10-13 15:02:32">2021/10/13</span>
        </a>
        
        
        <a  class="全部文章 2金融 C行业个股 "
           href="/2021/10/09/2-jin-rong/c-xing-ye-ge-gu/zhong-guo-ping-an/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="中国平安">中国平安</span>
            <span class="post-date" title="2021-10-09 15:46:55">2021/10/09</span>
        </a>
        
        
        <a  class="全部文章 2金融 D投资策略 "
           href="/2021/10/09/2-jin-rong/d-tou-zi-ce-lue/ding-tou-ce-lue-si-kao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="定投策略思考">定投策略思考</span>
            <span class="post-date" title="2021-10-09 15:32:41">2021/10/09</span>
        </a>
        
        
        <a  class="全部文章 2金融 D投资策略 "
           href="/2021/10/09/2-jin-rong/d-tou-zi-ce-lue/tou-zi-li-nian-shi-tiao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="投资理念十条">投资理念十条</span>
            <span class="post-date" title="2021-10-09 14:47:12">2021/10/09</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 "
           href="/2021/10/07/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/typora-shi-shi-me/"
           data-tag="github,Java"
           data-author="" >
            <span class="post-title" title="Typora 是什么？">Typora 是什么？</span>
            <span class="post-date" title="2021-10-07 23:15:08">2021/10/07</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 JAVA "
           href="/2021/10/04/1-ji-suan-ji/a-bian-cheng-yu-yan/java/java-xue-xi-lu-xian/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="Java学习路线">Java学习路线</span>
            <span class="post-date" title="2021-10-04 19:43:51">2021/10/04</span>
        </a>
        
        
        <a  class="全部文章 3修身 B生活技能 "
           href="/2021/10/03/3-xiu-shen/b-sheng-huo-ji-neng/shou-ji-xuan-gou/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="手机选购">手机选购</span>
            <span class="post-date" title="2021-10-03 14:34:46">2021/10/03</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2021/10/03/3-xiu-shen/c-sheng-huo-zhi-shi/shou-ji-zhu-ce-zhang-hao-guan-li/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="手机注册账号管理">手机注册账号管理</span>
            <span class="post-date" title="2021-10-03 00:15:58">2021/10/03</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2021/10/03/3-xiu-shen/c-sheng-huo-zhi-shi/tuo-hang-ji-hua-mian-shi-zong-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="拓航计划面试总结">拓航计划面试总结</span>
            <span class="post-date" title="2021-10-03 00:14:25">2021/10/03</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2021/10/02/3-xiu-shen/c-sheng-huo-zhi-shi/ben-ke-bi-ye-lun-wen-jin-zhan/"
           data-tag="github,Java,python,pytorch"
           data-author="" >
            <span class="post-title" title="本科毕业论文进展">本科毕业论文进展</span>
            <span class="post-date" title="2021-10-02 19:06:41">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2021/10/02/3-xiu-shen/c-sheng-huo-zhi-shi/bi-ye-lun-wen-si-lu-he-can-kao-zi-liao/"
           data-tag="github,PHP"
           data-author="" >
            <span class="post-title" title="毕业论文思路和参考资料">毕业论文思路和参考资料</span>
            <span class="post-date" title="2021-10-02 19:04:15">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 3修身 D工作 "
           href="/2021/10/02/3-xiu-shen/d-gong-zuo/she-bao-he-wu-xian-yi-jin/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="社保和五险一金">社保和五险一金</span>
            <span class="post-date" title="2021-10-02 18:59:33">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 3修身 D工作 "
           href="/2021/10/02/3-xiu-shen/d-gong-zuo/ji-ti-hu-kou-xiang-guan-shi-xiang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="集体户口相关事项">集体户口相关事项</span>
            <span class="post-date" title="2021-10-02 18:58:45">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 其它 "
           href="/2021/10/02/1-ji-suan-ji/a-bian-cheng-yu-yan/qi-ta/neo4j-tu-cha-xun-yu-ju/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="neo4j图查询语句">neo4j图查询语句</span>
            <span class="post-date" title="2021-10-02 18:52:19">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 3修身 A自修 "
           href="/2021/10/02/3-xiu-shen/a-zi-xiu/yan-jiu-sheng-jie-duan-zhun-bei/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="研究生阶段准备">研究生阶段准备</span>
            <span class="post-date" title="2021-10-02 18:51:31">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 其它 "
           href="/2021/10/02/1-ji-suan-ji/a-bian-cheng-yu-yan/qi-ta/linux-ling-san-zhi-shi-dian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="linux零散知识点">linux零散知识点</span>
            <span class="post-date" title="2021-10-02 18:32:34">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 windows "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/windows/an-zhuang-reactnative/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="安装ReactNative">安装ReactNative</span>
            <span class="post-date" title="2021-10-02 18:01:21">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 其它 "
           href="/2021/10/02/1-ji-suan-ji/a-bian-cheng-yu-yan/qi-ta/bian-yi-yuan-li-ci-fa-fen-xi-cheng-xu-wen-dang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="编译原理词法分析程序文档">编译原理词法分析程序文档</span>
            <span class="post-date" title="2021-10-02 18:00:49">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 其它 "
           href="/2021/10/02/1-ji-suan-ji/a-bian-cheng-yu-yan/qi-ta/bian-yi-yuan-li-ebnf-to-bnf/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="编译原理EBNF To BNF">编译原理EBNF To BNF</span>
            <span class="post-date" title="2021-10-02 17:59:24">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 其它 "
           href="/2021/10/02/1-ji-suan-ji/a-bian-cheng-yu-yan/qi-ta/bian-yi-yuan-li-yu-fa-fen-xi-cheng-xu-wen-dang/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="编译原理语法分析程序文档">编译原理语法分析程序文档</span>
            <span class="post-date" title="2021-10-02 17:58:49">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 WAMP "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/wamp/wamp-she-zhi-xu-ni-zhu-ji-hou-bu-neng-fang-wen-wen-ti/"
           data-tag="WAMP"
           data-author="" >
            <span class="post-title" title="WAMP设置虚拟主机后不能访问问题">WAMP设置虚拟主机后不能访问问题</span>
            <span class="post-date" title="2021-10-02 17:53:26">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 WAMP "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/wamp/wamp-yuan-cheng-zhu-ji-she-zhi-xu-ni-zhu-ji/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="WAMP远程主机设置虚拟主机">WAMP远程主机设置虚拟主机</span>
            <span class="post-date" title="2021-10-02 17:45:44">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 I计算机图形学 "
           href="/2021/10/02/1-ji-suan-ji/i-ji-suan-ji-tu-xing-xue/shu-zi-tu-xiang-chu-li-ke-cheng-bi-ji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数字图像处理课程笔记">数字图像处理课程笔记</span>
            <span class="post-date" title="2021-10-02 17:02:04">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 I计算机图形学 "
           href="/2021/10/02/1-ji-suan-ji/i-ji-suan-ji-tu-xing-xue/ping-mu-huan-chong-qu-li-jie/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="屏幕缓冲区理解">屏幕缓冲区理解</span>
            <span class="post-date" title="2021-10-02 17:00:19">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 F计算机网络 "
           href="/2021/10/02/1-ji-suan-ji/f-ji-suan-ji-wang-luo/jian-yi-liao-tian-ruan-jian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="简易聊天软件">简易聊天软件</span>
            <span class="post-date" title="2021-10-02 16:19:29">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 F计算机网络 "
           href="/2021/10/02/1-ji-suan-ji/f-ji-suan-ji-wang-luo/ji-suan-ji-wang-luo-ke-cheng-zhi-shi-tu-pu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络课程知识图谱">计算机网络课程知识图谱</span>
            <span class="post-date" title="2021-10-02 16:18:05">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 WAMP "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/wamp/wamp-tong-yi-ge-fu-wu-qi-pei-zhi-duo-ge-wang-zhan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="WAMP同一个服务器配置多个网站">WAMP同一个服务器配置多个网站</span>
            <span class="post-date" title="2021-10-02 16:11:44">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 linux "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/linux/teng-xun-yun-fu-wu-qi-bao-ta-wordpress-an-zhuang-ge-ren-bo-ke/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="腾讯云服务器+宝塔+wordpress安装个人博客">腾讯云服务器+宝塔+wordpress安装个人博客</span>
            <span class="post-date" title="2021-10-02 16:10:05">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 E人工智能 "
           href="/2021/10/02/1-ji-suan-ji/e-ren-gong-zhi-neng/san-chong-sou-suo-suan-fa-jie-8-shu-ma-wen-ti/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="三种搜索算法解8数码问题">三种搜索算法解8数码问题</span>
            <span class="post-date" title="2021-10-02 14:56:49">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 E人工智能 "
           href="/2021/10/02/1-ji-suan-ji/e-ren-gong-zhi-neng/shen-jing-wang-luo-bp-suan-fa-xi-tong-kai-fa-yu-yan-zheng/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="神经网络 BP算法系统开发与验证">神经网络 BP算法系统开发与验证</span>
            <span class="post-date" title="2021-10-02 14:44:53">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 WAMP "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/wamp/wamp-guan-yu-lian-jie-shu-ju-ku-shi-bai-de-ke-neng-xing/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="WAMP关于连接数据库失败的可能性">WAMP关于连接数据库失败的可能性</span>
            <span class="post-date" title="2021-10-02 14:41:04">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 Python "
           href="/2021/10/02/1-ji-suan-ji/a-bian-cheng-yu-yan/python/python-xue-xi-lu-xian/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="python学习路线">python学习路线</span>
            <span class="post-date" title="2021-10-02 14:36:40">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 G计算机硬件 "
           href="/2021/10/02/1-ji-suan-ji/g-ji-suan-ji-ying-jian/shu-mei-pai-yan-shi-dian-ying/"
           data-tag="github,python"
           data-author="" >
            <span class="post-title" title="树莓派延时电影">树莓派延时电影</span>
            <span class="post-date" title="2021-10-02 14:26:28">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 A编程语言 其它 "
           href="/2021/10/02/1-ji-suan-ji/a-bian-cheng-yu-yan/qi-ta/shell-xue-xi-bi-ji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell学习笔记">Shell学习笔记</span>
            <span class="post-date" title="2021-10-02 14:21:05">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/idea-an-zhuang-ji-shi-yong/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="IDEA安装及使用">IDEA安装及使用</span>
            <span class="post-date" title="2021-10-02 13:16:19">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 WAMP "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/wamp/wamp-da-jian-ti-shi/"
           data-tag="PHP,WAMP"
           data-author="" >
            <span class="post-title" title="WAMP搭建提示">WAMP搭建提示</span>
            <span class="post-date" title="2021-10-02 13:00:30">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 WAMP "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/wamp/wamp-pei-zhi-yu-ming/"
           data-tag="WAMP"
           data-author="" >
            <span class="post-title" title="WAMP配置域名">WAMP配置域名</span>
            <span class="post-date" title="2021-10-02 12:04:50">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 windows "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/windows/an-zhuang-mysql/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安装mysql">安装mysql</span>
            <span class="post-date" title="2021-10-02 11:56:10">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/sublime-an-zhuang-ji-shi-yong/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Sublime安装及使用">Sublime安装及使用</span>
            <span class="post-date" title="2021-10-02 11:54:55">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Z其他计算机 "
           href="/2021/10/02/1-ji-suan-ji/z-qi-ta-ji-suan-ji/ji-lu-yi-ci-guan-yu-bo-cai-pa-chong-jiao-yu-men-hu-wang-zhan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="记录一次关于菠菜爬虫教育门户网站">记录一次关于菠菜爬虫教育门户网站</span>
            <span class="post-date" title="2021-10-02 11:54:03">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2021/10/02/2-jin-rong/a-jin-rong-zhi-shi/guan-yu-wai-hui-he-jing-wai-mai-fang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="关于外汇和境外买房">关于外汇和境外买房</span>
            <span class="post-date" title="2021-10-02 11:44:45">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2021/10/02/2-jin-rong/a-jin-rong-zhi-shi/zhuan-gu-jie-zhi-shi-shi-me-yi-si/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="转股价值是什么意思">转股价值是什么意思</span>
            <span class="post-date" title="2021-10-02 11:40:12">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2021/10/02/2-jin-rong/a-jin-rong-zhi-shi/chang-wai-ji-jin-he-chang-nei-ji-jin-shou-xu-fei-bi-jiao/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="场外基金和场内基金手续费比较">场外基金和场内基金手续费比较</span>
            <span class="post-date" title="2021-10-02 11:35:56">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2021/10/02/3-xiu-shen/e-chuang-ye/shen-qing-qi-ye-zhang-hu-wei-xin-xiao-cheng-xu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="申请企业账户微信小程序">申请企业账户微信小程序</span>
            <span class="post-date" title="2021-10-02 11:33:42">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2021/10/02/3-xiu-shen/e-chuang-ye/wei-xin-zhi-fu-ping-tai-de-kai-tong/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="微信支付平台的开通">微信支付平台的开通</span>
            <span class="post-date" title="2021-10-02 11:31:00">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2021/10/02/3-xiu-shen/e-chuang-ye/wei-xin-gong-zhong-ping-tai-ren-zheng-wei-qi-ye/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="微信公众平台认证为企业">微信公众平台认证为企业</span>
            <span class="post-date" title="2021-10-02 11:26:01">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2021/10/02/3-xiu-shen/e-chuang-ye/ge-ren-cheng-xu-qian-yi-wei-qi-ye/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="个人程序迁移为企业">个人程序迁移为企业</span>
            <span class="post-date" title="2021-10-02 11:24:08">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 linux "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/linux/liang-tai-linux-zhu-ji-lian-jie-mysql-yuan-cheng-shu-ju-ku-shi-bai-de-jing-yan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="两台Linux主机连接mysql远程数据库失败的经验">两台Linux主机连接mysql远程数据库失败的经验</span>
            <span class="post-date" title="2021-10-02 00:38:58">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 D软件开发项目 "
           href="/2021/10/02/1-ji-suan-ji/d-ruan-jian-kai-fa-xiang-mu/xiao-cheng-xu-xue-xi-zhi-nan/"
           data-tag="github,Java,PHP,WAMP"
           data-author="" >
            <span class="post-title" title="小程序学习指南">小程序学习指南</span>
            <span class="post-date" title="2021-10-02 00:33:40">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 VsCode "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/vscode/an-zhuang-pytorch-yu-dao-de-wen-ti/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安装Pytorch遇到的问题">安装Pytorch遇到的问题</span>
            <span class="post-date" title="2021-10-02 00:32:27">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 VsCode "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/vscode/python-pei-zhi-yi-ge-guan-yu-pil-de-wen-ti/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="Python配置一个关于PIL的问题">Python配置一个关于PIL的问题</span>
            <span class="post-date" title="2021-10-02 00:28:38">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 VsCode "
           href="/2021/10/02/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/vscode/vscode-pei-zhi-kuai-jie-jian-yun-xing-python-wen-jian/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="VSCODE配置快捷键运行Python文件">VSCODE配置快捷键运行Python文件</span>
            <span class="post-date" title="2021-10-02 00:27:49">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Z其他计算机 "
           href="/2021/10/02/1-ji-suan-ji/z-qi-ta-ji-suan-ji/pei-zhi-github12306-xiang-mu/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="配置github12306项目">配置github12306项目</span>
            <span class="post-date" title="2021-10-02 00:18:43">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Z其他计算机 "
           href="/2021/10/02/1-ji-suan-ji/z-qi-ta-ji-suan-ji/bian-ma-fang-shi-asciiunicodeutf-8utf-16-bian-xi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="编码方式-ASCIIUnicodeUTF-8UTF-16辨析">编码方式-ASCIIUnicodeUTF-8UTF-16辨析</span>
            <span class="post-date" title="2021-10-02 00:12:17">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Z其他计算机 "
           href="/2021/10/02/1-ji-suan-ji/z-qi-ta-ji-suan-ji/pa-chong-pa-dao-de-shi-shi-me/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="爬虫爬到的&amp;#是什么">爬虫爬到的&amp;#是什么</span>
            <span class="post-date" title="2021-10-02 00:10:04">2021/10/02</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 windows "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/windows/yi-tai-dian-nao-pei-zhi-liang-ge-github-zhang-hao-er/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="一台电脑配置两个github账号二">一台电脑配置两个github账号二</span>
            <span class="post-date" title="2021-10-01 23:57:10">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 windows "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/windows/yi-tai-dian-nao-pei-zhi-liang-ge-github-zhang-hao/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="一台电脑配置两个github账号">一台电脑配置两个github账号</span>
            <span class="post-date" title="2021-10-01 23:53:37">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 VsCode "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/vscode/pei-zhi-github-xiang-mu-weibo-daily-hotkey/"
           data-tag="github,python"
           data-author="" >
            <span class="post-title" title="配置github项目——weibo_daily_hotkey">配置github项目——weibo_daily_hotkey</span>
            <span class="post-date" title="2021-10-01 23:50:36">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 Vs2019 "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/vs2019/vs2019-pei-zhi-lian-jie-shu-ju-ku/"
           data-tag="C++,WAMP"
           data-author="" >
            <span class="post-title" title="vs2019配置连接数据库">vs2019配置连接数据库</span>
            <span class="post-date" title="2021-10-01 23:47:48">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 linux "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/linux/an-zhuang-pei-zhi-llvm/"
           data-tag="github,C++"
           data-author="" >
            <span class="post-title" title="安装配置llvm">安装配置llvm</span>
            <span class="post-date" title="2021-10-01 23:46:27">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 linux "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/linux/an-zhuang-pei-zhi-flex-bison-deng/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="安装配置flex+bison等">安装配置flex+bison等</span>
            <span class="post-date" title="2021-10-01 23:43:46">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 C算法与数据结构 "
           href="/2021/10/01/1-ji-suan-ji/c-suan-fa-yu-shu-ju-jie-gou/apriori-suan-fa/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="Apriori算法">Apriori算法</span>
            <span class="post-date" title="2021-10-01 23:41:14">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 VsCode "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/vscode/pei-zhi-jeesite-yun-xing-huan-jing/"
           data-tag="github,Java"
           data-author="" >
            <span class="post-title" title="配置Jeesite运行环境">配置Jeesite运行环境</span>
            <span class="post-date" title="2021-10-01 23:32:06">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 VsCode "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/vscode/pei-zhi-github-xiang-mu-ccks-kg/"
           data-tag="python,pytorch"
           data-author="" >
            <span class="post-title" title="配置github项目ccks_kg">配置github项目ccks_kg</span>
            <span class="post-date" title="2021-10-01 23:28:59">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 linux "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/linux/centos7-an-zhuang-bu-tong-ban-ben-de-python-bing-she-zhi-mo-ren-python/"
           data-tag="github,python"
           data-author="" >
            <span class="post-title" title="centos7安装不同版本的python并设置默认python">centos7安装不同版本的python并设置默认python</span>
            <span class="post-date" title="2021-10-01 23:27:20">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 linux "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/linux/an-zhuang-wordpress-ming-ling-xing-gong-ju-wp-cli-lai-guan-li-wordpress/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="安装wordpress命令行工具WP-CLI来管理wordpress">安装wordpress命令行工具WP-CLI来管理wordpress</span>
            <span class="post-date" title="2021-10-01 23:25:41">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 linux "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/linux/zai-yun-fu-wu-qi-shang-bu-shu-jian-kong-gu-shi-jiao-ben/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="在云服务器上部署监控股市脚本">在云服务器上部署监控股市脚本</span>
            <span class="post-date" title="2021-10-01 23:23:07">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 VsCode "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/vscode/an-zhuang-tensorflow/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="安装tensorflow">安装tensorflow</span>
            <span class="post-date" title="2021-10-01 23:19:16">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 linux "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/linux/zai-yun-fu-wu-qi-shang-gua-qi-jiao-ben-zhi-xing-pa-qu-shu-ju-ren-wu-xu-yao-zhu-yi-de-dian/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="《在云服务器上挂起脚本执行爬取数据任务需要注意的点》">《在云服务器上挂起脚本执行爬取数据任务需要注意的点》</span>
            <span class="post-date" title="2021-10-01 23:16:51">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 VsCode "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/vscode/an-zhuang-pei-zhi-senta/"
           data-tag="github,python"
           data-author="" >
            <span class="post-title" title="安装配置senta">安装配置senta</span>
            <span class="post-date" title="2021-10-01 23:11:15">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 linux "
           href="/2021/10/01/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/linux/zai-zi-ji-de-fu-wu-qi-shang-an-zhuang-git-fu-wu-qi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="在自己的服务器上安装git服务器">在自己的服务器上安装git服务器</span>
            <span class="post-date" title="2021-10-01 23:10:24">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 G奇思妙想 "
           href="/2021/10/01/3-xiu-shen/g-qi-si-miao-xiang/xue-xi-gan-zhi-ji-hou-de-xiang-fa/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="学习感知机后的想法">学习感知机后的想法</span>
            <span class="post-date" title="2021-10-01 23:01:26">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 B生活技能 "
           href="/2021/10/01/3-xiu-shen/b-sheng-huo-ji-neng/kuan-dai-jie-ru/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="宽带接入">宽带接入</span>
            <span class="post-date" title="2021-10-01 22:58:33">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2021/10/01/3-xiu-shen/c-sheng-huo-zhi-shi/gao-shu-shu-xue-zi-liao-de-xuan-ze/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高数数学资料的选择">高数数学资料的选择</span>
            <span class="post-date" title="2021-10-01 22:51:16">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 G奇思妙想 "
           href="/2021/10/01/3-xiu-shen/g-qi-si-miao-xiang/ju-zhen-yu-shi-ji-sheng-huo-xiang-lian-xi/"
           data-tag="PHP"
           data-author="" >
            <span class="post-title" title="矩阵与实际生活相联系">矩阵与实际生活相联系</span>
            <span class="post-date" title="2021-10-01 22:48:21">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2021/10/01/3-xiu-shen/c-sheng-huo-zhi-shi/kao-yan-jing-yan-fen-xiang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="考研经验分享">考研经验分享</span>
            <span class="post-date" title="2021-10-01 22:47:45">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 5学科 A文学 村上春树 "
           href="/2021/10/01/5-xue-ke/a-wen-xue/cun-shang-chun-shu/guo-jing-yi-nan-tai-yang-yi-xi-cun-shang-xiao-shuo-xun-li-qi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="国境以南，太阳以西——村上小说巡礼七">国境以南，太阳以西——村上小说巡礼七</span>
            <span class="post-date" title="2021-10-01 22:45:00">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 5学科 A文学 村上春树 "
           href="/2021/10/01/5-xue-ke/a-wen-xue/cun-shang-chun-shu/nuo-wei-de-sen-lin-cun-shang-xiao-shuo-xun-li-wu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="挪威的森林——村上小说巡礼五">挪威的森林——村上小说巡礼五</span>
            <span class="post-date" title="2021-10-01 22:44:57">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 5学科 A文学 村上春树 "
           href="/2021/10/01/5-xue-ke/a-wen-xue/cun-shang-chun-shu/wu-wu-wu-cun-shang-xiao-shuo-xun-li-liu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="舞舞舞——村上小说巡礼六">舞舞舞——村上小说巡礼六</span>
            <span class="post-date" title="2021-10-01 22:44:39">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 5学科 A文学 村上春树 "
           href="/2021/10/01/5-xue-ke/a-wen-xue/cun-shang-chun-shu/shi-jie-jin-tou-he-leng-ku-xian-jing-cun-shang-xiao-shuo-xun-li-si/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="世界尽头和冷酷仙境——村上小说巡礼四">世界尽头和冷酷仙境——村上小说巡礼四</span>
            <span class="post-date" title="2021-10-01 22:44:16">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 5学科 A文学 村上春树 "
           href="/2021/10/01/5-xue-ke/a-wen-xue/cun-shang-chun-shu/xun-yang-mou-xian-ji-cun-shang-xiao-shuo-xun-li-san/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="寻羊冒险记——村上小说巡礼三">寻羊冒险记——村上小说巡礼三</span>
            <span class="post-date" title="2021-10-01 22:40:57">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 5学科 A文学 村上春树 "
           href="/2021/10/01/5-xue-ke/a-wen-xue/cun-shang-chun-shu/1973-nian-de-dan-zi-qiu-cun-shang-xiao-shuo-xun-li-er/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="1973年的弹子球——村上小说巡礼二">1973年的弹子球——村上小说巡礼二</span>
            <span class="post-date" title="2021-10-01 22:39:55">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2021/10/01/3-xiu-shen/e-chuang-ye/kuai-di-dai-qu-xiang-mu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="快递代取项目">快递代取项目</span>
            <span class="post-date" title="2021-10-01 22:25:44">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 G奇思妙想 "
           href="/2021/10/01/3-xiu-shen/g-qi-si-miao-xiang/li-shang-an-ge-qu-dui-bi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="李上安歌曲对比">李上安歌曲对比</span>
            <span class="post-date" title="2021-10-01 22:02:57">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2021/10/01/3-xiu-shen/e-chuang-ye/fu-wu-qi-yu-yu-ming-gou-mai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="服务器与域名购买">服务器与域名购买</span>
            <span class="post-date" title="2021-10-01 21:42:58">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 3修身 E创业 "
           href="/2021/10/01/3-xiu-shen/e-chuang-ye/chuang-ban-gong-si-liu-cheng/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创办公司流程">创办公司流程</span>
            <span class="post-date" title="2021-10-01 21:36:31">2021/10/01</span>
        </a>
        
        
        <a  class="全部文章 2金融 E投资记录 "
           href="/2021/09/30/2-jin-rong/e-tou-zi-ji-lu/2020-nian-tou-zi-ji-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2020年投资记录">2020年投资记录</span>
            <span class="post-date" title="2021-09-30 00:38:12">2021/09/30</span>
        </a>
        
        
        <a  class="全部文章 3修身 B生活技能 "
           href="/2021/09/30/3-xiu-shen/b-sheng-huo-ji-neng/zheng-quan-cong-ye-zi-ge-kao-shi-ji-lu/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="证券从业资格考试记录">证券从业资格考试记录</span>
            <span class="post-date" title="2021-09-30 00:34:31">2021/09/30</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2021/09/29/2-jin-rong/a-jin-rong-zhi-shi/jin-qian-guan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="金钱观">金钱观</span>
            <span class="post-date" title="2021-09-29 00:49:05">2021/09/29</span>
        </a>
        
        
        <a  class="全部文章 2金融 D投资策略 "
           href="/2021/09/28/2-jin-rong/d-tou-zi-ce-lue/wei-shi-me-bu-yao-jin-jian-gu-qun-he-gen-zhao-gu-piao-da-v-zou/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="为什么不要进荐股群和跟着股票大V走？">为什么不要进荐股群和跟着股票大V走？</span>
            <span class="post-date" title="2021-09-28 21:39:53">2021/09/28</span>
        </a>
        
        
        <a  class="全部文章 5学科 D政治 "
           href="/2021/09/21/5-xue-ke/d-zheng-zhi/xue-xi-gong-chan-zhu-yi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="学习共产主义">学习共产主义</span>
            <span class="post-date" title="2021-09-21 15:23:58">2021/09/21</span>
        </a>
        
        
        <a  class="全部文章 2金融 A金融知识 "
           href="/2021/09/20/2-jin-rong/a-jin-rong-zhi-shi/fintech-jin-rong-ke-ji-de-chuang-xin-chuang-ye-yu-an-li/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="FinTech+金融科技的创新,创业与案例">FinTech+金融科技的创新,创业与案例</span>
            <span class="post-date" title="2021-09-20 12:14:55">2021/09/20</span>
        </a>
        
        
        <a  class="全部文章 4运动 A足球 "
           href="/2021/09/18/4-yun-dong/a-zu-qiu/cai-pan-zhi-ze/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="裁判职责">裁判职责</span>
            <span class="post-date" title="2021-09-18 23:55:14">2021/09/18</span>
        </a>
        
        
        <a  class="全部文章 4运动 A足球 "
           href="/2021/09/16/4-yun-dong/a-zu-qiu/di-si-guan-yuan-zhi-ze/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="第四官员职责">第四官员职责</span>
            <span class="post-date" title="2021-09-16 00:04:38">2021/09/16</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Z其他计算机 "
           href="/2021/09/14/1-ji-suan-ji/z-qi-ta-ji-suan-ji/ji-suan-ji-lun-wen-fa-biao/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="计算机论文发表">计算机论文发表</span>
            <span class="post-date" title="2021-09-14 19:11:31">2021/09/14</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2021/09/14/3-xiu-shen/c-sheng-huo-zhi-shi/wen-xue-su-cai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="文学素材">文学素材</span>
            <span class="post-date" title="2021-09-14 19:03:54">2021/09/14</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2021/09/14/3-xiu-shen/c-sheng-huo-zhi-shi/xiao-hua/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="笑话">笑话</span>
            <span class="post-date" title="2021-09-14 19:02:50">2021/09/14</span>
        </a>
        
        
        <a  class="全部文章 5学科 B社会科学 "
           href="/2021/09/14/5-xue-ke/b-she-hui-ke-xue/xiang-tu-zhong-guo/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="乡土中国">乡土中国</span>
            <span class="post-date" title="2021-09-14 19:01:01">2021/09/14</span>
        </a>
        
        
        <a  class="全部文章 5学科 B社会科学 "
           href="/2021/09/13/5-xue-ke/b-she-hui-ke-xue/she-hui-xing-dong-wu-wei/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="社会性动物(未)">社会性动物(未)</span>
            <span class="post-date" title="2021-09-13 22:25:00">2021/09/13</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2021/09/13/1-ji-suan-ji/y-shi-yan-shi/pjsua2-python-ben-di-fu-xian/"
           data-tag="C++,python"
           data-author="" >
            <span class="post-title" title="pjsua2_python本地复现">pjsua2_python本地复现</span>
            <span class="post-date" title="2021-09-13 22:20:53">2021/09/13</span>
        </a>
        
        
        <a  class="全部文章 1计算机 "
           href="/2021/09/13/1-ji-suan-ji/ying-yong-ruan-jian-ji-kai-fa-huan-jing/"
           data-tag="github,Java,C++,python,PHP"
           data-author="" >
            <span class="post-title" title="应用软件及开发环境">应用软件及开发环境</span>
            <span class="post-date" title="2021-09-13 21:26:05">2021/09/13</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2021/09/07/1-ji-suan-ji/y-shi-yan-shi/biogears/"
           data-tag="github,Java,C++,python"
           data-author="" >
            <span class="post-title" title="biogears">biogears</span>
            <span class="post-date" title="2021-09-07 21:36:47">2021/09/07</span>
        </a>
        
        
        <a  class="全部文章 1计算机 Y实验室 "
           href="/2021/09/07/1-ji-suan-ji/y-shi-yan-shi/a-zu-hui-hui-bao/"
           data-tag="github,Java,C++,python"
           data-author="" >
            <span class="post-title" title="阿组会汇报">阿组会汇报</span>
            <span class="post-date" title="2021-09-07 21:28:12">2021/09/07</span>
        </a>
        
        
        <a  class="全部文章 1计算机 G计算机硬件 "
           href="/2021/09/07/1-ji-suan-ji/g-ji-suan-ji-ying-jian/dian-zi-she-bei-zhi-shi/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="电子设备知识">电子设备知识</span>
            <span class="post-date" title="2021-09-07 20:54:21">2021/09/07</span>
        </a>
        
        
        <a  class="全部文章 1计算机 B集成开发环境 windows "
           href="/2021/09/07/1-ji-suan-ji/b-ji-cheng-kai-fa-huan-jing/windows/typora-picgo-pei-zhi-ben-di-bi-ji/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="typora+picgo配置本地笔记">typora+picgo配置本地笔记</span>
            <span class="post-date" title="2021-09-07 20:17:11">2021/09/07</span>
        </a>
        
        
        <a  class="全部文章 3修身 C生活知识 "
           href="/2021/04/15/3-xiu-shen/c-sheng-huo-zhi-shi/jing-wai-lu-you-xue-xi-ru-he-shi-yong-fu-kuan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="境外旅游学习如何使用付款">境外旅游学习如何使用付款</span>
            <span class="post-date" title="2021-04-15 15:06:10">2021/04/15</span>
        </a>
        
        
        <a  class="全部文章 1计算机 E人工智能 "
           href="/2021/01/27/1-ji-suan-ji/e-ren-gong-zhi-neng/distributed-representations-of-words-and-phrases-and-their-compositionality/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Distributed Representations of Words and Phrases and their Compositionality">Distributed Representations of Words and Phrases and their Compositionality</span>
            <span class="post-date" title="2021-01-27 19:38:27">2021/01/27</span>
        </a>
        
        
        <a  class="全部文章 3修身 G奇思妙想 "
           href="/2019/11/16/3-xiu-shen/g-qi-si-miao-xiang/zhu-guan-shi-jie-he-ke-guan-shi-jie-de-tao-lun-2019-11-16/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="主观世界和客观世界的讨论">主观世界和客观世界的讨论</span>
            <span class="post-date" title="2019-11-16 00:00:00">2019/11/16</span>
        </a>
        
        
        <a  class="全部文章 5学科 A文学 "
           href="/2019/07/05/5-xue-ke/a-wen-xue/tai-si-2019-07-05/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="苔丝">苔丝</span>
            <span class="post-date" title="2019-07-05 00:00:00">2019/07/05</span>
        </a>
        
        
        <a  class="全部文章 5学科 G影评 "
           href="/2019/07/05/5-xue-ke/g-ying-ping/tian-cai-qiang-shou-2019-07-05/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="天才枪手">天才枪手</span>
            <span class="post-date" title="2019-07-05 00:00:00">2019/07/05</span>
        </a>
        
        
        <a  class="全部文章 3修身 G奇思妙想 "
           href="/2018/11/04/3-xiu-shen/g-qi-si-miao-xiang/lun-xue-xi-he-ying-shi-jiao-yu-2018-11-04/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="论学习和应试教育">论学习和应试教育</span>
            <span class="post-date" title="2018-11-04 00:00:00">2018/11/04</span>
        </a>
        
        
        <a  class="全部文章 5学科 A文学 "
           href="/2018/09/08/5-xue-ke/a-wen-xue/xian-yi-ren-x-de-xian-shen-2018-09-08/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="嫌疑人X的献身">嫌疑人X的献身</span>
            <span class="post-date" title="2018-09-08 00:00:00">2018/09/08</span>
        </a>
        
        
        <a  class="全部文章 5学科 G影评 "
           href="/2018/08/28/5-xue-ke/g-ying-ping/peng-ran-xin-dong-2018-08-28/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="怦然心动">怦然心动</span>
            <span class="post-date" title="2018-08-28 00:00:00">2018/08/28</span>
        </a>
        
        
        <a  class="全部文章 5学科 A文学 "
           href="/2018/08/19/5-xue-ke/a-wen-xue/liao-bu-qi-de-gai-ci-bi-2018-08-19/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="了不起的盖茨比">了不起的盖茨比</span>
            <span class="post-date" title="2018-08-19 00:00:00">2018/08/19</span>
        </a>
        
        
        <a  class="全部文章 3修身 G奇思妙想 "
           href="/2018/08/18/3-xiu-shen/g-qi-si-miao-xiang/nan-nu-sui-tan-2018-08-18/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="男女随谈">男女随谈</span>
            <span class="post-date" title="2018-08-18 00:00:00">2018/08/18</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-0开发/Z刷题/03Leetcode热题100" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">03Leetcode热题100</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="0开发">0开发</a> > 
            
            <a  data-rel="0开发&lt;---&gt;Z刷题">Z刷题</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">Java</a>
            
            <a class="color2">python</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2023-03-05 17:23:29'>2022-09-14 14:18</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:30.1k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E5%8F%B7-%E9%A2%98%E7%9B%AE"><span class="toc-text">题号.题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B31%E5%90%8D%E7%A7%B0-self"><span class="toc-text">思想1名称(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B32%E5%90%8D%E7%A7%B0"><span class="toc-text">思想2名称*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode%E7%83%AD%E9%A2%98Hot100"><span class="toc-text">LeetCode热题Hot100</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-book"><span class="toc-text">2. 两数相加 📖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%BA%BA%E5%B7%A5%E5%8A%A0%E6%B3%95-self"><span class="toc-text">模拟人工加法(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-self"><span class="toc-text">迭代(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-text">3. 无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-%E6%83%B3%E9%94%99%E6%96%B9%E5%90%91"><span class="toc-text">动态规划(self, 想错方向</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">滑动窗口*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-4"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">4. 寻找两个正序数组的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B31%E5%90%8D%E7%A7%B0-self-1"><span class="toc-text">思想1名称(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-5"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%96%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">合并排序取中位数*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-6"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">5. 最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%8A%98%E6%AF%94%E8%BE%83%E7%9B%B8%E7%AD%89-self"><span class="toc-text">对折比较相等(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-7"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">10. 正则表达式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-self-%E5%8F%AA%E8%BF%87%E4%BA%86%E4%B8%80%E5%8D%8A%E6%A0%B7%E4%BE%8B-%E6%B2%A1%E5%81%9A%E5%87%BA%E6%9D%A5"><span class="toc-text">递归(self, 只过了一半样例, 没做出来</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0"><span class="toc-text">错误原因:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-8"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">11. 盛最多水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-9"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">15. 三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%BE%AA%E7%8E%AF-map%E8%AE%A1%E6%95%B0-set%E5%AD%98%E5%82%A8-self"><span class="toc-text">双循环+map计数+set存储(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-10"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">排序+双指针*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-11"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-text">17. 电话号码的字母组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E5%BE%AA%E7%8E%AF-self"><span class="toc-text">递归+循环(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-12"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-13"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">19. 删除链表的倒数第 N 个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-self"><span class="toc-text">快慢指针(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-14"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-text">22. 括号生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%8B%AC%E5%8F%B7-self"><span class="toc-text">递归+迭代加括号(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-15"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B32%E5%90%8D%E7%A7%B0-1"><span class="toc-text">思想2名称*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-16"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">23. 合并K个升序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E6%94%BE%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E5%BD%A2%E6%88%90%E9%93%BE%E8%A1%A8-self"><span class="toc-text">存放数组排序后形成链表(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-18"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-17"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB-self"><span class="toc-text">分治*(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%811"><span class="toc-text">代码1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%812"><span class="toc-text">代码2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-18"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-self"><span class="toc-text">优先队列(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-19"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-19"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-text">31. 下一个排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95"><span class="toc-text">下一个排列算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-20"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-20"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-text">32. 最长有效括号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-21"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-21"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">33. 搜索旋转排序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%81%8D%E5%8E%86-self"><span class="toc-text">顺序遍历(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-22"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-22"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93-self"><span class="toc-text">二分查找变体(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-23"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-23"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E4%BD%93-self-1"><span class="toc-text">二分查找变体(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-24"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%812-1"><span class="toc-text">代码2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-24"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-self-%E6%B2%A1%E5%81%9A%E5%87%BA%E6%9D%A5"><span class="toc-text">回溯(self, 没做出来</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-25"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-26"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-25"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">46. 全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E7%A9%BA-self%E6%B2%A1%E5%81%9A%E5%87%BA%E6%9D%A5"><span class="toc-text">填空(self没做出来</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-27"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-26"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-text">48. 旋转图像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE%E5%8A%A0%E9%95%9C%E5%83%8F"><span class="toc-text">利用矩阵的转置加镜像*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-28"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-27"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-text">49. 字母异位词分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-self"><span class="toc-text">Map(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-32"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-29"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-28"><span class="toc-text">复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-30"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-text">55. 跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self"><span class="toc-text">动态规划?(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-33"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-31"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-29"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-text">56. 合并区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F-self-%E6%B2%A1%E5%81%9A%E5%87%BA%E6%9D%A5"><span class="toc-text">模拟(self, 没做出来</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-34"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-32"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%90%8E%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="toc-text">排序后找规律*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-35"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-33"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-30"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">62. 不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-1"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-36"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-34"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-31"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-text">动态规划*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-37"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-35"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-32"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6"><span class="toc-text">组合数学</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-38"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-36"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-33"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">64. 最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-2"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-39"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-37"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-34"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-text">动态规划*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-40"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-35"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-text">75. 颜色分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3-self"><span class="toc-text">桶排序思想(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-41"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-36"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="toc-text">双指针*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-42"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-38"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-37"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-text">78. 子集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-self"><span class="toc-text">回溯(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-43"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-39"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-38"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-3"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-44"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-40"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-39"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-text">79. 单词搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-3"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-45"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-41"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">96. 不同的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-4"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-46"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-42"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-40"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%9E%84%E9%80%A0-self"><span class="toc-text">递归构造(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-47"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-43"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-41"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-text">114. 二叉树展开为链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95-self"><span class="toc-text">递归原地算法(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-48"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-44"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-45"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-42"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%86%8D%E6%9E%84%E9%80%A0"><span class="toc-text">前序遍历再构造*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-49"><span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-text">128. 最长连续序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F%E8%AE%A1%E6%95%B0-self"><span class="toc-text">去重排序计数(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-50"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-46"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-43"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash"><span class="toc-text">Hash*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-51"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-47"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-44"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">136. 只出现一次的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97-1"><span class="toc-text">位运算*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-52"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-48"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-45"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-alarm-clock"><span class="toc-text">139. 单词拆分⏰</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8set%E5%AD%98%E5%82%A8%E5%90%8E%E9%80%92%E5%BD%92-self-%E6%B2%A1%E8%A7%A3%E5%86%B3"><span class="toc-text">用set存储后递归(self, 没解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-53"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-49"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-46"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B32%E5%90%8D%E7%A7%B0-2"><span class="toc-text">思想2名称*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-54"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-50"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-47"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="toc-text">142. 环形链表 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-%E4%B8%80%E4%BA%8C%E4%B8%A4%E6%AC%A1%E7%9B%B8%E9%81%87"><span class="toc-text">快慢指针+一二两次相遇</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-55"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-51"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-48"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%93%BE%E8%A1%A8"><span class="toc-text">修改链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-56"><span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="toc-text">146. LRU 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%88%B6%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-self"><span class="toc-text">自制双向链表(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-57"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-52"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">148. 排序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%AD%98%E5%82%A8%E5%BF%AB%E6%8E%92%E5%90%8E%E5%86%8D%E8%B5%8B%E5%80%BC-self"><span class="toc-text">list存储快排后再赋值(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-58"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-53"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-49"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6-slef"><span class="toc-text">归并(slef*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-59"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-54"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-50"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">152. 乘积最大子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A50%E5%88%86%E5%89%B2%E5%90%8E%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86%E9%81%87%E5%88%B0%E8%B4%9F%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%BA%E5%A5%87%E6%95%B0%E6%97%B6%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%A5%87%E6%95%B0%E5%81%9C%E6%AD%A2"><span class="toc-text">以0分割后双向遍历遇到负数个数为奇数时最后一个奇数停止</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-60"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-55"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-51"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-alarm-clock"><span class="toc-text">动态规划⏰</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-61"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-56"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-52"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-text">155. 最小栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E6%A0%88%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%E6%A0%88-self"><span class="toc-text">一个数字栈一个最小数字栈(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-62"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-57"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-53"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89pair%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8"><span class="toc-text">自定义pair链表存储*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-63"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-58"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-text">160. 相交链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%B3%95-self"><span class="toc-text">指针法(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-64"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-59"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-54"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E9%9B%85%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%97%B6"><span class="toc-text">双指针优雅永不过时*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-65"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-60"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-55"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-text">169. 多数元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8"><span class="toc-text">摩尔投票</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-66"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-61"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-56"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-text">200. 岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86-self"><span class="toc-text">深度遍历(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-67"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-62"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-57"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208. 实现 Trie (前缀树)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie"><span class="toc-text">Trie</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-68"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-63"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-alarm-clock"><span class="toc-text">215. 数组中的第K个最大元素⏰</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0-self"><span class="toc-text">调用库函数(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-64"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-58"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B32%E5%90%8D%E7%A7%B0-3"><span class="toc-text">思想2名称*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-69"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-65"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-59"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-text">221. 最大正方形</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-5"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-70"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-66"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-60"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="toc-text">动态规划*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-71"><span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">234. 回文链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E5%8F%8D%E8%BD%AC%E5%AF%B9%E6%AF%94-self"><span class="toc-text">折半反转对比(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-72"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-67"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-61"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-alarm-clock"><span class="toc-text">快慢指针*(⏰</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-73"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-68"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-62"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-LCA"><span class="toc-text">236. 二叉树的最近公共祖先(LCA)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-74"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-69"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-63"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">238. 除自身以外数组的乘积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E7%B4%AF%E4%B9%98%E5%8F%B3%E7%B4%AF%E4%B9%98%E5%86%8D%E7%9B%B8%E4%B9%98"><span class="toc-text">左累乘右累乘再相乘</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-75"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-70"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-64"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="toc-text">240. 搜索二维矩阵 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%81%8D%E5%8E%86"><span class="toc-text">暴力遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-76"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-71"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-65"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%8F%E8%A1%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">对每行二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-77"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-72"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-66"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">279. 完全平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-78"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-73"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-67"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E6%B3%95"><span class="toc-text">数学法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-79"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-74"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-68"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-text">283. 移动零</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E9%9D%9E0%E8%A6%86%E7%9B%96%E5%88%B0%E6%95%B0%E7%BB%84%E5%89%8D%E9%9D%A2%E5%90%8E%E9%9D%A2%E8%B5%8B%E5%80%BC0-self"><span class="toc-text">将非0覆盖到数组前面后面赋值0(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-80"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-75"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-69"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88-alarm-clock"><span class="toc-text">左右指针⏰</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-81"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-76"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-70"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="toc-text">287. 寻找重复数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text">快慢指针法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-82"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-77"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-71"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">300. 最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-5"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-83"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-78"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-72"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-text">309. 最佳买卖股票时机含冷冻期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-6"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-84"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-79"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-73"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-text">322. 零钱兑换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-text">从上往下记忆化搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-85"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-80"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-74"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-7"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-86"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-75"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0"><span class="toc-text">338. 比特位计数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-self-6"><span class="toc-text">动态规划(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-87"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-82"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-76"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-text">347. 前 K 个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E5%A0%86"><span class="toc-text">哈希表+优先队列(堆)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-88"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-83"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-77"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-text">394. 字符串解码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-89"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-84"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-78"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-text">406. 根据身高重建队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-sob"><span class="toc-text">动态规划😭</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-90"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-85"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#h%E9%80%86%E5%BA%8Fk%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F-%E6%8F%92%E9%98%9F"><span class="toc-text">h逆序k顺序排序+插队*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-91"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-86"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-79"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">416. 分割等和子集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-0-1%E8%83%8C%E5%8C%85"><span class="toc-text">动态规划(0-1背包)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-92"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-87"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-80"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-text">437. 路径总和 III</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-93"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-88"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-81"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">438. 找到字符串中所有字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-1"><span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-94"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-89"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-82"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">448. 找到所有数组中消失的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%AD%89%E9%95%BF%E6%A0%87%E5%BF%97%E6%95%B0%E7%BB%84-self"><span class="toc-text">额外等长标志数组(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-95"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-90"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-83"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C"><span class="toc-text">原地哈希*</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-96"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-91"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-84"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB"><span class="toc-text">461. 汉明距离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97-2"><span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-97"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-92"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-85"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-text">494. 目标和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-text">回溯法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-98"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-93"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-86"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-text">538. 把二叉搜索树转换为累加树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%80%86%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">中序逆序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-99"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-94"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-87"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-text">543. 二叉树的直径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%BD%AC%E5%8C%96"><span class="toc-text">问题转化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-100"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-95"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-88"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">560. 和为 K 的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C-%E5%8F%8C%E9%87%8D%E9%81%8D%E5%8E%86-self"><span class="toc-text">前缀和+双重遍历(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-101"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-96"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-89"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">581. 最短无序连续子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E8%A7%84%E5%BE%8B"><span class="toc-text">数学规律</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-102"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-97"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-90"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83"><span class="toc-text">排序比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-103"><span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">617. 合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-self"><span class="toc-text">递归(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-104"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-98"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-text">621. 任务调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF"><span class="toc-text">脑筋急转弯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-105"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-99"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-91"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">647. 回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE-self"><span class="toc-text">暴力枚举(self</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-106"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-100"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-92"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-4"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-text">739. 每日温度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E5%BE%AA%E7%8E%AF-self"><span class="toc-text">双重循环(self</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-text">单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-107"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-101"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-93"><span class="toc-text">复杂度</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-4 i,
    .toc-level-4 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Leetcode时间限制</p>
<p><img src="https://raw.githubusercontent.com/pengber/pic-bed/main/img/1610787167-ACRBUz-complexity.png" alt="complexity.png"></p>
<p>注意:</p>
<p><span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>表示未完成</p>
<p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>表示重要</p>
<p><span class="github-emoji"><span>🌟</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>表示超级重要</p>
<p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>表示我的思路并且通过了</p>
<p><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>表示自己尝试的方法但是通不过</p>
<p><span class="github-emoji"><span>🙆♂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f646-2642.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>表示他人的方法通过了</p>
<p><span class="github-emoji"><span>🙅♂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f645-2642.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>表示他人的方法但没通过</p>
<p><span class="github-emoji"><span>💭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4ad.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>表示只写了想法没写代码无论自己或者其他人的.</p>
<h3 id="题号-题目"><a href="#题号-题目" class="headerlink" title="题号.题目"></a>题号.题目</h3><p>描述</p>
<p>样例</p>
<h4 id="思想1名称-self"><a href="#思想1名称-self" class="headerlink" title="思想1名称(self"></a>思想1名称(self</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">\\语法, 以后搜索\\语法可以学习语法
\\思想, 学习思想
</code></pre>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="思想2名称"><a href="#思想2名称" class="headerlink" title="思想2名称*"></a>思想2名称*</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">
</code></pre>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h2 id="LeetCode热题Hot100"><a href="#LeetCode热题Hot100" class="headerlink" title="LeetCode热题Hot100"></a>LeetCode热题Hot100</h2><h3 id="2-两数相加-book"><a href="#2-两数相加-book" class="headerlink" title="2. 两数相加 :book:"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a> <span class="github-emoji"><span>📖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d6.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h4 id="模拟人工加法-self"><a href="#模拟人工加法-self" class="headerlink" title="模拟人工加法(self"></a>模拟人工加法(self</h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>这道题其实就是链表逆向存储了十进制数, 也就是头存储的是<strong>个位</strong>, 模拟人工进行加法. 算法实际实现有点归并的思想.但是没有结合成统一的代码, 如果想结合成统一的代码. 就是在节点为空时, 相当于此节点的值为0即可.</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = new ListNode();
        ListNode cur = head;
        int carry = 0;
        int num = 0;
        while(l1!=null&amp;&amp;l2!=null){
            num = (l1.val+l2.val+carry)%10;         //思想, 先计算num, 两数之和加进位再对10取余
            carry = (l1.val+l2.val+carry)&gt;=10?1:0;  //思想, 如果这次相加大于等于10的话下一个进位是1否则为0
            ListNode node = new ListNode(num);
            cur.next = node;
            cur = cur.next;                         //思想, 下面移动
            l1 = l1.next;
            l2 = l2.next;
        }
        while(l1!=null){
            num = (l1.val+carry)%10;
            carry = (l1.val+carry)&gt;=10?1:0;
            ListNode node = new ListNode(num);
            cur.next = node;
            cur = cur.next;
            l1 = l1.next;
        }
        while(l2!=null){
            num = (l2.val+carry)%10;
            carry = (l2.val+carry)&gt;=10?1:0;
            ListNode node = new ListNode(num);
            cur.next = node;
            cur = cur.next;
            l2 = l2.next;
        }
        if (carry==1) {                             //思想, 如果最后一位还有进位的话需要构造
            ListNode node = new ListNode(carry);
            cur.next = node;
        }
        return head.next;
    }
}
</code></pre>
<h5 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(max{M,N})$</li>
<li>空间: $O(max{M,N})$, 其实可以为O(1), 也就是直接在原节点修改.</li>
</ul>
<h4 id="迭代-self"><a href="#迭代-self" class="headerlink" title="迭代(self"></a>迭代(self</h4><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>确定以下:</p>
<ul>
<li>函数干什么: 返回两个数字十进制相加后的新的节点</li>
<li>传递参数: 两个数字以及上次的进位, 第一次进位为0</li>
<li>终止条件:<ul>
<li>两个数字都为空</li>
<li>其中一个数字为空</li>
<li>两个数字都不为空</li>
</ul>
</li>
</ul>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        return addTwoNumbersHelp(l1, l2, 0);
    }
    private ListNode addTwoNumbersHelp(ListNode l1, ListNode l2, int carry){
        if (l1==null &amp;&amp; l2==null) {
            if(carry==1) return new ListNode(1);
            return null;
        }
        else if(l1==null&amp;&amp;l2!=null) {
            int num = (l2.val+carry)%10;
            carry = l2.val+carry&gt;=10?1:0;
            l2.val = num;
            l2.next = addTwoNumbersHelp(l1, l2.next, carry);
            return l2;
        }else if(l1!=null&amp;&amp;l2==null) {
            int num = (l1.val+carry)%10;
            carry = l1.val+carry&gt;=10?1:0;
            l1.val = num;
            l1.next = addTwoNumbersHelp(l1.next, l2, carry);				//思想
            return l1;
        }else{
            int num = (l1.val+l2.val+carry)%10;
            carry = (l1.val+l2.val+carry)&gt;=10?1:0;
            l1.val = num;
            l1.next = addTwoNumbersHelp(l1.next, l2.next, carry);			//思想
            return l1;
        }
    }
}
</code></pre>
<h5 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(max{N,M})$(N和M为两个节点存储十进制数的位数的长度)</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<pre><code class="java">示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
</code></pre>
<h4 id="动态规划-self-想错方向"><a href="#动态规划-self-想错方向" class="headerlink" title="动态规划(self, 想错方向"></a>动态规划(self, 想错方向</h4><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>本来我的思路是用动态规划的思路, 源自于<code>53题最大子序和</code>, 也就是令<br>$$<br>f(i)表示以第i个字母结尾的字符串的长度 \<br>f(i) = f(i-1)+1 \ \ \ \ \ \ 当i和i-1的字母不相同时 \<br>max = Math.max(f(1), f(2), …,f(n))<br>$$<br>但是我发现这样很难计算当$i$个字母在之前出现过的时候,所以会出现各种问题.</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口*"></a>滑动窗口*</h4><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p>两个指针, 一个指针指向窗口的左端, 表示第i个字母时, 不含重复字符子串的左端, 一个指针为i, 表示滑动窗口的右端.</p>
<p>i从0开始, 一次加1,</p>
<p>left默认为0, 当第i个字母没出现时不变, 出现时, 指向这个出现字母最后一次出现的位置+1和left之中最大的那个.</p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map&lt;Character, Integer&gt; m = new HashMap&lt;&gt;();
        int max = 0;
        int left = 0;
        for(int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            if (m.containsKey(c)) {
                left = Math.max(m.get(c)+1, left);  //思想
            }
            m.put(c,i);                             //思想
            max = Math.max(max, i-left+1);
        }
        return max;
    }
}
</code></pre>
<h5 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) 。</p>
<pre><code class="java">示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
</code></pre>
<h4 id="思想1名称-self-1"><a href="#思想1名称-self-1" class="headerlink" title="思想1名称(self"></a>思想1名称(self</h4><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><pre><code>\\语法, 以后搜索\\语法可以学习语法
\\思想, 学习思想
</code></pre>
<h5 id="复杂度-5"><a href="#复杂度-5" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="合并排序取中位数"><a href="#合并排序取中位数" class="headerlink" title="合并排序取中位数*"></a>合并排序取中位数*</h4><h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><p>合并两个数组然后取中位数</p>
<p>但是这个的时间是借sort算法快排的$O(log(M+N))$来实现的, 而不是真正自己实现了所需要的算法复杂度.</p>
<h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n1 = nums1.length;
        int n2 = nums2.length;
        int[] nums = new int[n1 + n2];
        System.arraycopy(nums1, 0, nums, 0, n1);		//语法
        System.arraycopy(nums2, 0, nums, n1, n2);		//语法
        Arrays.sort(nums);								//语法
        int n = nums.length;
        if (n % 2 == 0) {
            return (nums[(n/2)-1] + nums[n/2])/2.0;
        } else {
            return nums[n/2];
        }
    }
}
</code></pre>
<h5 id="复杂度-6"><a href="#复杂度-6" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<pre><code>示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

示例 2：

输入：s = "cbbd"
输出："bb"
</code></pre>
<h4 id="对折比较相等-self"><a href="#对折比较相等-self" class="headerlink" title="对折比较相等(self"></a>对折比较相等(self</h4><h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h5><p>移动一个指针, 再让这个指针往左走和往右走如果一直想等的话就是回文串, 记录最大长度和这个指针的位置, 要注意, 分为奇对称和偶对称</p>
<ul>
<li>奇对称: abacd, 这个aba以b为对称轴</li>
<li>偶对称: abbac, abba以”空”为对称轴</li>
</ul>
<h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public String longestPalindrome(String s) {
        char []str = s.toCharArray();
        int max_length = 1;			//记录整个回文串的最大长度
        int flag = 1;               //记录是哪种情况, 1是奇对称(aba), 0是偶对称(aa)
        int index = 0;				//如果是奇对称, 记录对称轴的位置, 如果是偶对称, 记录空的下一个字符的位置, 这里记录后面那个字符的话就要使得`length&gt;=max_length`
        String result = s.substring(0,1);
        for(int i =1; i &lt; str.length; i++) {
            //奇对称
            int length = 1;				//奇对称初始长度为1
            for(int j = i-1, k = i+1; j &gt;=0&amp;&amp;k&lt;str.length;j--,k++){
                if(str[j]==str[k]) {
                    length+=2;
                    if(length&gt;=max_length) {
                        index = i;
                        flag = 1;
                        max_length = length;
                    }
                }else{
                    break;
                }
            }
            //偶对称
            length = 0;					//偶对成初始长度为0
            for(int j = i-1,k = i; j &gt;=0 &amp;&amp; k &lt; str.length; j--, k++) {
                if(str[j]==str[k]) {
                    length+=2;
                    if(length&gt;=max_length) {
                        index = i;
                        flag = 0;
                        max_length = length;
                    }
                }else{
                    break;
                }
            }
        }
        if (flag == 0) {
            //abbacd的话, index就是第二个b, max_length是4
            result = s.substring(index-max_length/2,index+max_length/2);
        }else{
            //abcbad, index是c, max_length是5.
            result = s.substring(index-max_length/2, index+max_length/2+1);
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-7"><a href="#复杂度-7" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(N)$, 浪费这么多空间主要是为了直接用[]取字符, 使用s.charAt也可以做到$O(1)$.</li>
</ul>
<h3 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<pre><code>'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
</code></pre>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串</p>
<pre><code>示例 1：

输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。

示例 2:

输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3：

输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4：

输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

示例 5：

输入：s = "mississippi" p = "mis*is*p*."
输出：false
</code></pre>
<h4 id="递归-self-只过了一半样例-没做出来"><a href="#递归-self-只过了一半样例-没做出来" class="headerlink" title="递归(self, 只过了一半样例, 没做出来"></a>递归(self, 只过了一半样例, 没做出来</h4><h5 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h5><p>慢慢的确定终止条件再到一半情况</p>
<h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean isMatch(String s, String p) {
        if (s.length()==0&amp;&amp;p.length()==0) {
            return true;
        }else if(s.length()==0&amp;&amp;p.length()==1){          //s是空串, p不为空的情况          
            return false;
        }else if(s.length()==0&amp;&amp;p.length()&gt;1){
            char c1 = p.charAt(0);
            char c2 = p.charAt(1);
            if (c2=='*') {                      //如果是"p*"或者".*"这种情况
                return isMatch(s, p.substring(2,p.length()));
            }else{                              //如果是"a"这种情况
                return false;
            }
        }else if(s.length() &gt; 0 &amp;&amp; p.length() ==0) {      //s不是空串,但是p是空串
            return false;
        }else if(s.length() &gt;0 &amp;&amp; p.length() ==1) {
            char c = s.charAt(0);
            char c1 = p.charAt(0);
            if ((c==c1||c1=='.')&amp;&amp;s.length()==1) return true;
            else return false;
        }else{
            char c = s.charAt(0);
            char c1 = p.charAt(0);
            char c2 = p.charAt(1);
            if(c==c1||c1=='.') {
                if(c2=='*'){
                    return isMatch(s.substring(1,s.length()), p);
                }else{
                    return isMatch(s.substring(1,s.length()), p.substring(1,p.length()));
                }
            }else{
                if(c2=='*'){
                    return isMatch(s, p.substring(2,p.length()));
                }else{
                    return false;
                }
            }
        }
    }
}
</code></pre>
<h5 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因:"></a>错误原因:</h5><p>通过测试用例：298 / 353</p>
<pre><code>输入：
"aaa"
"a*a"
</code></pre>
<pre><code>输出：
false
</code></pre>
<pre><code>预期结果：
true
</code></pre>
<p>我只是从前匹配, 但是a*到底要匹配多少次这是从前匹配做不到的.</p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划*"></a>动态规划*</h4><h5 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h5><p>还没学习呢</p>
<h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-8"><a href="#复杂度-8" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<p><img src="https://raw.githubusercontent.com/pengber/pic-bed/main/img/image-20220123100131768.png" alt="image-20220123100131768"></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><h5 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h5><p>这题一看数据量, $10^5$表明$n^2$的暴力群举就会超时, 所以要想其他办法, 先写出动态规划方程:<br>$$<br>max_area = max( min(height[i],height[j])*(j-i))<br>$$<br>问题就出现在宽和高上, 宽虽然一次移动1个单位, 但是面积的增加与否还要看移动后的高是否会减小, 我的想法就这么中断了, 因为我不知道如何判断移动后的高是不是正确的高, 但其实不用管是不是正确的高, 我们只需要记录最大的面积就好了, 尽管它不是正确的高, 只要我们遍历所有情况, 记录最大的面积就可以了.</p>
<p>接下来就写循环, 如果都从一端开始, 一个是循环终止不好写, 另一个是i和j都从一端开始的话必然$N^2$, 所以技巧就在于用双指针刚开始指向首尾, 然后移动这两个指针中的一个, 移动哪一个呢?<strong>移动那个高比较短的那个的下标</strong>.</p>
<h5 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxArea(int[] height) {
        int area = 0;
        int i = 0;
        int j = height.length-1;					//思想, 双指针指向首尾
        area = Math.min(height[i],height[j])*(j-i);
        while(i!=j) {
            if(height[i]&lt;=height[j]) i++;
            else j--;
            int new_area = Math.min(height[i],height[j])*(j-i);//思想,动态规划方程
            if (new_area&gt;area) {
                area = new_area;
            }
        }
        return area;
    }
}
</code></pre>
<h5 id="复杂度-9"><a href="#复杂度-9" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<pre><code>示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
</code></pre>
<pre><code>示例 2：

输入：nums = [-1,3,2,-1,0,0]
输出：[[-1,-1,2],[2,3,-1],[3,0,0]]
注意: 这里的数字可以用多次, 只是最后的结果不能重复而已.
</code></pre>
<pre><code>示例 3：

输入：nums = [-1,0,-1,0]
输出：[[-1,0,1]]
注意: 没有[0,0,0]这个答案
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="双循环-map计数-set存储-self"><a href="#双循环-map计数-set存储-self" class="headerlink" title="双循环+map计数+set存储(self"></a>双循环+map计数+set存储(self</h4><h5 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h5><p>一看数据量, 说明$n^2$算法可以解决, 所以是两个循环, 第三个数用map来直接查找.</p>
<p>首先要明确的是这里面的数字可以用多次, 只是结果里面的不能重复而已, 所以结果需要用一个<code>set&lt;&gt;</code>先存储, 另外, 里面的小结果不能用<code>set&lt;Integer&gt;</code>存储, 因为可能出现<code>[1, 1, -2]</code>这种答案, 所以, 最后答案的存储要用<code>set&lt;List&lt;Integer&gt;&gt;</code>来存储, 并且在将<code>list&lt;Integer&gt;</code>放入<code>set</code>前要进行排序, 否则发挥不了set的作用.</p>
<h5 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for(int i = 0; i &lt;nums.length; i++) {
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
        }
        Set&lt;List&lt;Integer&gt;&gt; answer = new HashSet&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if(nums.length &lt; 3) return result;		//思想, 小于3的答案为空直接返回.
        
        for(int i = 0; i &lt; nums.length; i++) {
            for (int j = i+1; j &lt; nums.length; j++) {
                int last_num = 0-nums[i]-nums[j];
                if(nums[i]==last_num&amp;&amp;map.get(nums[i])&gt;=2&amp;&amp;last_num!=nums[j]&amp;&amp;map.get(nums[j])&gt;=1) {
                    //[-1,-1,2,0]这种情况,两个相同
                }
                else if(nums[j]==last_num&amp;&amp;map.get(nums[j])&gt;=2&amp;&amp;last_num!=nums[i]&amp;&amp;map.get(nums[i])&gt;=1) {
                    //[-1,-1,2,0]这种情况
                }else if(nums[i]!=last_num&amp;&amp;nums[j]!=last_num&amp;&amp;map.get(nums[i])&gt;=1&amp;&amp;map.get(nums[j])&gt;=1&amp;&amp;map.getOrDefault(last_num,0)&gt;=1) {
                    //[1,2,-3]这种情况,都不相同(一个相同)
                }else if(nums[i]==last_num&amp;&amp;nums[j]==last_num&amp;&amp;map.get(nums[i])&gt;=3){
                    //[0,0,0]这种情况, 三个相同
                }
                else{
                    continue;
                }
                List&lt;Integer&gt; new_answer = new ArrayList&lt;&gt;();
                new_answer.add(nums[i]);
                new_answer.add(nums[j]);
                new_answer.add(last_num);
                Collections.sort(new_answer);		//思想, //语法,在进set前进行排序
                answer.add(new_answer);
            }
        }
        for(List&lt;Integer&gt; new_set:answer) {
            List&lt;Integer&gt; new_result = new ArrayList&lt;&gt;(new_set);
            result.add(new_result);
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-10"><a href="#复杂度-10" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序+双指针*"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/">排序+双指针*</a></h4><h5 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h5><blockquote>
<p>本题的难点在于如何去除重复解。</p>
<ol>
<li>特判，对于数组长度 nnn，如果数组为 nulll或者数组长度小于 3，返回 [][][]。</li>
<li>对数组进行排序。</li>
<li>遍历排序后数组：<ol>
<li>若 nums[i]&gt;0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。</li>
<li>如果nums[i]与nums[i-1]相同, 继续(排除重复解)</li>
<li>令左指针 L=i+1，右指针 R=n−1，当 L&lt;R时，执行循环：<ul>
<li>nums[i]+nums[L]+nums[R]==0时, 执行循环, 如果左指针和下一个位置相同, 则前进(排除相同解)或者右指针的前一个位置相同,则前进</li>
<li><strong>若和大于0, 说明nums[R]太大, R左移</strong></li>
<li><strong>若和小于0, 说明nums[L]太小, L右移</strong></li>
</ul>
</li>
</ol>
</li>
</ol>
</blockquote>
<p>最后两句话是精髓!</p>
<h5 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();
        //排序
        Arrays.sort(nums);
        //双指针
        int len = nums.length;
        for(int i = 0;i &lt; len;++i) {
            if(nums[i] &gt; 0) return lists;

            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;

            int curr = nums[i];
            int L = i+1, R = len-1;
            while (L &lt; R) {
                int tmp = curr + nums[L] + nums[R];
                if(tmp == 0) {
                    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
                    list.add(curr);
                    list.add(nums[L]);
                    list.add(nums[R]);
                    lists.add(list);
                    while(L &lt; R &amp;&amp; nums[L+1] == nums[L]) ++L;
                    while (L &lt; R &amp;&amp; nums[R-1] == nums[R]) --R;
                    ++L;
                    --R;
                } else if(tmp &lt; 0) {
                    ++L;
                } else {
                    --R;
                }
            }
        }
        return lists;
    }
</code></pre>
<h5 id="复杂度-11"><a href="#复杂度-11" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2$)</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<pre><code>示例 1：

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
</code></pre>
<h4 id="递归-循环-self"><a href="#递归-循环-self" class="headerlink" title="递归+循环(self"></a>递归+循环(self</h4><h5 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h5><p>递归的终止条件是当传递的字符串为0.</p>
<p>递归的传递参数是字符串.</p>
<p>递归的返回类型是List<string>, 是传递的字符串形成的电话号码的字符串.</string></p>
<p>因为数字和字母的对应关系不是规则的, 所以为了解决这个问题写了很多没有算法思想的语句.</p>
<p>但从这个思想上, 我们已经看到了本题应该使用回溯算法思想.</p>
<h5 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;String&gt; letterCombinations(String digits) {
        if(digits.length()==0) return new ArrayList&lt;String&gt;();
        return letterCombinationsHelp(digits);
    }
    private List&lt;String&gt; letterCombinationsHelp(String digits) {
        List&lt;String&gt; result = new ArrayList&lt;&gt;();
        if(digits.length()==0) {
            result.add("");
            return result;
        }
        List&lt;String&gt; lastList = new ArrayList&lt;&gt;();
        lastList = letterCombinationsHelp(digits.substring(1,digits.length()));
        if(digits.charAt(0)&gt;='2'&amp;&amp;digits.charAt(0)&lt;='6') {//0-6可以
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'2')*3+'a'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'2')*3+'b'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'2')*3+'c'))+item);
            }
        }else if(digits.charAt(0)=='7'){
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'7')+'p'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'7')+'q'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'7')+'r'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'7')+'s'))+item);
            }
        }else if(digits.charAt(0)=='8'){
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'8')+'t'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'8')+'u'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'8')+'v'))+item);
            }
        }else if(digits.charAt(0)=='9') {
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'9')+'w'))+item);
            }
            for(String item:lastList) {
               result.add((char)(((digits.charAt(0)-'9')+'x'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'9')+'y'))+item);
            }
            for(String item:lastList) {
                result.add((char)(((digits.charAt(0)-'9')+'z'))+item);
            }
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-12"><a href="#复杂度-12" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$, N层递归, 每层递归最多10次操作左右, 好像不是很准确</li>
<li>空间: $O(N)$, N层递归</li>
</ul>
<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯*"></a>回溯*</h4><h5 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;String&gt; letterCombinations(String digits) {
        List&lt;String&gt; combinations = new ArrayList&lt;&gt;();
        if(digits.length()==0) return combinations;
        Map&lt;Character, String&gt; phoneMap = new HashMap&lt;&gt;(){{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};
        backtrack(combinations, phoneMap, digits, 0, new StringBuffer());
        return combinations;
    }
    private void backtrack(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, int index, StringBuffer combination) {
        if (index == digits.length()) {
            combinations.add(combination.toString());
        }else {
            char digit = digits.charAt(index);
            String letters = phoneMap.get(digit);
            for(int i = 0; i &lt; letters.length(); i++) {
                combination.append(letters.charAt(i));
                backtrack(combinations, phoneMap, digits, index+1, combination);
                combination.deleteCharAt(index);
            }
        }
    }
}
</code></pre>
<h5 id="复杂度-13"><a href="#复杂度-13" class="headerlink" title="复杂度"></a>复杂度</h5><p><img src="https://raw.githubusercontent.com/pengber/pic-bed/main/img/image-20220125122049206.png" alt="image-20220125122049206"></p>
<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<h4 id="快慢指针-self"><a href="#快慢指针-self" class="headerlink" title="快慢指针(self"></a>快慢指针(self</h4><h5 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h5><p>双指针, 先移动第二个指针到倒数第n个位置,然后两个指针一起移动, 第二个指针移动到末尾的时候第一个指针指向倒数第n个位置.</p>
<p>具体还用了一个技巧, 就是p指向倒数第n+1个位置, 这样好删除.</p>
<h5 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fakeHead = new ListNode();
        fakeHead.next = head;
        ListNode result = fakeHead;
        ListNode p = fakeHead;
        ListNode q = fakeHead;
        int i = 0;
        while(i&lt;=n) {
            i++;
            q = q.next;
        }
        while(q!=null) {
            p = p.next;
            q = q.next;
        }
        p.next = p.next.next;
        return result.next;
    }
}
</code></pre>
<h5 id="复杂度-14"><a href="#复杂度-14" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<pre><code>示例 1：

输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
</code></pre>
<pre><code>示例 2：

输入：n = 2
输出：["()()", "(())" ]
</code></pre>
<pre><code>示例 3：

输入：n = 1
输出：["()"]
</code></pre>
<h4 id="递归-迭代加括号-self"><a href="#递归-迭代加括号-self" class="headerlink" title="递归+迭代加括号(self"></a>递归+迭代加括号(self</h4><h5 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h5><p>从n=1到n=3我得出规律, 每个n都是n-1的字符串的前, 外, 后上面加括号, 比如</p>
<pre><code>n = 1 ()
n = 2 ()()  (()) ()()[这个去重]
</code></pre>
<p>但是写好代码发现, n=4由n=3前外后加括号会遗漏一个答案, 就是这个<code>(())(())</code>, 显然这个答案无法从n=3的答案中前外后加括号所得到, 也就是我的刚开始想的递归方程是错误的, 代码如下:</p>
<pre><code class="java">private Set&lt;String&gt; generateParenthesisHelp(int n) {
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        if(n == 0) {
            set.add("");
            return set;
        }else {
            Set&lt;String&gt; lastSet = generateParenthesisHelp(n-1);
            for(String item:lastSet) {
                String new_item1 = "()"+item;
                String new_item2 = "("+item+")";
                String new_item3 = item+"()";
                set.add(new_item1);
                set.add(new_item2);
                set.add(new_item3);
            } 
            return set;
        }
    }
</code></pre>
<p>其实递归方程应该是对于n-1的串, 遍历他们, 然后增加<code>item.substring(0,i)+"()"+item.substring(i,item.length())</code>这样.</p>
<h5 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; result = new ArrayList&lt;&gt;(generateParenthesisHelp(n));
        return result;
    }
    private Set&lt;String&gt; generateParenthesisHelp(int n) {
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        if(n == 1) {
            set.add("()");
            return set;
        }else {
            Set&lt;String&gt; lastSet = generateParenthesisHelp(n-1);
            for(String item:lastSet) {
                for(int i = 0; i &lt; item.length(); i++) {
                    set.add(item.substring(0,i)+"()"+item.substring(i,item.length()));
                }
            } 
            return set;
        }
    }
}
</code></pre>
<h5 id="复杂度-15"><a href="#复杂度-15" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N*2^{N-1})$</li>
<li>空间: $O(2^{N-1})$</li>
</ul>
<h4 id="思想2名称-1"><a href="#思想2名称-1" class="headerlink" title="思想2名称*"></a>思想2名称*</h4><h5 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-16"><a href="#复杂度-16" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<h4 id="存放数组排序后形成链表-self"><a href="#存放数组排序后形成链表-self" class="headerlink" title="存放数组排序后形成链表(self"></a>存放数组排序后形成链表(self</h4><h5 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h5><p>存放数组排序后形成链表返答案</p>
<h5 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        for(int i = 0; i &lt; lists.length; i++) {
            ListNode p = lists[i];
            while(p!=null) {
                result.add(p.val);
                p = p.next;
            }
        }
        Collections.sort(result);
        ListNode fakeHead = new ListNode();
        ListNode p = fakeHead;
        for(int i = 0; i &lt; result.size(); i++) {
            ListNode node = new ListNode(result.get(i));
            p.next = node;
            p = p.next;
        }
        return fakeHead.next;
    }
}
</code></pre>
<h5 id="复杂度-17"><a href="#复杂度-17" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$(算返回的时间)</li>
</ul>
<h4 id="分治-self"><a href="#分治-self" class="headerlink" title="分治*(self"></a>分治*(self</h4><h5 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h5><p>这其实就是多路归并, 但是因为多路归并的比较不如二路归并那么快, 所以要把多路归并转化为二路归并, 也就是分治算法, 但是我的这个分治写的不是标准的分治, 标准的分治不会复制形成新的节点, 而是在原有的节点的基础上, 用左右两个指针指代需要分治的位置.</p>
<h5 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h5><pre><code class="java">class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return divideAndConquer(lists);
    }
    ListNode divideAndConquer(ListNode[] lists) {
        //分治
        if(lists.length == 0) return null;
        if(lists.length == 1) {
            return lists[0];
        }
        ListNode fakeHead = new ListNode();
        ListNode p = fakeHead;
        ListNode[] lists1 = new ListNode[lists.length/2];
        ListNode[] lists2 = new ListNode[lists.length-lists.length/2];
        System.arraycopy(lists, 0, lists1, 0, lists.length/2);
        System.arraycopy(lists, lists.length/2, lists2, 0, lists.length-lists.length/2);
        ListNode node1= divideAndConquer(lists1);
        ListNode node2 = divideAndConquer(lists2);
        
        //合并
        while(node1!=null&amp;&amp;node2!=null) {
            if(node1.val&lt;=node2.val) {
                p.next = node1;
                node1 = node1.next;
            }else{
                p.next = node2;
                node2 = node2.next;
            }
            p = p.next;
        }
        if(node1!=null) p.next = node1;
        if(node2!=null) p.next = node2;
        return fakeHead.next;
    }
}
</code></pre>
<h5 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h5><p>对代码1的分治进行了改进, 节省了空间, 比较标准化写了分治</p>
<pre><code class="java">class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return divideAndConquer(lists,0,lists.length);
    }
    ListNode divideAndConquer(ListNode[] lists, int left, int right) {
        if(left==right) return null;
        if(right-left == 1) {
            return lists[left];
        }
        ListNode fakeHead = new ListNode();
        ListNode p = fakeHead;
        ListNode node1= divideAndConquer(lists, left, left+(right-left)/2);
        ListNode node2 = divideAndConquer(lists, left+(right-left)/2, right);
        while(node1!=null&amp;&amp;node2!=null) {
            if(node1.val&lt;=node2.val) {
                p.next = node1;
                node1 = node1.next;
            }else{
                p.next = node2;
                node2 = node2.next;
            }
            p = p.next;
        }
        if(node1!=null) p.next = node1;
        if(node2!=null) p.next = node2;
        return fakeHead.next;
    }
}
</code></pre>
<h5 id="复杂度-18"><a href="#复杂度-18" class="headerlink" title="复杂度"></a>复杂度</h5><p><img src="https://raw.githubusercontent.com/pengber/pic-bed/main/img/image-20220126111829459.png" alt="image-20220126111829459"></p>
<h4 id="优先队列-self"><a href="#优先队列-self" class="headerlink" title="优先队列(self"></a>优先队列(self</h4><h5 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h5><p>官方题解用优先队列来取代二路归并的比较进行多路归并的比较, 但是我想着都用优先队列了, 直接遍历数据存入优先队列(自然排序)再形成链表自然就是答案了.</p>
<h5 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;();
        for(int i = 0; i &lt; lists.length; i++) {
            ListNode node = lists[i];
            while(node!=null) {
                queue.add(node.val);
                node = node.next;
            }
        }
        ListNode fakeHead = new ListNode();
        ListNode p = fakeHead;
        int len = queue.size();						//语法, 优先队列的按自然排序取出只能这样取,因为是堆排序, 每出来一个大小会变化.
        for(int i = 0; i &lt; len; i++) {
            p.next = new ListNode(queue.poll());
            p = p.next;
        }
        return fakeHead.next;
    }
}
</code></pre>
<h5 id="复杂度-19"><a href="#复杂度-19" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N<em>N</em>log^N)$遍历N遍, 每遍进行一次堆排序</li>
</ul>
<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h3><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<pre><code>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
</code></pre>
<p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<pre><code>示例 1：

输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：

输入：nums = [3,2,1]
输出：[1,2,3]
</code></pre>
<h4 id="下一个排列算法"><a href="#下一个排列算法" class="headerlink" title="下一个排列算法"></a>下一个排列算法</h4><h5 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h5><p>从后往前一直顺序, 顺序被打断的位置记作$little_small_index$, 然后在$(little_small_index, length-1)$中找比little_small_index位置的最小的稍大数(因为little_small_index,length-1)是顺序, 所以从后往前或者从前往后遍历一遍就找到了, 位置记作little_big_index), 交换little_small_index和little_big_index, 然后再对little_small_index后的进行一遍排序(也就是转置, 因为交换后的(little_small_index, length-1)依然是顺序.</p>
<h5 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void nextPermutation(int[] nums) {
        if(nums.length==1) return;
        int flag = 0;									//标志,0表示从后往前顺序,-1表示被打断
        int little_small_index = 0;
        int little_big_index = 0;
        for(int i = nums.length-1; i &gt; 0; --i) {				//思想, 找到稍微小一点的index
            if(nums[i]&lt;=nums[i-1]) {
                //从后往前顺序
                continue;
            }else{
                flag = 1;
                little_small_index = i-1;
                break;
            }
        }
        for (int i = nums.length-1; i &gt; little_small_index; --i) {//思想,找到稍微大一点的index
            if(nums[i] &lt;= nums[little_small_index]) continue;
            else {
                little_big_index = i;
                break;
            }
        }
        if(flag == 0) {
            //从后往前一直顺序
            inverse(nums, 0, nums.length-1);
        }else {
            swap(nums, little_small_index, little_big_index);
            inverse(nums, little_small_index+1, nums.length-1);
        }
        return;
    }
    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
        return;
    }
    private void inverse(int[] nums, int s, int e) {		//语法, 原地转置
        for(int i = 0; i &lt;= (e-s)/2;i++) {
            swap(nums, s+i,e-i);
        }
    }
}
</code></pre>
<h5 id="复杂度-20"><a href="#复杂度-20" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h3><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<pre><code>示例 1：
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"

示例 2：
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"

示例 3：
输入：s = ""
输出：0

示例 4：
输入：s = "()(()"
输出：2

示例 3：
输入：s = ")()())"
输出：4
</code></pre>
<p>动态规划</p>
<h5 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h5><p>见题解</p>
<h5 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h5><pre><code>class Solution {
    public int longestValidParentheses(String s) {
        int [] dp = new int[s.length()];
        int max_length = 0;
        for (int i = 1; i &lt; s.length(); i++) {
            if (s.charAt(i)==')'){
                if(s.charAt(i-1)=='(') {
                    dp[i] = (i&gt;=2?dp[i-2]:0)+2;		//语法, //思想, 这里的三目运算符是为了解决dp初始化问题和边界问题.
                }else if(i-dp[i-1]&gt;0 &amp;&amp; s.charAt(i-dp[i-1]-1)=='(') {
                    dp[i] = dp[i-1]+ (i-dp[i-1]&gt;=2 ? dp[i-dp[i-1]-2]:0)+2;	//语法, //思想, 这里的三目运算符是为了解决dp初始化问题和边界问题.
                }
                max_length = max_length &lt; dp[i]?dp[i]:max_length;
            }
        }
        return max_length;
    }
}
</code></pre>
<h5 id="复杂度-21"><a href="#复杂度-21" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h3><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<pre><code>示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
</code></pre>
<p>提示：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 5000</li>
<li>-10^4 &lt;= nums[i] &lt;= 10^4</li>
<li>nums 中的每个值都 独一无二</li>
<li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li>
<li>-10^4 &lt;= target &lt;= 10^4</li>
</ul>
<h4 id="顺序遍历-self"><a href="#顺序遍历-self" class="headerlink" title="顺序遍历(self"></a>顺序遍历(self</h4><h5 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h5><p>这个题数据量O(N)能解决, 所以先直接顺序遍历找AC后再思考考点.</p>
<p>考点应该是如果数据量超大的话必须降为$O(logN)$, 如果是对数时间复杂度, 寻找的复杂度用二分即可实现, 但是要找到那个旋转点 k 才能进行二分, 所以找k的算法应该也是对数复杂度.可以这样找k</p>
<ul>
<li>将nums对半分, 这样一个必定为顺序, 一个必定为旋转数组</li>
<li>回到上步</li>
</ul>
<h5 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int search(int[] nums, int target) {
        int result = -1;
        for(int i = 0; i &lt; nums.length; i++) {
            if(target == nums[i]) {
                result = i;
                break;
            }
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-22"><a href="#复杂度-22" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="二分查找变体-self"><a href="#二分查找变体-self" class="headerlink" title="二分查找变体(self"></a>二分查找变体(self</h4><h5 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h5><p>二分寻找的变体.</p>
<ul>
<li>先分为两半, 必定一个顺序一个旋转</li>
<li>如果target在顺序之中, 则继续寻找, 否则在旋转中寻找</li>
<li>寻找的终止条件是e-s&lt;=1 , 也就是一个数或者两个数(一般来说为一个数, 但是有点数组越界, 我就改造了一下)</li>
</ul>
<h5 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int search(int[] nums, int target) {
        return binarySearch(nums, 0, nums.length-1, target);
    }
    private int binarySearch(int[] nums, int s, int e, int target) {
        int m = s + (e-s)/2;
        if (e-s&lt;=1) {
            if (nums[s]==target) return s;
            else if(nums[e]==target) return e;
            else return -1;
        }
        if (nums[s] &lt; nums[m]) {
            if (nums[s]&lt;=target &amp;&amp;nums[m]&gt;=target) return binarySearch(nums, s, m, target);
            else{
                return binarySearch(nums, m, e, target);
            }
        }else{
            if (nums[m]&lt;=target &amp;&amp;nums[e]&gt;=target) return binarySearch(nums, m, e, target);
            else{
                return binarySearch(nums, s, m, target);
            }
        }
    }
}
</code></pre>
<h5 id="复杂度-23"><a href="#复杂度-23" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(logN)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<h4 id="二分查找变体-self-1"><a href="#二分查找变体-self-1" class="headerlink" title="二分查找变体(self"></a>二分查找变体(self</h4><h5 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h5><p>两个二分查找, 只不过一个从前找start, 一个从后找end.</p>
<h5 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] searchRange(int[] nums, int target) {
        int [] result = new int[2];
        result[0] = -1;
        result[1] = -1;
        if (nums.length==0) return result;
        result[0] = binarySearchStart(nums, 0, nums.length-1, target);
        result[1] = binarySearchEnd(nums, 0, nums.length-1, target);
        return result;
    }
    // 找start
    public int binarySearchStart(int[] nums, int s, int e, int target) {
        if(e-s&lt;=1) {
            if(nums[s] == target) return s;
            else if(nums[e] == target) return e;
            else return -1;
        }
        int m = s+(e-s)/2;
        if(nums[s]&lt;=target &amp;&amp; target &lt;= nums[m]) return binarySearchStart(nums, s, m, target);
        else return binarySearchStart(nums, m+1, e, target);
    }
    public int binarySearchEnd(int[] nums, int s, int e, int target) {
        if(e-s&lt;=1) {
            if(nums[e] == target) return e;
            else if(nums[s] == target) return s;
            else return -1;
        }
        int m = s+(e-s)/2;
        if(nums[m]&lt;=target &amp;&amp; target &lt;= nums[e]) return binarySearchEnd(nums, m, e, target);
        else return binarySearchEnd(nums, s, m-1, target);
    }

}
</code></pre>
<h5 id="代码2-1"><a href="#代码2-1" class="headerlink" title="代码2"></a>代码2</h5><pre><code class="java">class Solution {
    public int[] searchRange(int[] nums, int target) {
        int [] result = new int[2];
        result[0] = -1;
        result[1] = -1;
        if (nums.length==0) return result;
        result[0] = binarySearchStart(nums, 0, nums.length-1, target);
        result[1] = binarySearchEnd(nums, 0, nums.length-1, target);
        return result;
    }
    public int binarySearchStart(int[] nums, int s, int e, int target) {
        if(e-s==0) {
            if(nums[s] == target) return s;
            else return -1;
        }
        int m = s+(e-s)/2;
        if(nums[s]&lt;=target &amp;&amp; target &lt;= nums[m]) return binarySearchStart(nums, s, m, target);
        else return binarySearchStart(nums, m+1, e, target);
    }
    public int binarySearchEnd(int[] nums, int s, int e, int target) {
        if(e-s==0) {
            if(nums[e] == target) return e;
            else return -1;
        }
        int m = s+(e-s)/2+1;		//注意这里要+1.
        if(nums[m]&lt;=target &amp;&amp; target &lt;= nums[e]) return binarySearchEnd(nums, m, e, target);
        else return binarySearchEnd(nums, s, m-1, target);
    }

}
</code></pre>
<h5 id="复杂度-24"><a href="#复杂度-24" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(logN)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<pre><code>示例 1：

输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
</code></pre>
<h4 id="回溯-self-没做出来"><a href="#回溯-self-没做出来" class="headerlink" title="回溯(self, 没做出来"></a>回溯(self, 没做出来</h4><h5 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h5><p>就一看就是回溯的题, 但对回溯的方法不太熟, 只能写个大概.</p>
<h5 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; last = new ArrayList&lt;&gt;();
        combinationSumHelp(candidates, target, 0, last, 0, result);
        return result;
    }
    public void combinationSumHelp(int[] candidates, int target, int index, List&lt;Integer&gt; last, int sum, List&lt;List&lt;Integer&gt;&gt; result) {
      if(index &gt;= candidates.length) return;
        if(candidates[index]+sum==target) {
            last.add(candidates[index]);
            sum+=candidates[index];
            List&lt;Integer&gt; result_item = new ArrayList&lt;&gt;(last);
            result.add(result_item);
            return;
        }else if(candidates[index]+sum &gt; target) {
            return;
        }
        else if(candidates[index]+sum &lt; target){
            last.add(candidates[index]);
            List&lt;Integer&gt; temp_last = new ArrayList&lt;&gt;(last);
            combinationSumHelp(candidates, target, index, temp_last, sum+=candidates[index], result);
            last.remove(last.size()-1);
            sum-=candidates[index];
            combinationSumHelp(candidates, target, index+1, last, sum, result);
        }
    }
}
</code></pre>
<h4 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯*"></a>回溯*</h4><h5 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; combination = new ArrayList&lt;&gt;();
        combinationSumHelp(candidates, target, 0, combination, result);
        return result;
    }
    public void combinationSumHelp(int[] candidates, int target, int begin, List&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; result) {
      if (target &lt; 0) return;
      if  (target == 0) {
          result.add(new ArrayList&lt;&gt;(combination));
          return;
      }
      for (int i = begin; i &lt; candidates.length; i++) {
          combination.add(candidates[i]);
          combinationSumHelp(candidates, target-candidates[i], i, combination, result);
          combination.remove(combination.size()-1);
      }
    }
}
</code></pre>
<h5 id="复杂度-25"><a href="#复杂度-25" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(S)$，其中 S为所有可行解的长度之和(树的深度之和, 可以通过剪枝来降低)</li>
<li>空间: $O(target)$, 最差为target深(都是1).</li>
</ul>
<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<pre><code>示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]

示例 3：

输入：nums = [1]
输出：[[1]]
</code></pre>
<h4 id="填空-self没做出来"><a href="#填空-self没做出来" class="headerlink" title="填空(self没做出来"></a>填空(self没做出来</h4><h5 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h5><p>我想的是[1, 2, 3, 4], 然后把1取出来, 然后放入剩下的[2, 3, 4]的四个空中, 这样遍历所有数据来一次.</p>
<p>这么做不能得到全排列, 比如[4, 3, 2, 1]这个数据出不来, 只能出来<code>[4, 1, 2, 3], [1, 4, 2, 3], [1, 2, 4, 3], [1, 2, 3, 4]</code>这些数据</p>
<h4 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯*"></a>回溯*</h4><h5 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; collections = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; collection = new ArrayList&lt;&gt;();
        int [] flags = new int[nums.length];				//用一个flag数组来标志是否使用过
        int depth = nums.length;
        dfs(collections, collection, nums, flags, depth, 0);
        return collections;
    }

    //思想
    void dfs(List&lt;List&lt;Integer&gt;&gt; collections, List&lt;Integer&gt; collection, int[]nums, int [] flags, int depth, int index){
        if (index == depth) {
            collections.add(new ArrayList&lt;Integer&gt;(collection));
            return;
        }

        for (int i = 0; i &lt; depth; i++) {
            if (flags[i] == 0) {
                flags[i] = 1;
                collection.add(nums[i]);
                dfs(collections, collection, nums, flags, depth, index+1);
                flags[i] = 0;
                collection.remove(collection.size()-1);
            }
        }
    }
}
</code></pre>
<h5 id="复杂度-26"><a href="#复杂度-26" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N*N!)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<h4 id="利用矩阵的转置加镜像"><a href="#利用矩阵的转置加镜像" class="headerlink" title="利用矩阵的转置加镜像*"></a>利用矩阵的转置加镜像*</h4><h5 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h5><p>转置和镜像可以原地进行.</p>
<p>向右旋转90°=&gt;先转置再左右镜像.</p>
<p>向右旋转180°=&gt;先左右镜像, 再上下镜像.</p>
<p>向右旋转270°=&gt;先转置再上下镜像(也就是向左旋转90°)</p>
<h5 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void rotate(int[][] matrix) {
        transpose(matrix);
        leftRightMirror(matrix);
        return;
    }
    void transpose(int[][] matrix) {
        for (int i = 0; i &lt; matrix.length; i++) {
            for (int j = i; j &lt; matrix.length;j++) {
                int t = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = t;
            }
        }
        return;
    }
    void leftRightMirror(int [][]matrix) {
        for (int j= 0; j&lt; matrix.length/2; j++) {
            for (int i = 0; i &lt; matrix.length; i++) {
                int t = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.length-1-j];
                matrix[i][matrix.length-1-j] = t;
            }
        }
    }
    void upDownMirror(int [][] matrix) {
        for (int i = 0; i &lt; matrix.length/2; i++) {
            for (int j = 0 ;j &lt; matrix.length; j++) {
                int t = matrix[i][j];
                matrix[i][j] = matrix[matrix.length-1-i][j];
                matrix[matrix.length-1-i][j] = t;
            }
        }
    }
}
</code></pre>
<h5 id="复杂度-27"><a href="#复杂度-27" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<pre><code>示例 1:

输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

示例 2:

输入: strs = [""]
输出: [[""]]
</code></pre>
<h4 id="Map-self"><a href="#Map-self" class="headerlink" title="Map(self"></a>Map(self</h4><h5 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h5><p>先得到每个字符串对应的字典序字符串, 然后创建该字典序字符串的<code>map&lt;string, List&lt;String&gt;&gt;</code>, 遍历一遍放进去之后再遍历一遍得到列表.</p>
<h5 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        List&lt;String&gt; lexicographicOrderStrs = new ArrayList&lt;&gt;();//对应strs的字典序列表
        List&lt;List&lt;String&gt;&gt; result;
        for(int i = 0; i &lt; strs.length; i++) {
            lexicographicOrderStrs.add(i, getLexicographicOrder(strs[i]));
        }
        //System.out.println(lexicographicOrderStrs);
        Map&lt;String, List&lt;String&gt;&gt; stringMap = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; strs.length; i++) {
            List&lt;String&gt; item = stringMap.getOrDefault(lexicographicOrderStrs.get(i), new ArrayList&lt;String&gt;());
            item.add(strs[i]);
            stringMap.put(lexicographicOrderStrs.get(i), item);
        }
        result =  new ArrayList&lt;&gt;(stringMap.values());
        return result;
    }
    String getLexicographicOrder(String str) {
        char[] ar = str.toCharArray();
        Arrays.sort(ar);
        String sortedStr = String.valueOf(ar);
        return sortedStr;
    }
}
</code></pre>
<h5 id="复杂度-28"><a href="#复杂度-28" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(NKlog^K)$ K为字符串最长长度</li>
<li>空间: $O(N)$</li>
</ul>
<h5 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h5><p>官方题解简化版</p>
<pre><code class="java">class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();
        for (String str : strs) {
            char[] array = str.toCharArray();
            Arrays.sort(array);
            String key = new String(array);
            List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;());
            list.add(str);
            map.put(key, list);
        }
        return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());
    }
}


作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h3><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<pre><code>示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
</code></pre>
<h4 id="动态规划-self"><a href="#动态规划-self" class="headerlink" title="动态规划?(self"></a>动态规划?(self</h4><h5 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h5><p>用一个max来记录该位置之前可以到达最远的位置, 然后比较该位置和最远位置, 如果该位置可以到达, 重新计算最远位置, 直至最后一个位置.</p>
<h5 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean canJump(int[] nums) {
        int max = 0+nums[0];        //之前的步数可以到达的最大坐标.
        boolean flag = true;       //是否可以到达最后下标.
        for (int i = 1; i &lt; nums.length; i++) {
            if(i &lt;= max) {
                //可以到达
                max = max &gt; i+nums[i]?max:i+nums[i];
            }else {
                flag = false;   //不可以到达
                break;
            }
        }
        return flag;
    }
}
</code></pre>
<h5 id="复杂度-29"><a href="#复杂度-29" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<pre><code>示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。


示例 3：

输入：intervals = [[1,4],[5,6]]
输出：[[1,4],[5,6]]
解释：区间 [1,4] 和 [5,6] 不可被视为重叠区间。
</code></pre>
<h4 id="模拟-self-没做出来"><a href="#模拟-self-没做出来" class="headerlink" title="模拟(self, 没做出来"></a>模拟(self, 没做出来</h4><h5 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h5><p>把各个区间遍历一遍在数轴上进行标记, 然后再遍历一遍数轴得到这些区间.</p>
<p>这个思想是错误的, 这个只能得到合并后的区间, 但是不能得到重叠的区间, 比如示例3, 示例3就会被这样的算法得到一个区间, 没有体现重叠.</p>
<h5 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[][] merge(int[][] intervals) {
        int [] flags = new int[10001];
        for (int i = 0; i &lt; intervals.length; i++) {
            for(int j = intervals[i][0]; j &lt;=intervals[i][1]; j++) {
                flags[j] = 1;
            }
        }
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        int flag = 0;           //是否已经选取左端点的标志
        for(int i = 0; i &lt; 10001; i++) {
            if(flags[i] == 1 &amp;&amp; flag == 0) {
                List&lt;Integer&gt; item = new ArrayList&lt;&gt;();
                item.add(i);
                result.add(item);
                flag = 1;
            }else if(flags[i] == 1 &amp;&amp; flag == 1) {
                if (i==10000||flags[i+1]==0) {
                    //右端
                    result.get(result.size()-1).add(i);
                    flag = 0;
                }else{
                    //非右端, 中间
                    continue;
                }
            }else {
                //flags[i] == 0
                continue;
            }
        }
        int[][] realResult = new int[result.size()][2];
        for(int i = 0; i &lt; result.size(); i++) {
            realResult[i][0] = result.get(i).get(0);
            realResult[i][1] = result.get(i).get(1);
        }
        return realResult;
    }
}
</code></pre>
<h4 id="排序后找规律"><a href="#排序后找规律" class="headerlink" title="排序后找规律*"></a>排序后找规律*</h4><h5 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h5><p>对这些区间进行左端的排序保证左端一定最小, 然后的话合并这些区间:</p>
<ul>
<li>如果下一个区间的左端比上一个区间的右端大, 一定不重叠, 直接形成新区间.</li>
<li>如果下一个区间的左端比上一个区间的右端小, 然后将上一个区间的右端置为这两个区间最大的右端.</li>
</ul>
<h5 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[][] merge(int[][] intervals) {
        
        Arrays.sort(intervals, new Comparator&lt;int[]&gt;(){//语法
            public int compare(int [] intervals1, int [] intervals2) {
                return intervals1[0] - intervals2[0];
            }
        });
        List&lt;int[]&gt; merge = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; intervals.length; i++) {
            int L = intervals[i][0];
            int R = intervals[i][1];
            if (merge.size()==0||merge.get(merge.size()-1)[1] &lt; L) {//语法, //思想
                merge.add(new int[]{L,R});
            }else{
                //如果存在重叠
                merge.get(merge.size()-1)[1] = Math.max(merge.get(merge.size()-1)[1], R);//思想
            }
        }
        return merge.toArray(new int[merge.size()][]);//语法
    }
}
</code></pre>
<h5 id="复杂度-30"><a href="#复杂度-30" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<h4 id="动态规划-self-1"><a href="#动态规划-self-1" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h5><p>把最后一行和最后一列初始化为1, 然后从右下角往左上角计算,动态规划方程如下:<br>$$<br>squar[i][j] = 1; (i=m-2, j=1,2…n-1)\<br>squar[i][j] = 1; (j=n-2, j=1,2…m-1)\<br>squar[i][j] = square[i][j+1]+square[i+1][j];<br>$$</p>
<h5 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int uniquePaths(int m, int n) {
        int [][] square = new int[m][n];
        square[m-1][n-1] = 1;
        for(int i = 0; i &lt; m; i++) {
            square[i][n-1] = 1;
        }
        for(int j = 0; j &lt; n; j++) {
            square[m-1][j] = 1;
        }
        for (int i = m-2; i &gt;= 0; i--) {
            for (int j = n-2; j &gt;= 0; j--) {
                square[i][j] = square[i][j+1]+square[i+1][j];
            }
        }
        return square[0][0];
    }
}
</code></pre>
<h5 id="复杂度-31"><a href="#复杂度-31" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(M*N)$</li>
</ul>
<h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划*"></a>动态规划*</h4><h5 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h5><p>从左上往右下计算</p>
<h5 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int uniquePaths(int m, int n) {
        int [][] square = new int[m][n];
        square[m-1][n-1] = 1;
        for(int i = 0; i &lt; m; i++) {
            square[i][n-1] = 1;
        }
        for(int j = 0; j &lt; n; j++) {
            square[m-1][j] = 1;
        }
        for (int i = m-2; i &gt;= 0; i--) {
            for (int j = n-2; j &gt;= 0; j--) {
                square[i][j] = square[i][j+1]+square[i+1][j];
            }
        }
        return square[0][0];
    }
}
</code></pre>
<h5 id="复杂度-32"><a href="#复杂度-32" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(M*N)$</li>
</ul>
<h4 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h4><h5 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h5><p>一共需要走$m+n-2$步, 需要从中挑选$m-1$次向下移动.</p>
<h5 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y &lt; m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
}
</code></pre>
<h5 id="复杂度-33"><a href="#复杂度-33" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li><p>时间复杂度：O(m)。由于我们交换行列的值并不会对答案产生影响，因此我们总可以通过交换 m和 n 使得 m&lt;=n，这样空间复杂度降低至 O(min(m,n))。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h3><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<pre><code>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
</code></pre>
<h4 id="动态规划-self-2"><a href="#动态规划-self-2" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h5><p>动态规划, 和63题思路差不多, 只不过算和而且正向算</p>
<h5 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int [][] square = new int[m][n];
        square[0][0] = grid[0][0];                      //思想
        for(int i = 1; i &lt; m; i++) {
            square[i][0] = square[i-1][0]+grid[i][0];   //思想, 注意第一个是square
        }
        for(int j = 1; j &lt; n; j++) {
            square[0][j] = square[0][j-1]+grid[0][j];
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                square[i][j] = Math.min(square[i-1][j],square[i][j-1])+grid[i][j];
            }
        }
        return square[m-1][n-1];
    }
}
</code></pre>
<h5 id="复杂度-34"><a href="#复杂度-34" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(m*n)$</li>
<li>空间: $O(m*n)$</li>
</ul>
<h4 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划*"></a>动态规划*</h4><h5 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h5><p>可以不建新数组, 直接在原数组修改</p>
<h5 id="复杂度-35"><a href="#复杂度-35" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h3><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。</p>
<pre><code>示例 1：

输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]

示例 2：

输入：nums = [2,0,1]
输出：[0,1,2]

</code></pre>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以不使用代码库中的排序函数来解决这道题吗？</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<h4 id="桶排序思想-self"><a href="#桶排序思想-self" class="headerlink" title="桶排序思想(self"></a>桶排序思想(self</h4><h5 id="思路-41"><a href="#思路-41" class="headerlink" title="思路"></a>思路</h5><p>扫描第一遍记录各个数字数目, 第二遍置数</p>
<h5 id="复杂度-36"><a href="#复杂度-36" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $o(1)$</li>
</ul>
<h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针*"></a>双指针*</h4><h5 id="思路-42"><a href="#思路-42" class="headerlink" title="思路"></a>思路</h5><p>官方题解方法三.</p>
<p>用两个指针p1,p2来指代0和2要替换的位置, 扫描, 如果发现0的话与p1位置交换, 如果发现2的话与p2位置交换, 但是要注意, 无论是交换0还是2, 交换后的结果都有可能是三种(0和2), 这时候不能前进, 而是要将再进行交换直到不是自己.这两个做1个就行了.</p>
<h5 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void sortColors(int[] nums) {
        int p1 = 0;                     //用来指示1的下次交换
        int p2 = nums.length-1;         //用来指示2的下次交换
        for (int i = 0; i &lt;= p2; ++i) {	//思想, 注意终止条件.
            if(nums[i] == 0) {
                int t = nums[i];
                nums[i] = nums[p1];
                nums[p1] = t;
                p1++;              
            }else if (nums[i] == 2){
                int t = nums[i];
                nums[i] = nums[p2];
                nums[p2] = t;
                p2--;
                i--;                    //思想,如果是2的话替换之后可能是0, 可能是1, 也可能是2 所以要转变为这个位置不是2为止, 也就是其他两种情况
            }else{
                continue;
            }
        }
        return;
    }
}
</code></pre>
<h5 id="复杂度-37"><a href="#复杂度-37" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<pre><code>示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

示例 2：

输入：nums = [0]
输出：[[],[0]]
</code></pre>
<h4 id="回溯-self"><a href="#回溯-self" class="headerlink" title="回溯(self"></a>回溯(self</h4><h5 id="思路-43"><a href="#思路-43" class="headerlink" title="思路"></a>思路</h5><p>回溯模板, 不用标记数组</p>
<h5 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; collections = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; collection = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();
        collections.add(item);           //空集
        dfs(collections, collection, nums.length, 0, nums);
        return collections;
    }
    void dfs(List&lt;List&lt;Integer&gt;&gt; collections, List&lt;Integer&gt; collection, int depth, int index, int []nums) {
        if (index == depth) {
            return;
        }
        for(int i = index; i &lt; depth; i++){
            collection.add(nums[i]);
            collections.add(new ArrayList&lt;Integer&gt;(collection));		//思想
            dfs(collections, collection, depth, i+1, nums);
            collection.remove(collection.size()-1);
        }
    }
}
</code></pre>
<h5 id="复杂度-38"><a href="#复杂度-38" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="动态规划-self-3"><a href="#动态规划-self-3" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-44"><a href="#思路-44" class="headerlink" title="思路"></a>思路</h5><p>[1,2,3]的子集可以由[1,2]的子集得到</p>
<h5 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; collections = new ArrayList&lt;&gt;();
        collections.add(new ArrayList&lt;&gt;());           //空集
        List&lt;Integer&gt; temp_item = new ArrayList&lt;&gt;();
        temp_item.add(nums[0]);
        collections.add(temp_item);
        for (int i = 1; i &lt; nums.length; i++) {
            int length = collections.size();
            for(int j = 0; j &lt; length; j++) {
                List&lt;Integer&gt; new_item = new ArrayList&lt;&gt;(collections.get(j));
                new_item.add(nums[i]);
                collections.add(new_item);
            }
        }
        return collections;
    }
    
}
</code></pre>
<h5 id="复杂度-39"><a href="#复杂度-39" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(2^N)$</li>
<li>空间: $O(2^N)$结果的空间</li>
</ul>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h3><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<h4 id="回溯-3"><a href="#回溯-3" class="headerlink" title="回溯"></a>回溯</h4><h5 id="思路-45"><a href="#思路-45" class="headerlink" title="思路"></a>思路</h5><p>我觉得很重要的一点是, 主函数要干什么,  辅助函数要干什么.</p>
<p>主函数: 遍历棋盘, 使用辅助函数判断是否该位置可以得到正确答案.</p>
<p>辅助函数:</p>
<ul>
<li><p>如果是倒数第一位, 则直接返回最后一位与当前棋盘的判别, 这样是必要的, 一个是剪掉枝, 另一个最重要的是, 我们的辅助函数默认(i,j)是合法的, 如果判断最后一位与字符串的长度的话, (i, j)必然不合法.就会出现</p>
<pre><code>[[a]]
a
</code></pre>
<p>这样的样例是false的结果</p>
</li>
<li><p>如果当前棋盘子和字符相同的话, 继续试探<strong>合法的棋子</strong>与下一个字符.</p>
</li>
<li><p>如果周围4个都不正常的话, 回退本棋子, 并且返回假.</p>
</li>
</ul>
<h5 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean exist(char[][] board, String word) {
        List&lt;Boolean&gt; result = new ArrayList&lt;&gt;();
        boolean[][] board_flag = new boolean[board.length][board[0].length];
        boolean flag = false;
        for (int i = 0 ; i &lt; board.length; i ++) {
            for (int j = 0; j &lt; board[0].length; j++) {
                flag = exist_help(i, j, 0, board, board_flag, word);
                if (flag == true) return true;
            }
        }
        return false;
    }
    boolean exist_help(int i, int j, int k, char[][] board, boolean [][] board_flag, String word) {
        
        if(k==word.length()-1) {			//思想, 不能用k==word.length() return true;
            return board[i][j] == word.charAt(k);
        }
        if (board[i][j]==word.charAt(k)) {
            board_flag[i][j] = true;
            if(inArea(i, j+1, board)&amp;&amp;!board_flag[i][j+1]) {
                if (exist_help(i, j+1, k+1, board, board_flag, word)) return true;
            }
            if(inArea(i, j-1, board)&amp;&amp;!board_flag[i][j-1]) {
                if( exist_help(i, j-1, k+1, board, board_flag, word)) return true;
            }
            if(inArea(i-1, j, board)&amp;&amp;!board_flag[i-1][j]) {
                if( exist_help(i-1, j, k+1, board, board_flag, word)) return true;
            }
            if(inArea(i+1, j, board)&amp;&amp;!board_flag[i+1][j]) {
                if( exist_help(i+1, j, k+1, board, board_flag, word)) return true;
            }
            board_flag[i][j] = false;
        }
        return false;
        
    }
    boolean inArea(int i, int j, char[][]board) {
        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; board.length &amp;&amp; j &lt; board[0].length) {
            return true;
        }else {
            return false;
        }
    }
}
</code></pre>
<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<h4 id="动态规划-self-4"><a href="#动态规划-self-4" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-46"><a href="#思路-46" class="headerlink" title="思路"></a>思路</h5><p>可以分解为子问题, 1节点为1, 2节点为2, 3为5个节点, 然后</p>
<pre><code>4可以求解:
以1为中心, 左0右3
以2为中心, 左1右2
以3为中心, 左2右1
以4为中心, 左1右3
</code></pre>
<p>然后左边和右边数量<strong>是相乘的关系(组合)</strong>, 我第一次写为了相加.</p>
<blockquote>
<p>结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，…，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0)<em>G(n-1)+G(1)</em>(n-2)+…+G(n-1)*G(0)</p>
<p>-评论</p>
</blockquote>
<h5 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int numTrees(int n) {
        int[] tree_num = new int[20];
        tree_num[0] = 1;
        tree_num[1] = 1;
        tree_num[2] = 2;
        tree_num[3] = 5;
        for (int i = 4; i &lt;= n; i++) {
            for (int j = 1; j &lt;= i; j++) {
                tree_num[i]+=tree_num[j-1]*tree_num[i-j];
            }
        }
        return tree_num[n];
    }
}
</code></pre>
<h5 id="复杂度-40"><a href="#复杂度-40" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<h4 id="递归构造-self"><a href="#递归构造-self" class="headerlink" title="递归构造(self"></a>递归构造(self</h4><h5 id="思路-47"><a href="#思路-47" class="headerlink" title="思路"></a>思路</h5><p>前序的第一个节点可以将中序划分为两部分, 有一个细节是, 我刚开始划分为两部分, 然后分别在递归函数里面传递两部分的首位位置<code>s1, e1, s2, e2</code>, 但是这样数据比较多, 而且边界不容易界定, 所以改成了传递每个部分的首位置和元素的个数, 这样少了一个计算的参数, 不容易出错.</p>
<h5 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildTreeHelp(preorder,0,inorder,0,preorder.length);
    }
    public TreeNode buildTreeHelp(int [] preorder, int s1, int[] inorder, int s2, int count) {
        if(count==0) {			//思想,  一定要注意终止条件
            return null;
        }

        TreeNode new_node = new TreeNode(preorder[s1]);
        int index = 0;
        int left_num = 0;               //左侧元素的个数
        int right_num = 0;              //右侧元素的个数, 用于确定
        for (int i = s2; i &lt; s2+count; i++) {
            if(inorder[i] == preorder[s1]) {
                index = i;
                left_num = i - s2;
                right_num = count-1-left_num;
            }

        }
        new_node.left = buildTreeHelp(preorder, s1+1, inorder, s2, left_num);
        new_node.right = buildTreeHelp(preorder, s1+left_num+1, inorder, index+1, right_num);
        return new_node;
    }
}
</code></pre>
<h5 id="复杂度-41"><a href="#复杂度-41" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<pre><code>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
</code></pre>
<h4 id="递归原地算法-self"><a href="#递归原地算法-self" class="headerlink" title="递归原地算法(self"></a>递归原地算法(self</h4><h5 id="思路-48"><a href="#思路-48" class="headerlink" title="思路"></a>思路</h5><p>分各种情况讨论而已.</p>
<h5 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }
        else if (root.left == null &amp;&amp; root.right == null) {
            return;
        }else if (root.left == null &amp;&amp; root.right != null) {
            flatten(root.right);
            return;
        }else if (root.left!=null &amp;&amp; root.right == null) {
            flatten(root.left);
            root.right = root.left;
            root.left = null;
            return;
        }else {
            flatten(root.right);
            flatten(root.left);
            TreeNode temp_left = root.left;
            TreeNode temp_node = root.left;
            while(temp_node.right!=null) {
                temp_node = temp_node.right;
            }
            temp_node.right = root.right;
            root.right= temp_left;
            root.left = null;
            return;
        }
    }
}
</code></pre>
<h5 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h5><p>我的递归写复杂了</p>
<pre><code class="java">class Solution {
    public void flatten(TreeNode root) {
        if(root == null)
            return;
        // 拉直左子树
        flatten(root.left);
        // 拉直右子树
        flatten(root.right);

        // 将左子树末端连接右子树根
        if(root.left !=null){
            TreeNode p = root.left;
            while (p.right != null)
                p = p.right;
            p.right = root.right;
            root.right = root.left; // 右子树接到左子树
        }
        // 左子树置为null
        root.left = null;
    }
}


作者：zhy-20
链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/di-gui-er-cha-shu-zhan-kai-wei-lian-biao-jg0j/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h5 id="复杂度-42"><a href="#复杂度-42" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="前序遍历再构造"><a href="#前序遍历再构造" class="headerlink" title="前序遍历再构造*"></a>前序遍历再构造*</h4><h5 id="思路-49"><a href="#思路-49" class="headerlink" title="思路"></a>思路</h5><p>用List存储前序遍历结果, 再根据前序遍历结果, 但是这种方法不是原地方法</p>
<h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<h4 id="去重排序计数-self"><a href="#去重排序计数-self" class="headerlink" title="去重排序计数(self"></a>去重排序计数(self</h4><h5 id="思路-50"><a href="#思路-50" class="headerlink" title="思路"></a>思路</h5><p>去重排序计数</p>
<p>但是排序就是O(NlogN)了</p>
<h5 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int longestConsecutive(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for(int item:nums){
            set.add(item);
        }
        int size = set.size();
        int count = 0;
        int[] new_nums = new int[size];
        for(Integer item:set) {
            new_nums[count++] = item;
        }
        
        Arrays.sort(new_nums);
        
        if(new_nums.length==0) return 0;
        int max_length = 1;
        int length = 1;
        for (int i = 0; i &lt; new_nums.length-1; i++) {
            if(new_nums[i+1] == new_nums[i]+1) {
                length++;
                max_length = Math.max(max_length, length);
            }else {
                length = 1;
            }
        }
        return max_length;
    }
}
</code></pre>
<h5 id="复杂度-43"><a href="#复杂度-43" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(NLogN)$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash*"></a>Hash*</h4><h5 id="思路-51"><a href="#思路-51" class="headerlink" title="思路"></a>思路</h5><p>将数据存储到哈希表中, 再遍历, 如果某个数是开头(没有它的前一个数), 则进内循环得到以它为首的序列的长度, 否则不进内循环.</p>
<h5 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int longestConsecutive(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for(int item:nums){
            set.add(item);
        }
        int max_length = 0;
        int length = 1;
        for(int item:set) {
            if (!set.contains(item-1)) {
                int next_item = item+1;
                while(set.contains(next_item)) {
                    next_item++;
                    length++;
                }
                max_length = Math.max(length, max_length);
            }
            length = 1;
        }
        return max_length;
    }
}
</code></pre>
<h5 id="复杂度-44"><a href="#复杂度-44" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h4 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算*"></a>位运算*</h4><h5 id="思路-52"><a href="#思路-52" class="headerlink" title="思路"></a>思路</h5><p>位运算, 异或: 相异为1, 相同为0.</p>
<blockquote>
<p>Java提供的位运算符有：左移( &lt;&lt; )、右移( &gt;&gt; ) 、无符号右移( &gt;&gt;&gt; )  、位与( &amp; ) 、位或( | )、位非( ~ )、位异或( ^ )，除了位非( ~ )是一元操作符外，其它的都是二元操作符。</p>
</blockquote>
<h5 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            result = result ^ nums[i];
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-45"><a href="#复杂度-45" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="139-单词拆分-alarm-clock"><a href="#139-单词拆分-alarm-clock" class="headerlink" title="139. 单词拆分:alarm_clock:"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a><span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<pre><code>示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。

示例 3：

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false

 

提示：

    1 &lt;= s.length &lt;= 300
    1 &lt;= wordDict.length &lt;= 1000
    1 &lt;= wordDict[i].length &lt;= 20
    s 和 wordDict[i] 仅有小写英文字母组成
    wordDict 中的所有字符串 互不相同
</code></pre>
<h4 id="用set存储后递归-self-没解决"><a href="#用set存储后递归-self-没解决" class="headerlink" title="用set存储后递归(self, 没解决"></a>用set存储后递归(self, 没解决</h4><h5 id="思路-53"><a href="#思路-53" class="headerlink" title="思路"></a>思路</h5><p>用set存储字典, 然后递归判断, 为了加快速度, 使用字典中字词的最短长度和最长长度.</p>
<p>但是下面的样例会超出时间限制.</p>
<pre><code>"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"
["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]
</code></pre>
<p>因为是递归遍历, 而且<code>aaaaaaa</code>与<code>[a, aa, aaa]</code>有太多次匹配和递归了.</p>
<p>如果有优化的话, 就是将字典中的词典,只存储最小的”字”, 比如[a, aa]只存储[a], 纸样的话下面的代码可以改造为</p>
<pre><code>return wordBreakHelp(s.substring(i), wordDictSet, shortest, longest);
</code></pre>
<h5 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        int shortest = 21;
        int longest = 0;
        Set&lt;String&gt; wordDictSet = new HashSet&lt;String&gt;();
        for (int i = 0; i &lt; wordDict.size(); i++) {
            wordDictSet.add(wordDict.get(i));
            shortest = Math.min(wordDict.get(i).length(), shortest);
            longest = Math.max(wordDict.get(i).length(), longest);
        }
        return wordBreakHelp(s, wordDictSet, shortest, longest);
    }
    public boolean wordBreakHelp(String s, Set&lt;String&gt; wordDictSet, int shortest, int longest) {
        boolean flag = false;
        if(s.length() == 0) return true;
        for(int i = shortest; i &lt;= longest; i++) {
            if (s.length() &lt; i) return false;
            if (wordDictSet.contains(s.substring(0,i))) {
                flag = wordBreakHelp(s.substring(i), wordDictSet, shortest, longest);
                if(flag) return true;
            }
        }
        return false;
    }
}
</code></pre>
<h5 id="复杂度-46"><a href="#复杂度-46" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="思想2名称-2"><a href="#思想2名称-2" class="headerlink" title="思想2名称*"></a>思想2名称*</h4><h5 id="思路-54"><a href="#思路-54" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-47"><a href="#复杂度-47" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<h4 id="快慢指针-一二两次相遇"><a href="#快慢指针-一二两次相遇" class="headerlink" title="快慢指针+一二两次相遇"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/">快慢指针+一二两次相遇</a></h4><h5 id="思路-55"><a href="#思路-55" class="headerlink" title="思路"></a>思路</h5><p>==第一次相遇的节点 和 头结点 同时移动, 下次相同的节点就是入口==</p>
<blockquote>
<p>总结关键点(注意a是除环外的长度(也就是起始点距离进入环节点的距离),b是环的长度, n是未知数)</p>
<ul>
<li>1.第一次相遇，slow = nb(是由fast=2slow, fast = slow+nb推出的)</li>
<li>2.a+nb = 入口点</li>
<li>3.slow再走a = 入口 = head走到入口 = a</li>
<li>4.由3得出，起始点(head) + a = 第一次相遇位置(nb) + a</li>
<li>5.a不是显性的求出来的, 只需要同时移动起始点和第一次相遇位置即可</li>
</ul>
<p>感觉就是数学公式推导+逻辑结合的一道题</p>
</blockquote>
<h5 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(true) {
            if(slow == null || fast == null || fast.next == null) return null;  //无环
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) break;            //第一次相遇
        }
        // f = 2s
        // f = s+nb 快慢指针相遇时走的步数为s的步数+n圈环的步数
        // s = nb   快慢指针相遇时s的步数由前两式子得到为nb
        // 将f置为0, s=nb, 快慢指针再次向前移动, 两者相遇时节点为环的入口.
        ListNode temp = head;
        while(temp != slow) {           //然后起始点+a = nb + a, 而nb + a就是入口点也就是答案
            temp = temp.next;
            slow = slow.next;
        }
        return temp;
        
    }
}
</code></pre>
<h5 id="复杂度-48"><a href="#复杂度-48" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="修改链表"><a href="#修改链表" class="headerlink" title="修改链表"></a>修改链表</h4><h5 id="思路-56"><a href="#思路-56" class="headerlink" title="思路"></a>思路</h5><p>遍历链表, 将链表的每个节点.next都赋值为temp, 这样就把节点一个一个拆开了(不符合题意), 遇到环的时候就是.next==temp的时候.</p>
<h3 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></h3><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：</p>
<ul>
<li>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</li>
<li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</li>
</ul>
<p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<h4 id="自制双向链表-self"><a href="#自制双向链表-self" class="headerlink" title="自制双向链表(self"></a>自制双向链表(self</h4><h5 id="思路-57"><a href="#思路-57" class="headerlink" title="思路"></a>思路</h5><h5 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class BiLinkedNode{
    public BiLinkedNode previous;
    public BiLinkedNode next;
    public int key;
    public int val;
    BiLinkedNode(){
        previous = null;
        next = null;
        val = -1;
    }
    BiLinkedNode(int key, int val){
        previous = null;
        next = null;
        this.key = key;
        this.val = val;
    }
}

class LRUCache {

    private int capacity;
    private int count;
    private BiLinkedNode head;
    private BiLinkedNode tail;
    private Map&lt;Integer, BiLinkedNode&gt; m;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.count = 0;
        this.m = new HashMap&lt;&gt;();
        this.head = new BiLinkedNode();
        this.tail = new BiLinkedNode();
        head.next = tail;				//思想,头节点是假节点.
        tail.previous = head;       	//思想,注意tail是单独的tail
    }
    
    public int get(int key) {
        if(m.containsKey(key)) {
            BiLinkedNode temp = new BiLinkedNode(key, m.get(key).val);
            deleteNode(m.get(key));
            insertLast(temp);
            m.remove(key);
            m.put(key, temp);
            return m.get(key).val;
        }
        else return -1;
    }
    
    public void put(int key, int value) {

        if (m.containsKey(key)==true) {
            deleteNode(m.get(key));
            m.remove(key);
            BiLinkedNode temp = new BiLinkedNode(key, value);
            m.put(key, temp);
            insertLast(temp);
            
        }
        else {
            if (count==capacity) {
                BiLinkedNode temp = new BiLinkedNode(key, value);
                System.out.println("key:"+key+" remove"+head.next.val);
                m.remove(head.next.key);        //这里应该是移除head.next.val对应的key
                deleteFirst();
                m.put(key, temp);
                insertLast(temp);
            }else {
                BiLinkedNode temp = new BiLinkedNode(key, value);
                insertLast(temp);
                m.put(key, temp);
                count+=1;
            }
        }
    }
    public void deleteFirst() {			//语法, 其实可以与下面的合并
        head.next = head.next.next;
        head.next.previous = head;
        return;
    }
    public void deleteNode(BiLinkedNode temp) {
        temp.previous.next = temp.next;
        temp.next.previous = temp.previous;
        return;
    }
    public void insertLast(BiLinkedNode temp) {
        tail.previous.next = temp;
        temp.previous = tail.previous;
        temp.next = tail;
        tail.previous = temp;
        return;
    }
    public void printList() {
        BiLinkedNode node= head.next;
        while(node !=null) {
            System.out.print(node.val+" ");
            node = node.next;
        }
        System.out.println();
        return;
    }
}
</code></pre>
<p>我构造了太多的节点了, 没有弄好数据结构和面向对象化数据结构,导致代码重用性不高, 开销大, 但至少AC了</p>
<h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h3><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<pre><code>输入：head = [4,2,1,3](以链表形式存在)
输出：[1,2,3,4]
</code></pre>
<p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<h4 id="list存储快排后再赋值-self"><a href="#list存储快排后再赋值-self" class="headerlink" title="list存储快排后再赋值(self"></a>list存储快排后再赋值(self</h4><h5 id="思路-58"><a href="#思路-58" class="headerlink" title="思路"></a>思路</h5><p>list存储快排后再赋值给链表</p>
<h5 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode sortList(ListNode head) {
        List&lt;Integer&gt; data = new ArrayList&lt;&gt;();
        ListNode p = head;
        while(p != null) {
            data.add(p.val);
            p = p.next;
        }
        Collections.sort(data);
        p = head;
        for(int i = 0; i &lt; data.size(); i++) {
            p.val = data.get(i);
            p = p.next;
        }
        return head;
    }
}
</code></pre>
<h5 id="复杂度-49"><a href="#复杂度-49" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(NLogN)$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="归并-slef"><a href="#归并-slef" class="headerlink" title="归并(slef*"></a>归并(slef*</h4><h5 id="思路-59"><a href="#思路-59" class="headerlink" title="思路"></a>思路</h5><p><img src="https://raw.githubusercontent.com/pengber/pic-bed/main/img/image-20220310142915943.png" alt="image-20220310142915943"></p>
<p>平均时间为O(NlogN)并且辅助空间为O(1)的只能是归并(对链表排序的最佳方案).</p>
<h5 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public ListNode sortList(ListNode head) {
        int length = 0;
        ListNode point = head;
        while(point != null) {
            length++;
            point = point.next;
        }
        return sortListHelp(head, length);
    }
    public ListNode sortListHelp(ListNode head, int length) {
        if (length == 1||length == 0) {
            return head;
        } 
        ListNode first_point = head;
        ListNode another_head = head;
        for(int i = 0; i &lt; length - length/2; i++) {
            
            if (i == length-length/2-1) {
                another_head = first_point.next;
                first_point.next = null;
            }else{
                first_point = first_point.next;
            }
            
        }
        ListNode first_head = sortListHelp(head, length - length/2);
        ListNode second_head = sortListHelp(another_head, length/2);
        ListNode new_head = new ListNode();
        ListNode point = new_head;
        while(first_head != null &amp;&amp; second_head != null) {
            if (first_head.val &lt; second_head.val) {
                point.next = first_head;
                first_head = first_head.next;
                point = point.next;
            }else {
                point.next = second_head;
                second_head = second_head.next;
                point = point.next;
            }
        }
        while(first_head!=null) {
            point.next = first_head;
            first_head = first_head.next;
            point = point.next;
            //以上可以简写为point.next = first_head即可.
        }
        while(second_head!=null){
             point.next = second_head;
            second_head = second_head.next;
            point = point.next;
            //以上可以简写为point.next = second_head即可.
        }
        point.next = null;
        return new_head.next;
    }
}
</code></pre>
<h5 id="复杂度-50"><a href="#复杂度-50" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(NlogN)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h3><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<p>子数组 是数组的连续子序列。</p>
<h4 id="以0分割后双向遍历遇到负数个数为奇数时最后一个奇数停止"><a href="#以0分割后双向遍历遇到负数个数为奇数时最后一个奇数停止" class="headerlink" title="以0分割后双向遍历遇到负数个数为奇数时最后一个奇数停止"></a>以0分割后双向遍历遇到负数个数为奇数时最后一个奇数停止</h4><h5 id="思路-60"><a href="#思路-60" class="headerlink" title="思路"></a>思路</h5><p>[1, 2, -3, -4, -5] 的最大值是[1, 2, -3, -4]和[-4, -5]中的一个.</p>
<p>[1, 2, 0, 3, 4]的最大值是[1, 2]和[3, 4]中的一个.</p>
<h5 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxProduct(int[] nums) {
        int max = -11;              //结果,-11因为最小是-10
        int s = 0;                  //开始下标预赋值
        int e = nums.length-1;      //结束下标预赋值
        List&lt;List&lt;Integer&gt;&gt; zero_index = new ArrayList&lt;&gt;();
        int zero_count = 0;

        // 求得以0为分割的区间下标起始点和终止点
        for (int i = 0; i &lt; nums.length; i++) {
            List&lt;Integer&gt; pair = new ArrayList&lt;&gt;();
            if(nums[i] == 0) {
                pair.add(s);
                pair.add(i-1);
                zero_index.add(pair);
                s = i+1;
                zero_count++;
            }
            if(i == nums.length-1){
                if(nums[i] == 0){
                    break;
                }else{
                    pair.add(s);
                    pair.add(i);
                    zero_index.add(pair);
                }
            }
        }

        //以0左分割
        for (int i = 0; i &lt; zero_index.size(); i++) {
            int product = maxProductHelp(nums, zero_index.get(i).get(0), zero_index.get(i).get(1));
            max = Math.max(max, product);

        }
        
        //因为0也是子序列, 所以以防[-2, 0]这种样例
        if (zero_count &gt; 0) {
            return Math.max(max, 0);
        }
        return max;
    }
    public int maxProductHelp(int [] nums, int s, int e) {
        int count = 0;      //负数的个数
        
        //统计负数的个数
        for (int i = s; i &lt;= e; i++) {
            if (nums[i] &lt; 0) {
                count++;
            }
        }

        if(e &lt;= s) return nums[s];      //如果是一个数则直接返回

        if(count%2 == 0) {              //如果负数时偶数则直接乘积返回
            int result = 1;
            for(int i = s; i &lt;= e; i++) {
                result = result * nums[i];
            }
            return result;
        }

        //要么是从左往右相乘遇到最后一个负数停止的积
        //要么是从右往左相乘遇到最后一个负数停止的积
        int count1 = 0;
        int product1 = 1;

        int count2 = 0;
        int product2 = 1;
        for(int i = s; i &lt;= e; i++) {  
            if(nums[i] &lt; 0) count1++;
            if(count1 == count) {
                break;
            }
            product1 = product1 * nums[i];
        }

        for(int i = e; i &gt;= s; i--) {
            if(nums[i] &lt; 0) count2++;
            if(count2 == count){
                break;
            }
            product2 = product2 * nums[i];
        }
        return Math.max(product1, product2);
    }
}
</code></pre>
<h5 id="复杂度-51"><a href="#复杂度-51" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="动态规划-alarm-clock"><a href="#动态规划-alarm-clock" class="headerlink" title="动态规划:alarm_clock:"></a>动态规划<span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><h5 id="思路-61"><a href="#思路-61" class="headerlink" title="思路"></a>思路</h5><p>动态规划方程</p>
<pre><code>maxF[i] = Math.max(Math.max(maxF[i-1]*nums[i], minF[i-1]*nums[i]), nums[i]);
minF[i] = Math.min(Math.min(maxF[i-1]*nums[i], minF[i-1]*nums[i]), nums[i]);
</code></pre>
<h5 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxProduct(int[] nums) {
        int length = nums.length;
        int max = nums[0];
        int[] maxF = new int[length];
        int[] minF = new int[length];
        if(length == 1) return nums[0];
        System.arraycopy(nums, 0, maxF, 0, length);
        System.arraycopy(nums, 0, minF, 0, length);
        for(int i = 1; i &lt; length; i++) {
            maxF[i] = Math.max(Math.max(maxF[i-1]*nums[i], minF[i-1]*nums[i]), nums[i]);
            minF[i] = Math.min(Math.min(maxF[i-1]*nums[i], minF[i-1]*nums[i]), nums[i]);
        }
        for(int i = 0; i &lt; length; i++) {
            max = Math.max(maxF[i], max);
        }
        return max;
    }
}
</code></pre>
<h5 id="复杂度-52"><a href="#复杂度-52" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h3><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 MinStack 类:</p>
<pre><code>MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。
</code></pre>
<h4 id="一个数字栈一个最小数字栈-self"><a href="#一个数字栈一个最小数字栈-self" class="headerlink" title="一个数字栈一个最小数字栈(self"></a>一个数字栈一个最小数字栈(self</h4><h5 id="思路-62"><a href="#思路-62" class="headerlink" title="思路"></a>思路</h5><p>本来想用优先队列存储最小元素的, 但是发现无法以O(1)在pop的时候也删除最小元素, 所以想到了两个栈, 以前数据结构时作过.</p>
<h5 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class MinStack {
    private List&lt;Integer&gt; minStack;
    private int count;
    private List&lt;Integer&gt; numStack;
    public MinStack() {
        numStack = new ArrayList&lt;&gt;();
        minStack = new ArrayList&lt;&gt;();
        count = 0;
    }
    
    public void push(int val) {
        numStack.add(val);
        if (count == 0) {
            minStack.add(val);
        }else {
            int min = this.getMin();
            if(min &lt; val) {
                minStack.add(min);
            }else{
                minStack.add(val);
            }
        }
        count++;
    }
    
    public void pop() {
        numStack.remove(count-1);
        minStack.remove(count-1);
        count--;
    }
    
    public int top() {
        return numStack.get(count-1);

    }
    
    public int getMin() {
        return minStack.get(count-1);
    }
}
</code></pre>
<h5 id="复杂度-53"><a href="#复杂度-53" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="自定义pair链表存储"><a href="#自定义pair链表存储" class="headerlink" title="自定义pair链表存储*"></a>自定义pair链表存储*</h4><h5 id="思路-63"><a href="#思路-63" class="headerlink" title="思路"></a>思路</h5><p>pair存储数字和对应的最小数字</p>
<h5 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class MinStack {
    private Node head;
    
    public void push(int x) {
        if(head == null) 
            head = new Node(x, x);
        else 
            head = new Node(x, Math.min(x, head.min), head);
    }

    public void pop() {
        head = head.next;
    }

    public int top() {
        return head.val;
    }

    public int getMin() {
        return head.min;
    }
    
    private class Node {
        int val;
        int min;
        Node next;
        
        private Node(int val, int min) {
            this(val, min, null);
        }
        
        private Node(int val, int min, Node next) {
            this.val = val;
            this.min = min;
            this.next = next;
        }
    }
}
</code></pre>
<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<h4 id="指针法-self"><a href="#指针法-self" class="headerlink" title="指针法(self"></a>指针法(self</h4><h5 id="思路-64"><a href="#思路-64" class="headerlink" title="思路"></a>思路</h5><p>让长的链表先移动Math.abs(LengthA-LengB), 然后两个一起移动, 移动到末尾时还没有相等则为null, 否则返回相同的节点.</p>
<h5 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

        int lengthA = getLength(headA);
        int lengthB = getLength(headB);
        ListNode longHead = lengthA &gt; lengthB ? headA:headB;
        ListNode shortHead = lengthA &gt; lengthB ? headB:headA;
        ListNode newLongHead = move(longHead, Math.abs(lengthA-lengthB));
        for (int i = 0; i &lt; Math.min(lengthA, lengthB); i++) {
            if(newLongHead == null || shortHead ==null) return null;
            else if (newLongHead == shortHead) return newLongHead;
            newLongHead = move(newLongHead, 1);
            shortHead = move(shortHead, 1);
        }
        return null;
    }
    public ListNode move(ListNode head, int step){
        ListNode node = head;
        for(int i = 0; i &lt; step; i++) {
            node = node.next;
        }
        return node;
    }
    public int getLength(ListNode head){
        int length = 0;
        ListNode node = head;
        while(node != null){
            length++;
            node = node.next;
        }
        return length;
    }
    public void printHead(ListNode head) {
        ListNode node = head;
        while(node != null) {
            System.out.print(node.val);
            node = node.next;
        }
        System.out.println();
    }
}
</code></pre>
<h5 id="复杂度-54"><a href="#复杂度-54" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M+N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="双指针优雅永不过时"><a href="#双指针优雅永不过时" class="headerlink" title="双指针优雅永不过时*"></a>双指针优雅永不过时*</h4><h5 id="思路-65"><a href="#思路-65" class="headerlink" title="思路"></a>思路</h5><p>让两个指针移动, 谁移动到末尾就指向另一个链表的头部, 这样的话等两个指针各移动一次到末尾之后就长度相等了, 抹平了不相等的那一部分.</p>
<h5 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h5><pre><code>public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode pA = headA, pB = headB;
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}


作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h5 id="复杂度-55"><a href="#复杂度-55" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M+N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></h3><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h4 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h4><h5 id="思路-66"><a href="#思路-66" class="headerlink" title="思路"></a>思路</h5><p>遇到相同的计数+1, 否则计数-1, 如果计数为0则换个数字.</p>
<h5 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        int num = nums[0];
        for(int i = 0; i &lt; nums.length; i++){
            if(count == 0) {
                num = nums[i];
                count++;
            }else {
                if (nums[i] != num) {
                    count--;
                }else{
                    count++;
                }
            }
        }
        return num;
    }
}
</code></pre>
<h5 id="复杂度-56"><a href="#复杂度-56" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<h4 id="深度遍历-self"><a href="#深度遍历-self" class="headerlink" title="深度遍历(self"></a>深度遍历(self</h4><h5 id="思路-67"><a href="#思路-67" class="headerlink" title="思路"></a>思路</h5><p>用标记数组先标记海洋为访问过, 然后遍历每一个陆地, 将陆地的连片岛屿进行标记为访问过.</p>
<p>遍历每一个陆地, 如果没有访问过就数字+1</p>
<h5 id="代码-62"><a href="#代码-62" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    private int[][] bias = new int[][]{{-1,0},{+1,0},{0,-1},{0,+1}};
    public int numIslands(char[][] grid) {
        boolean flag = false;
        int[][] visited = new int[grid.length][grid[0].length];
        int num = 0;
        for(int i = 0; i &lt; grid.length; i++) {
            for (int j = 0; j &lt; grid[0].length; j++) {
                if(grid[i][j] == '0') {
                    visited[i][j] = 1;
                }
            }
        }
        for(int i = 0; i &lt; grid.length; i++) {
            for (int j = 0; j &lt; grid[0].length; j++) {
                if (visited[i][j] == 0) {
                    num++;
                    numIslandsHelp(grid, visited, i, j);
                }
            }
        }
        return num;
    }
    public void numIslandsHelp(char[][] grid, int[][]visited, int m, int n){
    
        if(m &lt; 0 || m &gt;= grid.length || n &lt; 0 || n &gt;= grid[0].length) {
            return;
        }
        if(visited[m][n] == 1) {
            return; 
        }
        visited[m][n] = 1;
        for(int i = 0;i &lt; 4; i++) {
            int x = m+bias[i][0];
            int y = n+bias[i][1];
            numIslandsHelp(grid, visited, x, y);  
        }
        return;
    }
}
</code></pre>
<h5 id="复杂度-57"><a href="#复杂度-57" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(M*N)$</li>
</ul>
<h3 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h3><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<pre><code>Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。
</code></pre>
<h4 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h4><h5 id="思路-68"><a href="#思路-68" class="headerlink" title="思路"></a>思路</h5><p>前缀树的节点是这样的:</p>
<pre><code class="java">private class TrieNode {                //语法
    boolean isKey;
    TrieNode[] children;
    TrieNode(){
        isKey = false;
        children = new TrieNode[26];         //思想
    }
}
</code></pre>
<p>如果一个孩子不存在, 是这样判断的(也就是TrieNode[]的默认值是null):</p>
<pre><code> if(node.children[pos]==null)
</code></pre>
<h5 id="代码-63"><a href="#代码-63" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Trie {
    private class TrieNode {                //语法
    boolean isKey;
    TrieNode[] children;
    TrieNode(){
        isKey = false;
        children = new TrieNode[26];         //思想
    }
    }
    private TrieNode root;
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode node = root;
        for (int i = 0; i &lt; word.length(); i++) {
            int pos = word.charAt(i)-'a';
            if(node.children[pos]==null){       //思想
                TrieNode new_children = new TrieNode();
                node.children[pos] = new_children;
                node = node.children[pos];      //思想,
            }
            else{
                node = node.children[pos];
            }
        }
        node.isKey = true;
        return;
    }
    
    public boolean search(String word) {
        TrieNode node = root;
        for (int i = 0; i &lt; word.length(); i++) {
            int pos = word.charAt(i)-'a';
            if(node.children[pos]==null){
                return false;
            }else{
                node = node.children[pos];
            }
        }
        return node.isKey;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (int i = 0; i &lt; prefix.length(); i++) {
            int pos = prefix.charAt(i)-'a';
            if(node.children[pos]==null){
                return false;
            }else{
                node = node.children[pos];
            }
        }
        return true;
    }
}
</code></pre>
<h3 id="215-数组中的第K个最大元素-alarm-clock"><a href="#215-数组中的第K个最大元素-alarm-clock" class="headerlink" title="215. 数组中的第K个最大元素:alarm_clock:"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a><span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<h4 id="调用库函数-self"><a href="#调用库函数-self" class="headerlink" title="调用库函数(self"></a>调用库函数(self</h4><h5 id="代码-64"><a href="#代码-64" class="headerlink" title="代码"></a>代码</h5><pre><code>class Solution {
    public int findKthLargest(int[] nums, int k) {
       Arrays.sort(nums);				//语法
       return nums[nums.length-k]; 
    }
}
</code></pre>
<h5 id="复杂度-58"><a href="#复杂度-58" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="思想2名称-3"><a href="#思想2名称-3" class="headerlink" title="思想2名称*"></a>思想2名称*</h4><h5 id="思路-69"><a href="#思路-69" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-65"><a href="#代码-65" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-59"><a href="#复杂度-59" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></h3><p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。</p>
<h4 id="动态规划-self-5"><a href="#动态规划-self-5" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-70"><a href="#思路-70" class="headerlink" title="思路"></a>思路</h5><p>$dp[i][j]$代表该位置为正方形右下角的最大边长.<br>$$<br>dp[i][j] = 0 if(matrix[i][j] == 0)\<br>dp[i][j] = 1+[1,2,m,..dp[i-1][j-1]]中最大的m使得matrix[i-(1..m)][j]和matrix[i][j-(1..m)]都是1.<br>$$</p>
<h5 id="代码-66"><a href="#代码-66" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maximalSquare(char[][] matrix) {
        int rowNum = matrix.length;
        int colNum = matrix[0].length;
        int[][] flag = new int[rowNum][colNum];
        int max = 0;        //最大边长
        for(int i = 0; i &lt; rowNum; i++) {
            for(int j = 0; j &lt; colNum; j++) {
                flag[i][j] = matrix[i][j]-'0';
            }
        }
        

        for(int i = 1; i &lt; rowNum; i++) {
            for(int j = 1; j &lt; colNum; j++) {
                int last = flag[i-1][j-1];	//以左上角的那个元素为正方形右下角的最大边长
                for(int k = last; k &gt;= 1; k--) {
                    //从高往低刷
                    boolean tag = true;		//i行j列的元素是否都&gt;0(表示可以是边长)
                    for(int m = 1; m &lt;= k; m++) {
                        tag = tag &amp;&amp; flag[i][j-m]&gt;0?true:false;
                        tag = tag &amp;&amp; flag[i-m][j]&gt;0?true:false;
                    }
                    if(tag == true &amp;&amp; flag[i][j] == 1) {
                        flag[i][j] += k;
                        break;				//如果已经组成正方形则break,防止正方形边长缩小
                    }
                }
                
            }
        }
        for(int i = 0; i &lt; rowNum; i++) {
            for (int j = 0; j &lt; colNum; j++) {
                max = Math.max(max, flag[i][j]);
            }
        }
        return max*max;
    }
}
</code></pre>
<h5 id="复杂度-60"><a href="#复杂度-60" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(N^2)$</li>
</ul>
<h4 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划*"></a>动态规划*</h4><h5 id="思路-71"><a href="#思路-71" class="headerlink" title="思路"></a>思路</h5><blockquote>
<pre><code class="java">        dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为: 
        dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);
</code></pre>
</blockquote>
<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<h4 id="折半反转对比-self"><a href="#折半反转对比-self" class="headerlink" title="折半反转对比(self"></a>折半反转对比(self</h4><h5 id="思路-72"><a href="#思路-72" class="headerlink" title="思路"></a>思路</h5><p>折半反转对比</p>
<h5 id="代码-67"><a href="#代码-67" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        int length = 0;
        ListNode node = head;
        ListNode head2;
        ListNode new_head = new ListNode();
        //求链表长度
        while(node!=null) {
            length++;
            node = node.next;
        }
        node = head;
        //将链表对半
        for(int i = 0; i &lt; (length+1)/2-1; i++) {
            node = node.next;
        }
        head2 = node.next;
        node.next = null;

        
        //转置链表
        while(head2 != null) {
            ListNode temp = head2.next;
            head2.next = new_head.next;
            new_head.next = head2;
            head2 = temp;
        }
        new_head = new_head.next;

        //判断饭转后的链表的一半是否和另一半相同
        for(int i = 0; i &lt; length/2; i++) {
            if(head.val == new_head.val) {
                head = head.next;
                new_head = new_head.next;
                continue;
            }
            else return false;
        }
        return true;
        
    }
    
}
</code></pre>
<h5 id="复杂度-61"><a href="#复杂度-61" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="快慢指针-alarm-clock"><a href="#快慢指针-alarm-clock" class="headerlink" title="快慢指针*(:alarm_clock:"></a>快慢指针*(<span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><h5 id="思路-73"><a href="#思路-73" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-68"><a href="#代码-68" class="headerlink" title="代码"></a>代码</h5><pre><code>
</code></pre>
<h5 id="复杂度-62"><a href="#复杂度-62" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="236-二叉树的最近公共祖先-LCA"><a href="#236-二叉树的最近公共祖先-LCA" class="headerlink" title="236. 二叉树的最近公共祖先(LCA)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>(LCA)</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><h5 id="思路-74"><a href="#思路-74" class="headerlink" title="思路"></a>思路</h5><p>递归函数:</p>
<ul>
<li>返回值: 返回root节点下最近的含有p或者q的节点</li>
<li>终止条件: <ul>
<li>如果root是p或者q返回root, 否则(root==null或者其他情况)返回null</li>
<li>后序遍历子树</li>
<li>如果左孩子和右孩子中都有p或者q的父节点的话, 返回root(因为是后序遍历, 自底向上遍历, 所以第一次返回的必然是最近公共祖先), 否则只返回含有p或者q的节点</li>
</ul>
</li>
</ul>
<h5 id="代码-69"><a href="#代码-69" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //递归函数:如果root是p或q的最近父节点,返回root,否则返回null
        if(root == p || root == q || root == null) return root;

        TreeNode left_father = lowestCommonAncestor(root.left, p, q);
        TreeNode right_father = lowestCommonAncestor(root.right, p, q);

        //想法, 后序遍历
        if (left_father!= null &amp;&amp; right_father != null) {
            //如果左右孩子都有p或者q, 则root是最近父节点
            return root;
        }else if (left_father != null) {
            //如果左孩子下面有节点是p或q的父节点(此时右孩子不是p或者q的父节点),返回该节点
            return left_father;
        }else if (right_father != null) {
            return right_father;
        }else{
            return null;
        }
    }
}
</code></pre>
<h5 id="复杂度-63"><a href="#复杂度-63" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$(每个节点被访问一次)</li>
<li>空间: $O(N)$(最差情况下为一条单链)</li>
</ul>
<h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h3><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p>
<p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p>
<p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<pre><code>示例 1:

输入: nums = [1,2,3,4]
输出: [24,12,8,6]

示例 2:

输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
</code></pre>
<p><strong>进阶：</strong>你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。</p>
<h4 id="左累乘右累乘再相乘"><a href="#左累乘右累乘再相乘" class="headerlink" title="左累乘右累乘再相乘"></a>左累乘右累乘再相乘</h4><h5 id="思路-75"><a href="#思路-75" class="headerlink" title="思路"></a>思路</h5><p>用两个数组存储某位的左累乘和右累乘的结果, 比如</p>
<pre><code>[1,    2,   3,   4]
[1 	  ,1,  1*2, 1*2*3]
[2*3*4,3*4, 4,  1]
</code></pre>
<p>而在计算下面这两个数组的时候是可以优化为O(1)的, 因为是累乘.</p>
<p>注意:</p>
<ul>
<li>O(N)算法可以扫描多遍</li>
<li>O(1)算法用累乘</li>
</ul>
<h5 id="代码-70"><a href="#代码-70" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] result = new int[nums.length];
        int p = 1;      //存储某个数左边的连乘结果
        int q = 1;      //存储某个数右乘的连乘结果

        result[0] = 1;
        for(int i = 1; i &lt; nums.length; i++) {
            p = p*nums[i-1];
            result[i] = p;
        }
        for(int i = nums.length-2; i &gt;= 0; i--) {
            q = q*nums[i+1];
            result[i] = result[i] * q;
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-64"><a href="#复杂度-64" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h3><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<pre><code>每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
</code></pre>
<h4 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h4><h5 id="思路-76"><a href="#思路-76" class="headerlink" title="思路"></a>思路</h5><p>逐个遍历比较</p>
<h5 id="代码-71"><a href="#代码-71" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for (int i = 0; i &lt; matrix.length; i++) {
            for(int j = 0; j &lt; matrix[0].length; j++) {
                if (matrix[i][j] == target) return true;
            }
        }
        return false;
    }

}
</code></pre>
<h5 id="复杂度-65"><a href="#复杂度-65" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(M*N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="对每行二分查找"><a href="#对每行二分查找" class="headerlink" title="对每行二分查找"></a>对每行二分查找</h4><h5 id="思路-77"><a href="#思路-77" class="headerlink" title="思路"></a>思路</h5><p>对每行使用二分查找</p>
<h5 id="代码-72"><a href="#代码-72" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for (int[]nums:matrix){
            int result = search(nums, target);
            if (result != -1) return true;
        }
        return false;
    }
    public int search(int[] nums, int target){
        int low = 0;
        int high = nums.length-1;
        while(low &lt;= high) {
            int mid = (high-low)/2+low;
            int num = nums[mid];
            if (num == target){
                return mid;
            }else if (num&gt; target){
                high = mid-1;
            }else{
                low = mid + 1;
            }
        }
        return -1;
    }

}
</code></pre>
<h5 id="复杂度-66"><a href="#复杂度-66" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N*log^N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h3><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<h4 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="思路-78"><a href="#思路-78" class="headerlink" title="思路"></a>思路</h5><p>动态规划方程:<br>$$<br>f[i] = 1 + min(f_{j=1}^\sqrt[2]i[i-j*j])<br>$$<br>含义是: </p>
<p>正如i的完全平方数的最少数量等于1+比它小的能组成它的数字的完全平方数的最小数量.</p>
<h5 id="代码-73"><a href="#代码-73" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int numSquares(int n) {
        int []f = new int[n+1];
        f[0] = 0;
        for(int i = 1; i &lt;= n; i++){
            int min = Integer.MAX_VALUE;
            for(int j = 1; j * j &lt;= i; j++){
                min = Math.min(min, f[i-j*j]);		//思想
            }
            f[i] = min+1;
        }
        return f[n];
    }
}
</code></pre>
<h5 id="复杂度-67"><a href="#复杂度-67" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N*\sqrt[2]{N}$</li>
<li>空间: $O(N)$</li>
</ul>
<h4 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h4><h5 id="思路-79"><a href="#思路-79" class="headerlink" title="思路"></a>思路</h5><p>四平方和定理: 一个数最多能表示为4个平方数之和, 如果恰好为4个平方数之和, 那必然满足$n=4^i+(8j+7)$.</p>
<p>那么一个数的平方数只有以下可能:</p>
<ul>
<li>4 : 满足$n=4^i+(8j+7)$.</li>
<li>1: 满足$n=i*i$</li>
<li>2: 满足$n=i<em>i + j</em>j$</li>
<li>3: 不满足以上条件</li>
</ul>
<h5 id="代码-74"><a href="#代码-74" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int numSquares(int n) {
        if(satisfy4(n)) return 4;
        else if(satisfy1(n)) return 1;
        
        for(int i = 0; i*i&lt;n; i++){
            if(satisfy1(n-i*i)) return 2;
        }
        return 3;
    }
    boolean satisfy4(int n){			//思想
        while(n%4==0){
            n = n/4;
        }
        return n%8==7;
    }
    boolean satisfy1(int n){			//思想
        int r = (int)Math.sqrt(n);
        return r*r == n;
    }

}
</code></pre>
<h5 id="复杂度-68"><a href="#复杂度-68" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(\sqrt[2]{N})$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<h4 id="将非0覆盖到数组前面后面赋值0-self"><a href="#将非0覆盖到数组前面后面赋值0-self" class="headerlink" title="将非0覆盖到数组前面后面赋值0(self"></a>将非0覆盖到数组前面后面赋值0(self</h4><h5 id="思路-80"><a href="#思路-80" class="headerlink" title="思路"></a>思路</h5><p>第一次遍历计算0的个数, 然后第二次遍历将非0元素覆盖到前面, 后面再赋值count个0到数组后面</p>
<blockquote>
<p>覆盖法的优点是每个都要赋值一次，但是原本结果是0的位置全部要写一次。 交换法虽然每次代价是赋值2次（a=b;b=0;），但是后面都是0的位置可以不用再操作了。</p>
</blockquote>
<h5 id="代码-75"><a href="#代码-75" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void moveZeroes(int[] nums) {
        int start = 0;
        int count = 0;
        //计算0元素个数
        for(int i = 0; i &lt; nums.length; i++) {
            if(nums[i] == 0) count++;
        }
        for(int i = 0; i &lt; nums.length; i++) {
            if (nums[i] != 0) nums[start++] = nums[i];
            if (i &gt;= nums.length-count) nums[i] = 0;
        }
        return;
    }
}
</code></pre>
<h5 id="复杂度-69"><a href="#复杂度-69" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h4 id="左右指针-alarm-clock"><a href="#左右指针-alarm-clock" class="headerlink" title="左右指针:alarm_clock:"></a>左右指针<span class="github-emoji"><span>⏰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/23f0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><h5 id="思路-81"><a href="#思路-81" class="headerlink" title="思路"></a>思路</h5><h5 id="代码-76"><a href="#代码-76" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0;
        int right = 0;
        while(right &lt; nums.length) {
            if (nums[right] != 0) {
                int temp = nums[right];
                nums[right] = nums[left];
                nums[left] = temp;
                left++;
            }
            right++;
        }
        return;
    }
}
</code></pre>
<h5 id="复杂度-70"><a href="#复杂度-70" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h3><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>
<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
<h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4><h5 id="思路-82"><a href="#思路-82" class="headerlink" title="思路"></a>思路</h5><p>描述</p>
<h5 id="代码-77"><a href="#代码-77" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int findDuplicate(int[] nums) {
        int fast = 0;
        int low = 0;
        do{
            fast = nums[fast];
            fast = nums[fast];
            low = nums[low];
        }while(fast!=low);				//思想, 先判断有无环
        
        low = 0;						//思想,将慢指针置为起始点,然后快慢再一起移动, 再相遇时就是环的入口
        while(low!=fast){
            low = nums[low];
            fast = nums[fast];
        }
        return low;
    }
}
</code></pre>
<h5 id="复杂度-71"><a href="#复杂度-71" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$「Floyd 判圈算法」时间复杂度为线性的时间复杂度。</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<h4 id="动态规划-5"><a href="#动态规划-5" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="思路-83"><a href="#思路-83" class="headerlink" title="思路"></a>思路</h5><p>动态规划方程:</p>
<p>f[i]表示以第i个位置结尾的递增子序列的长度, 就等于扫描一遍该位置前面的f[j], 如果nums[i] &gt; nums[j]的话, f[i] = f[j]+1之间的最大值<br>$$<br>f[i] = Math.max(f_{j=1}^{i-1}[j]+1) if(nums[i]&gt;nums[j])<br>$$</p>
<h5 id="代码-78"><a href="#代码-78" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int lengthOfLIS(int[] nums) {
        int []f = new int[nums.length];
        f[0] = 1;
        for(int i = 1; i &lt; nums.length; i++){
            f[i] = 1;
            for(int j = 0; j &lt; i; j++){
                if(nums[i] &gt; nums[j]) {
                    f[i] = Math.max(f[j]+1,f[i]);		//思想, 递归方程
                }
            }
        }
        int result = Integer.MIN_VALUE;
        for(int i = 0; i&lt;nums.length;i++){				//思想, 是所有中最大的那个, 并不一定是最后的那个
            result = Math.max(f[i],result);
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-72"><a href="#复杂度-72" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N^2)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h3><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<pre><code>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
</code></pre>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h4 id="动态规划-6"><a href="#动态规划-6" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="思路-84"><a href="#思路-84" class="headerlink" title="思路"></a>思路</h5><p>第i天有这么几种可能性f[i], f[i]记为净收益:</p>
<ul>
<li>现在手上持有股票<ul>
<li>这种状态只能由第i-1天持有股票或者第i-1天可以购买股票时净收益减去今天购买股票花费转化而来</li>
<li>$$f[i][0] = max( f[i-1][0], f[i-1][2]-prices[i])$$</li>
</ul>
</li>
<li>现在处于冷冻期<ul>
<li>这种状态只能由第$$i-1$$天持有股票转化而来</li>
<li>$$f[i][1] = f[i-1][1]+prices[i]$$</li>
</ul>
</li>
<li>现在既不持有股票也不处于冷冻期(可以购买股票<ul>
<li>这种情况由第$$i-1$$天为冷冻期或者第$$i-1天$$可以购买股票转换而来</li>
<li>$$f[i][2] = Math.max(f[i-1][1], f[i-1][2])$$</li>
</ul>
</li>
</ul>
<h5 id="代码-79"><a href="#代码-79" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int maxProfit(int[] prices) {
        int[][] f= new int[prices.length][3];
        f[0][0] = -prices[0];       //持有股票的净收益
        f[0][1] = 0;                //冷冻期的净收益
        f[0][2] = 0;                //可以购买股票的净收益

        for(int i = 1; i &lt; prices.length; i++){
            f[i][0] = Math.max(f[i-1][0], f[i-1][2]-prices[i]);
            f[i][1] = f[i-1][0]+prices[i];
            f[i][2] = Math.max(f[i-1][1], f[i-1][2]);
        }
        return Math.max(f[prices.length-1][1],f[prices.length-1][2]);
    }
}
</code></pre>
<h5 id="复杂度-73"><a href="#复杂度-73" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h3><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
</code></pre>
<h4 id="从上往下记忆化搜索"><a href="#从上往下记忆化搜索" class="headerlink" title="从上往下记忆化搜索"></a>从上往下记忆化搜索</h4><h5 id="思路-85"><a href="#思路-85" class="headerlink" title="思路"></a>思路</h5><p>$$<br>F[n] = \min_{i=0…n-1}(F[n-c_i])+1<br>\<br>F[0] = 0<br>\<br>F[负数] = -1<br>$$</p>
<h5 id="代码-80"><a href="#代码-80" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount &lt; 1) {
            return 0;
        }
        return coinChange(coins, amount, new int[amount]);
    }
    private int coinChange(int[] coins, int rem, int[] f) {    //返回
        if(rem &lt; 0) {
            return -1;      //表示组成不了
        }

        if(rem == 0) {
            return 0;       //表示恰好组成
        }

        if(f[rem-1] != 0) { //记忆化搜索
            return f[rem-1];
        }

        int min = Integer.MAX_VALUE;
        for(int coin:coins) {
            int res = coinChange(coins, rem-coin, f);
            if(res &gt;= 0 &amp;&amp; res &lt; min) {     //能组成并且比其他的方案需要硬币小
                min = res + 1;
            }
            
        }
        f[rem-1] = (min==Integer.MAX_VALUE)?-1:min;
        return f[rem-1];
    }
}
</code></pre>
<h5 id="复杂度-74"><a href="#复杂度-74" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(Sn)$, S为状态数, n为面值数, 每个状态遍历面值计算一遍</li>
<li>空间: $O(S)$, S的数组来存储计算出来的答案</li>
</ul>
<h4 id="动态规划-7"><a href="#动态规划-7" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="思路-86"><a href="#思路-86" class="headerlink" title="思路"></a>思路</h5><p>$$<br>F[0] = 0;<br>f[S] = \min_{i=0,n-1}(f[S-coin_i])+1<br>$$</p>
<h5 id="代码-81"><a href="#代码-81" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount+1;
        int []f = new int[amount+1];
        Arrays.fill(f, max);
        f[0] = 0;
        for(int i = 1 ; i &lt;= amount; i++) {
            int min = max;
            for(int j = 0; j &lt; coins.length; j++){
                int res = (i-coins[j])&lt;0 ?max:f[i-coins[j]]+ 1;
                if(res&lt;min){
                    min = res;
                }
            }
            f[i] = min;
        }
        if(f[amount] &gt;= max) return -1;
        else return f[amount];
    }

}
</code></pre>
<h5 id="复杂度-75"><a href="#复杂度-75" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(Sn)$</li>
<li>空间: $O(S)$</li>
</ul>
<h3 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a></h3><p>给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 2
输出：[0,1,1]
解释：
0 --&gt; 0
1 --&gt; 1
2 --&gt; 10
</code></pre>
<h4 id="动态规划-self-6"><a href="#动态规划-self-6" class="headerlink" title="动态规划(self"></a>动态规划(self</h4><h5 id="思路-87"><a href="#思路-87" class="headerlink" title="思路"></a>思路</h5><p>动态规划方程:<br>$$<br>ans[i] = ans[i&gt;&gt;1]+(i%2==1)?1:0<br>$$</p>
<h5 id="代码-82"><a href="#代码-82" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] countBits(int n) {
        int[]ans = new int[n+1];
        if(n &lt; 1) return ans;
        ans[0] = 0;
        for(int i = 1; i &lt;= n; i++){
            int num = i;
            if(i % 2 == 0){
                ans[i] = ans[num&gt;&gt;1];				//语法
            }else{
                ans[i] = ans[num&gt;&gt;1]+1;
            }
        }
        return ans;
    }
}
</code></pre>
<h5 id="复杂度-76"><a href="#复杂度-76" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(N)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<h4 id="哈希表-优先队列-堆"><a href="#哈希表-优先队列-堆" class="headerlink" title="哈希表+优先队列(堆)"></a>哈希表+优先队列(堆)</h4><h5 id="思路-88"><a href="#思路-88" class="headerlink" title="思路"></a>思路</h5><p>哈希表计数, 优先队列为小顶堆存储计数结果, 如果队列长度小于k, 则直接入队, 队列长度大于k, 出堆顶然后入队.</p>
<h5 id="代码-83"><a href="#代码-83" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;();
        for(int i = 0; i &lt; nums.length; i++){
            m.put(nums[i], m.getOrDefault(nums[i],0)+1);
        }

        //语法
        PriorityQueue&lt;int[]&gt; queue= new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;(){
            public int compare(int[] a, int [] b){
                return a[1] - b[1];
            }
        });

        for(Map.Entry&lt;Integer, Integer&gt; entry : m.entrySet()){  //语法
            int num = entry.getKey();
            int count = entry.getValue();
            if(queue.size() == k) {                 //思想
                if(queue.peek()[1] &lt; count){
                    queue.poll();
                    queue.offer(new int[]{num, count});
                }
            } else {
                queue.offer(new int[]{num, count});
            }
        }
        int []result = new int[k];
        for (int i = 0; i &lt; k; i++) {
            result[i] = queue.poll()[0];
        }
        return result;
    }
}
</code></pre>
<h5 id="复杂度-77"><a href="#复杂度-77" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(Nlogk)$k为堆的节点数目</li>
<li>空间: $O(N)$</li>
</ul>
<h3 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<pre><code>示例 1：

输入：s = "3[a]2[bc]"
输出："aaabcbc"
</code></pre>
<p>提示：</p>
<pre><code>1 &lt;= s.length &lt;= 30
s 由小写英文字母、数字和方括号 '[]' 组成
s 保证是一个 有效 的输入。
s 中所有整数的取值范围为 [1, 300] 
</code></pre>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h5 id="思路-89"><a href="#思路-89" class="headerlink" title="思路"></a>思路</h5><ul>
<li>遇到<code>]</code><ul>
<li>弹出栈内字符直到遇到<code>[</code>, 得到<code>[</code>前面的数字, 然后将重复的字符串再入栈</li>
</ul>
</li>
<li>其他<ul>
<li>入栈</li>
</ul>
</li>
</ul>
<h5 id="代码-84"><a href="#代码-84" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public String decodeString(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for(int i = 0; i &lt; s.length(); i++) {
            if(s.charAt(i) != ']') {
                stack.push(s.charAt(i));
            }else{
                char topChar;
                String str="";
                while(stack.peek() != '[') {
                    topChar = stack.pop();
                    str = topChar+str;
                }
                stack.pop();            //弹出'['
                String numString = "";  //数组为多位数
                while(!stack.empty() &amp;&amp; stack.peek() &gt;= '0' &amp;&amp; stack.peek() &lt;= '9') {
                    topChar = stack.pop();
                    numString = topChar + numString;
                }

                int count = Integer.parseInt(numString);
                for(int j = 0; j &lt; count; j++) {
                    for(int k = 0; k &lt; str.length(); k++) {
                        stack.push(str.charAt(k));
                    }
                }
            }
        }

        List&lt;Character&gt; resultList = new ArrayList&lt;&gt;(stack);
        String result = "";
        for(Character c:resultList) {
            result+=c;
        }
        return result;
    }
    
}
</code></pre>
<h5 id="复杂度-78"><a href="#复杂度-78" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(S)$ S为解码后的字符串长度</li>
<li>空间: $O(S)$</li>
</ul>
<h3 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h3><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<pre><code>示例 1：

输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/queue-reconstruction-by-height
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。模:sob:
</code></pre>
<h4 id="动态规划-sob"><a href="#动态规划-sob" class="headerlink" title="动态规划:sob:"></a>动态规划<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><h5 id="思路-90"><a href="#思路-90" class="headerlink" title="思路"></a>思路</h5><p>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]], 思路是每次挑选这个位置上应该存在的人</p>
<ol>
<li><p>首先挑选正确答案第0个位置的人, 这个人一定是k=0并且h是最小的, 因为这个人k=0表明前面没有比它等高或更高的,</p>
<p>利用反证法: 假设这个人<code>队头</code>的人, 那么一定存在一个比它更矮的人, 并且k=0, 但这个人不存在, 说明挑选正确.</p>
</li>
<li><p>然后, 把队头挑选出来后, 其他位置的人肯定排在他的后面, 所以如果身高小于等于这个<code>队头</code>话, k要减一, 然后重复第1个步骤.</p>
</li>
</ol>
<pre><code>1. 挑选出[5,0], 新k: [7,0],[4,3],[7,1],[6,1],[5,1], 原来k:[7,0],[4,4],[7,1],[6,1],[5,2], 此时队列内为5,0],
2. 挑选出[7,0]对应的原来[7,1],新k:[4,2],[7,0],[6,0],[5,0],原来k:[4,3],[7,1],[6,1],[5,1],此时队列内为[5,0],[7,1]
3. 挑选出新k队列的[5,0]对应的原来[5,2],新k:[4,1],[7,0],[6,0]此时队列为[5,0],[7,1],[5,2]
4. 挑选出[6,0]对应的原来[6,1], 新k: [4,0],[7,0] 此时队列为[5,0],[7,1],[5,2], [6,1]
5. 挑选出[4,0]对应的原来[4,4], 新k:[7,0], 此时队列为[5,0],[7,1],[5,2], [6,1], [4,4]
6. 挑选出[7,0]对应的原来[7,1], 此时队列为[5,0],[7,1],[5,2], [6,1], [4,4],[7,1]
</code></pre>
<h5 id="代码-85"><a href="#代码-85" class="headerlink" title="代码"></a>代码</h5><pre><code>\\语法, 以后搜索\\语法可以学习语法
\\思想, 学习思想
</code></pre>
<h4 id="h逆序k顺序排序-插队"><a href="#h逆序k顺序排序-插队" class="headerlink" title="h逆序k顺序排序+插队*"></a>h逆序k顺序排序+插队*</h4><h5 id="思路-91"><a href="#思路-91" class="headerlink" title="思路"></a>思路</h5><blockquote>
<p>为什么要按照身高降序和k升序排列呢？ 举个例子，[7, 0] [7, 1] [6, 1] [5, 0] [5, 2] [4, 4],</p>
<ol>
<li>迎面走来了最高之人，身高为 7，他往队伍第 0 个位置一站，由于目前队伍为空，所以他的到来没有影响到其他人，目前队伍为 [[7, 0]]</li>
<li>接下来走来了身高第二高之人，身高也是 7，他可以站在第一位哥们的前面或者后面，好的我们一起来看看他的选择：他选择了位置 1！为什么呢？因为 k 按照升序排列！所以虽然他身高也是 7，但是他站在了第一位哥们的后面。目前队伍：[[7, 0], [7, 1]]</li>
<li>接下来迎面走来的是第三个人，他的身高为 6，k 为 1，代表他前面只有 1 位比他高或者一样高的哥们，他挤了挤原先在位置 1  的老哥，因为老哥的身高为 7，比他高所以老哥往后挪了一个位置也没什么影响。目前队伍：[[7, 0], [6, 1], [7, 1]]</li>
<li>省略。。。</li>
</ol>
</blockquote>
<h5 id="代码-86"><a href="#代码-86" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (a,b)-&gt;{
            // if (a[0] == b[0]) return a[1] - b[1];
            // return b[0] - a[0];
            if(a[0] != b[0]) return b[0]-a[0];          //思想, 身高从大到小为逆序
            return a[1]-b[1];                           //思想, 再k从小到大顺序
        });

        List&lt;int[]&gt; queue = new LinkedList&lt;&gt;();
        for(int[] item:people) {
            queue.add(item[1], item);
        }
        return queue.toArray(new int[people.length][]);         //语法
    }
}
</code></pre>
<h5 id="复杂度-79"><a href="#复杂度-79" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<pre><code>示例 1：

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
</code></pre>
<pre><code>示例 2：

输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
</code></pre>
<h4 id="动态规划-0-1背包"><a href="#动态规划-0-1背包" class="headerlink" title="动态规划(0-1背包)"></a>动态规划(0-1背包)</h4><h5 id="思路-92"><a href="#思路-92" class="headerlink" title="思路"></a>思路</h5><p>这道题可以变换为, <strong>给一个数组, 其中的若干个数字之和是否等于该数组总加和的一半</strong>.</p>
<p>可以先列出几个明显的false的情况:</p>
<ul>
<li>如果数组加和等于奇数, 则必定不可以</li>
<li>如果数组元素个数等于1, 则必定不可以</li>
</ul>
<p>然后就可以用动态规划来做了, 动态规划方程为:</p>
<p>$dp[i][j]$的含义是数组[0,i]中是否有若干个数字之和等于j, 其中$i$的取值范围为$[0,n-1]$, $j$的取值范围是$[0,target]$.<br>$$<br>dp[i][j] =<br>\begin{cases}<br>    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];(j&gt;=nums[i])	\<br>    dp[i][j] = dp[i-1][j];(j&lt;nums[i])<br>\end{cases}<br>$$<br>初始条件是:<br>$$<br>dp[0…n][0] = true, 表示数组的任意i个之前的数字之后都可以等于0<br>$$</p>
<h5 id="代码-87"><a href="#代码-87" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public boolean canPartition(int[] nums) {
        int length = nums.length;
        int sum = 0;
        for (int i = 0; i &lt; length; i++) {
            sum += nums[i];
        }
        //length &lt; 2不可能
        if (length &lt; 2) return false;
        //nums[]的和为奇数不可能
        if (sum % 2 == 1) return false;

        int target = sum / 2;
        boolean[][] dp = new boolean[length][target + 1];   //dp[i][j]的含义是数组[0,i]中是否有若干个数字之和等于j		//语法 思想
        for(int i = 0; i &lt; length; i++) {
            dp[i][0] = true;
        }

        for (int i = 1; i &lt; length; i++) {
            for (int j = 0; j &lt; target + 1; j++) {
                if(j &gt;= nums[i]) {
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }

        return dp[length-1][target];

    }
}
</code></pre>
<h5 id="复杂度-80"><a href="#复杂度-80" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(n*sum/2)$</li>
<li>空间: $O(n * sum/2)$</li>
</ul>
<h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h3><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/solution/dui-qian-zhui-he-jie-fa-de-yi-dian-jie-s-dey6/">前缀和</a></h4><h5 id="思路-93"><a href="#思路-93" class="headerlink" title="思路"></a>思路</h5><p>前缀和的定义: 一个节点的前缀和就是<code>该节点</code>到<code>根</code>之间的路径和。</p>
<p>前缀和如何得出这道题的答案: (当前节点的前缀和 - targetNum)所对应的前缀和有几条线路, 就有几个答案</p>
<p>HashMap存的是什么: 以前缀和为key, 以该前缀和 所有的线路为value</p>
<p>状态恢复: 为什么要在遍历完节点之后, 将该节点的前缀和要不算进去</p>
<h5 id="代码-88"><a href="#代码-88" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    Map&lt;Long, Long&gt; preSumMap;          //以前缀和为key, 以该前缀和 所有的线路为value
    Long target;
    public int pathSum(TreeNode root, int targetSum){
        preSumMap = new HashMap&lt;&gt;();
        target = Long.valueOf(targetSum);
        preSumMap.put(0L, 1L);

        return recur(root, 0L).intValue();
    }

    private Long recur(TreeNode root, Long preSum){   //返回以root为根节点的符合题目条件的答案个数
        if(root == null) return 0L;
        Long curNum = Long.valueOf(root.val + preSum);
        Long res = preSumMap.getOrDefault(Long.valueOf(curNum-target), 0L); //获取以该节点为最后一个节点符合题目的答案
        preSumMap.put(Long.valueOf(curNum), preSumMap.getOrDefault(curNum, 0L)+1); //更新前缀和

        res += recur(root.left, curNum);        //得到以左孩子为根节点的符合题目的答案
        res += recur(root.right, curNum);       

        preSumMap.put(Long.valueOf(curNum), preSumMap.get(curNum)-1);   //状态恢复, 该节点遍历完之后的前缀和不应该再计算
        return res;
    }
}
</code></pre>
<h5 id="复杂度-81"><a href="#复杂度-81" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $$</li>
<li>空间: $$</li>
</ul>
<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<pre><code>示例 1:

输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
</code></pre>
<h4 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h5 id="思路-94"><a href="#思路-94" class="headerlink" title="思路"></a>思路</h5><p>先用一个数组(map)来计算字符串p的各个字符出现的次数, 然后设置一个滑动窗口, 来滑动字符串s的子串, 这个滑动窗口每向下滑动一次, 要减去被滑动出去的字符一次(i-1位置), 要加上被滑动进来的字符(i+pLen-1)一次, 然后比较新滑动窗口的子串和需要比较的字符串p的计数数组, 如果相等的话就等于.</p>
<h5 id="代码-89"><a href="#代码-89" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;Integer&gt; findAnagrams(String s, String p) {
        int sLen = s.length();
        int pLen = p.length();
        
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        if (sLen &lt; pLen) return ans;

        int [] sCount = new int[26];        //语法
        int [] pCount = new int[26];
        for(int i = 0; i &lt; pLen; i++) {
            ++sCount[s.charAt(i)-'a'];
            ++pCount[p.charAt(i)-'a'];
        }
        if(Arrays.equals(sCount, pCount)) { //语法
            ans.add(0);
        }

        for(int i = 1; i &lt;= sLen-pLen; i++) {        //思想,滑动到下标sLen-pLen
            --sCount[s.charAt(i-1)-'a'];             //思想,把i-1滑出去了, 所以要减去[i-1]这个字母
            ++sCount[s.charAt(i+pLen-1)-'a'];        //思想,把i+pLen-1滑进去来了
            if(Arrays.equals(sCount, pCount)) {  //语法
                ans.add(i);
            }
        }
        return ans;
    }
}
</code></pre>
<h5 id="复杂度-82"><a href="#复杂度-82" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间:$O(m+(n−m)×Σ)$，其中 n 为字符串 s 的长度，m 为字符串 p 的长度，Σ 为所有可能的字符数。</li>
<li>空间: $O(Σ)$</li>
</ul>
<h3 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></h3><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p>
<pre><code>示例 1：

输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
</code></pre>
<h4 id="额外等长标志数组-self"><a href="#额外等长标志数组-self" class="headerlink" title="额外等长标志数组(self"></a>额外等长标志数组(self</h4><h5 id="思路-95"><a href="#思路-95" class="headerlink" title="思路"></a>思路</h5><p>用一个额外的数组, 对于数组中的数字用作额外数组中的下标进行标记.</p>
<h5 id="代码-90"><a href="#代码-90" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) {
        int len = nums.length;
        int [] flag = new int[len];
        for(int i = 0; i &lt; len; i++) {
            flag[nums[i]-1] = 1;
        }

        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        for(int i = 0; i &lt; len; i++) {
            if(flag[i] == 0) ans.add(i+1);
        }
        return ans;
    }
}
</code></pre>
<h5 id="复杂度-83"><a href="#复杂度-83" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(n), n为数组长度$,</li>
<li>空间: $O(n)$</li>
</ul>
<h4 id="原地哈希"><a href="#原地哈希" class="headerlink" title="原地哈希*"></a>原地哈希*</h4><h5 id="思路-96"><a href="#思路-96" class="headerlink" title="思路"></a>思路</h5><p>对数组中的每个数字, 让对应下标上的数字变为负数, 这样最后扫描一下数组哪个位置上的数字为正数, 就说明该下标没出现过</p>
<h5 id="代码-91"><a href="#代码-91" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) {
        int len = nums.length;
        for(int num:nums) {
            int index = Math.abs(num)-1;            //思想, 必须取绝对值, 因为数字可能已经被反转过了会出现负数
            nums[index] = -Math.abs(nums[index]);   //思想, 取绝对值后再取负
        }

        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        for(int i = 0; i &lt; len; i++) {
            if(nums[i] &gt; 0) ans.add(i+1);
        }
        return ans;
    }
}
</code></pre>
<h5 id="复杂度-84"><a href="#复杂度-84" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(n)$</li>
<li>空间: $O(n)$</li>
</ul>
<h3 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hamming-distance/">461. 汉明距离</a></h3><p>两个整数之间的 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p>
<pre><code>示例 1：

输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
</code></pre>
<h4 id="位运算-2"><a href="#位运算-2" class="headerlink" title="位运算"></a>位运算</h4><h5 id="思路-97"><a href="#思路-97" class="headerlink" title="思路"></a>思路</h5><p>先异或, 然后再右移与1做与运算, 计数</p>
<h5 id="代码-92"><a href="#代码-92" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int hammingDistance(int x, int y) {
        int z = x ^ y;
        int ans = 0;
        for(int i = 0; i &lt;32; i++) {
            if((z &amp; 1) == 1) ans = ans + 1;
            z = z &gt;&gt; 1;
        }
        return ans;
    }
}
</code></pre>
<h5 id="复杂度-85"><a href="#复杂度-85" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(1)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h3><p>给你一个整数数组 nums 和一个整数 target 。</p>
<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p>
<pre><code>例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
</code></pre>
<p>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
<pre><code>示例 1：

输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
</code></pre>
<h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><h5 id="思路-98"><a href="#思路-98" class="headerlink" title="思路"></a>思路</h5><ol>
<li>回溯法是一种待优化的穷举法</li>
<li>回溯法的基本思想是在一棵含有问题全部可能解的状态空间树上进行深度优先搜索，解为叶子结点。搜索过程中，每到达一个结点时，则判断该结点为根的子树是否含有问题的解，如果可以确定该子树中不含有问题的解，则放弃对该子树的搜索，退回到上层父结点，继续下一步深度优先搜索过程。</li>
<li>在回溯法中，并不是先构造出整棵状态空间树，再进行搜索，而是在搜索过程，逐步构造出状态空间树，即边搜索，边构造。</li>
</ol>
<h5 id="代码-93"><a href="#代码-93" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    int count;
    public int findTargetSumWays(int[] nums, int target) {
        count = 0;
        backTrack(nums, target, 0, 0);  //下一个应该计算下标的0的位置, 并且和为0
        return count;
    }

    //index: 下一个应该计算的位置, sum: 目前的和
    private void backTrack(int[] nums, int target, int index, int sum) {
        if(index == nums.length) {							//思想
            //到了最后的终点判断
            if(sum == target) {
                count++;
            }
        }else{
            backTrack(nums, target, index+1, sum+nums[index]);//思想
            backTrack(nums, target, index+1, sum-nums[index]);//思想
        }
    }
}
</code></pre>
<h5 id="复杂度-86"><a href="#复杂度-86" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(2^n)$</li>
<li>空间: $O(n), n为递归栈的深度$</li>
</ul>
<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<pre><code>节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节点键的节点。
左右子树也必须是二叉搜索树。
</code></pre>
<p><img src="https://raw.githubusercontent.com/pengber/pic-bed/main/img/tree.png" alt="tree"></p>
<h4 id="中序逆序遍历"><a href="#中序逆序遍历" class="headerlink" title="中序逆序遍历"></a>中序逆序遍历</h4><h5 id="思路-99"><a href="#思路-99" class="headerlink" title="思路"></a>思路</h5><p>中序逆序遍历则就是一个由大到小的排列, 然后用一个全局变量存储每次遍历前的加和即可.</p>
<h5 id="代码-94"><a href="#代码-94" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    int sum = 0;                    //思想
    public TreeNode convertBST(TreeNode root) {
        midTravel(root);
        return root;
    }
    //反序中序遍历会得到一个由大到小的数字, 加和赋值即可
    private void midTravel(TreeNode root) {   
        if(root == null) return;
        midTravel(root.right);
        sum += root.val;                    //思想
        root.val = sum;                     //思想
        midTravel(root.left);
    }
}
</code></pre>
<h5 id="复杂度-87"><a href="#复杂度-87" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(n), n为树的节点个数$</li>
<li>空间: $O(n), n为递归栈的最大深度, 最坏情况下为节点的个数$</li>
</ul>
<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<pre><code>示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    

返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
</code></pre>
<h4 id="问题转化"><a href="#问题转化" class="headerlink" title="问题转化"></a>问题转化</h4><h5 id="思路-100"><a href="#思路-100" class="headerlink" title="思路"></a>思路</h5><p>问题可以转化成: 二叉树的 每个节点的左右子树的高度和+2 的最大值(+2是因为左右子树连接父节点也有两条边), 而在深度优先遍历求得树高的时候是得到过左右子树高度的。</p>
<p>我觉得这道题最妙的地点在于: 在深度遍历求得树高度的同时, 答案需要的左右子树高度都有, 所以能得到答案.</p>
<h5 id="代码-95"><a href="#代码-95" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    int ans = 0;
    private int depth(TreeNode root) {
        if(root!=null) {
           int leftHeight = depth(root.left);
           int rightHeight = depth(root.right);
           ans = Math.max(ans, leftHeight + rightHeight+2);	//思想,根据左右子树高度得到答案
           return Math.max(leftHeight, rightHeight) + 1;    //思想,返回树的高度
        }else{
            return -1;                  //思想, 注意, 返回的是树的高度, null的高度应该算作-1
        }     
    }
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return ans;
    }
}
</code></pre>
<h5 id="复杂度-88"><a href="#复杂度-88" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(n), n为节点的个数$</li>
<li>空间: $O(n),最坏情况下为n$</li>
</ul>
<h3 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的连续子数组的个数</em> 。</p>
<pre><code>示例 1：

输入：nums = [1,1,1], k = 2
输出：2
</code></pre>
<h4 id="前缀和-双重遍历-self"><a href="#前缀和-双重遍历-self" class="headerlink" title="前缀和+双重遍历(self"></a>前缀和+双重遍历(self</h4><h5 id="思路-101"><a href="#思路-101" class="headerlink" title="思路"></a>思路</h5><p>先求每个位置的前缀和, 然后双重遍历, </p>
<p>第一重遍历到每个下标:</p>
<p>​    从这个下标起开始第二重遍历:<br>​         这个下标对应的前缀和 + k在后面出现了几次, 就计数几次.<br>​         另外如果这个下标的前缀和如果直接等于k, 则也要计数一次</p>
<h5 id="代码-96"><a href="#代码-96" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;      //没有递归, 不用全局变量
        for(int i = 1; i &lt; nums.length; i++) {
            nums[i] = nums[i-1] + nums[i];          //计算前缀和
        }
        for(int i = 0; i &lt; nums.length; i++) {
            int start = nums[i];
            int end = k + start;
            if(start == k) {                        //思想, 如果这个下标的前缀和等于目标数字, 直接计数一次
                count++;
            }
            for (int j = i+1; j &lt; nums.length; j++){ 
                if(end == nums[j]) count++;         //思想, 找符合start+k的前缀和的个数, 表明连续
            }
        }
        return count;
    }
}
</code></pre>
<h5 id="复杂度-89"><a href="#复杂度-89" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(n^2, n为数组的大小)$</li>
<li>空间: $O(1)$</li>
</ul>
<p><strong>优化:</strong></p>
<p>不关心具体的解的话, 求出前缀和的同时将前缀和用map来存储, 之后只要从map中提取前缀和出现的次数就可以了</p>
<h3 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></h3><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>请你找出符合题意的 最短 子数组，并输出它的长度。</p>
<pre><code>示例 1：

输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
</code></pre>
<h4 id="数学规律"><a href="#数学规律" class="headerlink" title="数学规律"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/solution/si-lu-qing-xi-ming-liao-kan-bu-dong-bu-cun-zai-de-/">数学规律</a></h4><h5 id="思路-102"><a href="#思路-102" class="headerlink" title="思路"></a>思路</h5><p>从左往右, 找到比左边最大值还小的最右下标, 从右往左, 找到比右边最小值还大的最左下标</p>
<h5 id="代码-97"><a href="#代码-97" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int len = nums.length;
        int max = nums[0];
        int left = 0;
        int right = 0;
        int min = nums[len-1];

        for(int i = 0; i &lt; len; i++) {
            if(nums[i] &gt;= max) max = nums[i];
            else right = i;                     //思想, 右索引是比numsB中最大元素的更小的最右边的那个(numsC比numsB都小)

            if(nums[len-i-1] &lt;= min) min = nums[len-i-1];
            else left = len-i-1;                //思想, 左索引是比numsB中最小元素的更大的最左边的那个(numsA比numsB都小)
        }
        return right!=0?right-left+1:0;
    }
}
</code></pre>
<h5 id="复杂度-90"><a href="#复杂度-90" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(n)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="排序比较"><a href="#排序比较" class="headerlink" title="排序比较"></a>排序比较</h4><h5 id="思路-103"><a href="#思路-103" class="headerlink" title="思路"></a>思路</h5><p>将数组进行排序, 然后比较, 最左边的与原数组不相同的位置 和 最右边的与原数组不相同的位置.</p>
<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><p>给你两棵二叉树： root1 和 root2 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p>注意: 合并过程必须从两个树的根节点开始。</p>
<h4 id="递归-self"><a href="#递归-self" class="headerlink" title="递归(self"></a>递归(self</h4><h5 id="思路-104"><a href="#思路-104" class="headerlink" title="思路"></a>思路</h5><p>就递归</p>
<h5 id="代码-98"><a href="#代码-98" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null &amp;&amp; root2 == null) return null;     //思想, 递归终止条件

        TreeNode root = new TreeNode();
        int root1_val = root1==null?0:root1.val;
        int root2_val = root2==null?0:root2.val;
        root.val = root1_val + root2_val;

        TreeNode root_left = mergeTrees(root1==null?null:root1.left, root2==null?null:root2.left);
        TreeNode root_right = mergeTrees(root1==null?null:root1.right, root2==null?null:root2.right);
        root.left = root_left;
        root.right = root_right;

        return root;
    }
}
</code></pre>
<h3 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/task-scheduler/">621. 任务调度器</a></h3><p>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>
<p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的 最短时间 。</p>
<h4 id="脑筋急转弯"><a href="#脑筋急转弯" class="headerlink" title="脑筋急转弯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/task-scheduler/solution/by-ac_oier-3560/">脑筋急转弯</a></h4><h5 id="思路-105"><a href="#思路-105" class="headerlink" title="思路"></a>思路</h5><p>最短时间和”冷却时间n”以及”计数最多的字符个数(tot)”有关:<br>$$<br>(n+1)×(max⁡−1)+tot<br>$$<br><strong>实际上，当任务总数不超过 (n+1)×(max⁡−1)+tot 时，我们总能将其他任务插到空闲时间中去，不会引入额外的冻结时间（下左图）；而当任务数超过该值时，我们可以在将其横向添加每个 n+1 块的后面，同时不会引入额外的冻结时间</strong></p>
<p>所以, 最后就取两者之间的最大值</p>
<h5 id="代码-99"><a href="#代码-99" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int leastInterval(char[] tasks, int n) {
        int[] char_nums = new int[26];      //默认初始化为0
        int max = 0;
        for(char task:tasks){
            char_nums[task-'A']++;
            max = char_nums[task-'A'] &gt; max ? char_nums[task-'A'] : max;
        }
        int count = 0;
        for(int num:char_nums) {
            if(num == max) count++;
        }
        return Math.max(tasks.length, (max-1)*(n+1)+count);

    }
}
</code></pre>
<h5 id="复杂度-91"><a href="#复杂度-91" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(n)$</li>
<li>空间: $O(1)$</li>
</ul>
<h3 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h3><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p>
<p>回文字符串 是正着读和倒过来读一样的字符串。</p>
<p>子字符串 是字符串中的由连续字符组成的一个序列。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<pre><code>示例 1：

输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
</code></pre>
<h4 id="暴力枚举-self"><a href="#暴力枚举-self" class="headerlink" title="暴力枚举(self"></a>暴力枚举(self</h4><h5 id="思路-106"><a href="#思路-106" class="headerlink" title="思路"></a>思路</h5><p>暴力枚举每一个子串是否是回文串</p>
<h5 id="代码-100"><a href="#代码-100" class="headerlink" title="代码"></a>代码</h5><pre><code>class Solution {
    public int countSubstrings(String s) {
        int count = s.length();       //一位子串必定是回文串
        for(int i = 2; i &lt;= s.length(); i++) {
            int num = countHelp(s, i);
            //System.out.println(i + "-" + num);
            count += num;
        }
        return count;
    }

    public int countHelp(String s, int n) {
        //返回n位子串的回文子串的个数
        int count = 0;
        for (int i = 0; i &lt;= s.length()-n; i++) {	//思想
            int start = i;
            for(int j = 0; j &lt; n/2; j++) {          //判断是否是回文串
                if(s.charAt(start+j)== s.charAt(start+n-1-j)) continue;
                else {
                    count--;
                    break;
                }
            }
            count++;
        }
        return count;
    }
}
</code></pre>
<h5 id="复杂度-92"><a href="#复杂度-92" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(n^3)$</li>
<li>空间: $O(1)$</li>
</ul>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h4 id="回溯-4"><a href="#回溯-4" class="headerlink" title="回溯"></a>回溯</h4><h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h3><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<pre><code>示例 1:

输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
</code></pre>
<h4 id="双重循环-self"><a href="#双重循环-self" class="headerlink" title="双重循环(self"></a>双重循环(self</h4><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><h5 id="思路-107"><a href="#思路-107" class="headerlink" title="思路"></a>思路</h5><p>用一个单调栈存储一个温度从大到小的下标, 遍历temperatures, </p>
<ul>
<li><p>如果栈为空, 则入栈当前下标</p>
</li>
<li><p>如果当前位置比栈顶要大, 则不断出栈比当前位置小的元素的下标并且就能得到出栈下标位置的答案(i-top), 直到栈顶元素的下标对应的温度比当前位置对应的温度大(也就是温度从大到小的下标)</p>
</li>
<li><p>如果当前位置比栈顶要小, 则直接入栈</p>
</li>
</ul>
<p>道理很好理解, 现在要找的是当前位置最近的比当前位置更大温度的距离, 用这种方法, 遍历当前位置, 对于栈里面比当前位置小的, 则可以用当前位置和栈里面存储的下标直接得出答案, 对于栈里面比当前位置温度大的, 则什么也不干, 入栈当前位置, 维护温度从大到小的下标即可.</p>
<h5 id="代码-101"><a href="#代码-101" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int [] ans = new int[temperatures.length];
        Stack&lt;Integer&gt; s = new Stack();
        for (int i = 0; i &lt; temperatures.length; i++) {
            if(s.empty()) s.push(i);
            else{
                int top = s.peek();
                while(temperatures[top] &lt; temperatures[i]) {
                    ans[top] = i - top;
                    s.pop();
                    if(s.empty()) break;
                    else top = s.peek();
                }
                s.push(i);
            }
        }
        return ans;
    }
}
</code></pre>
<h5 id="复杂度-93"><a href="#复杂度-93" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间: $O(n)$</li>
<li>空间: $O(n)$</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 欢迎在评论区中进行批评指正，转载请注明来源，如涉及侵权，请联系作者删除。 </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments">
    <script src="https://utteranc.es/client.js"
            repo="pengber/pengber.github.io"
            issue-term="pathname"
            theme="github-light"
            label="comment"
            crossorigin="anonymous"
            async>
    </script>
</div>




    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2022-2022 pengber
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
        /* 渲染*/
        function HTMLDecode(text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            temp = null;
            return output;
        }
        if (window.mermaid){
            window.mermaid = null
        }
        $.getScript("//cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js", function () {
            var mermaidOptions = JSON.parse(HTMLDecode("{&#34;theme&#34;:&#34;default&#34;,&#34;startOnLoad&#34;:true,&#34;flowchart&#34;:{&#34;useMaxWidth&#34;:false,&#34;htmlLabels&#34;:true}}"))
            if (window.mermaid) {
                mermaid.initialize(mermaidOptions)
                mermaid.contentLoaded()
            }
        })
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 622px;
    }
    .nav.fullscreen {
        margin-left: -622px;
    }
    .nav-left {
        width: 200px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 552px;
        }
        .nav.fullscreen {
            margin-left: -552px;
        }
        .nav-left {
            width: 160px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 552px;
            margin-left: -552px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
